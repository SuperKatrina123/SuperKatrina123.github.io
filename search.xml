<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>布局 | flex布局</title>
    <url>/2022/07/17/CSS/%E5%B8%83%E5%B1%80_flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>flex（flexible box）布局意为弹性布局，用来为盒装模型提供最大的灵活性</p>
<p>flex布局通过<code>display:flex</code>进行调用，任何一个容器，即使是行内元素，都可以调用flex布局</p>
<p>注意：设置为flex布局后，子元素的<code>float</code> <code>clear</code> <code>vertical-align</code>属性将失效</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>采用flex布局由两种元素构成：</p>
<ul>
<li><p>容器：flex container</p>
</li>
<li><p>项目：flex item</p>
</li>
</ul>
</li>
<li><p>容器默认有两根轴：</p>
<ul>
<li>主轴：main axis【默认水平】</li>
<li>交叉轴：cross axis</li>
</ul>
</li>
<li><p>位置设定：</p>
<ul>
<li>主轴开始位置：main start</li>
<li>主轴结束位置：main end</li>
<li>副轴开始位置：cross start</li>
<li>副轴结束位置：cross end</li>
</ul>
</li>
<li><p>项目排列：</p>
<ul>
<li>项目默认按照主轴进行排序</li>
<li>main size：单个项目占据的主轴空间</li>
<li>cross size：单个项目占据的交叉轴空间</li>
</ul>
</li>
</ol>
<img src="/2022/07/17/CSS/%E5%B8%83%E5%B1%80_flex%E5%B8%83%E5%B1%80/flex%E5%B8%83%E5%B1%80.png" class title="flex布局">

<h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><h4 id="flex-direction-决定主轴的方向-x3dgt-主轴的方向决定着项目的排布方向"><a href="#flex-direction-决定主轴的方向-x3D-gt-主轴的方向决定着项目的排布方向" class="headerlink" title="flex-direction   决定主轴的方向 &#x3D;&gt; 主轴的方向决定着项目的排布方向"></a>flex-direction   决定主轴的方向 &#x3D;&gt; 主轴的方向决定着项目的排布方向</h4><ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿</li>
<li><code>column-reverse</code> ：主轴为垂直方向，起点在下沿</li>
</ul>
<h4 id="flex-warp-定义如果一条轴线排不下如何换行"><a href="#flex-warp-定义如果一条轴线排不下，如何换行" class="headerlink" title="flex-warp  定义如果一条轴线排不下，如何换行"></a>flex-warp  定义如果一条轴线排不下，如何换行</h4><ul>
<li><code>nowarp</code>（默认）：不换行 【会压缩项目的宽度】</li>
<li><code>wrap</code>：换行，第一行在上方</li>
<li><code>wrap-reverse</code>：不换行，第一行在下方</li>
</ul>
<h4 id="flex-flow-flex-direction-和-flex-warp的简写"><a href="#flex-flow-flex-direction-和-flex-warp的简写" class="headerlink" title="flex-flow  flex-direction 和 flex-warp的简写"></a>flex-flow  flex-direction 和 flex-warp的简写</h4><h4 id="justify-content-定义项目在主轴上的对齐方式"><a href="#justify-content-定义项目在主轴上的对齐方式" class="headerlink" title="justify-content  定义项目在主轴上的对齐方式"></a>justify-content  定义项目在主轴上的对齐方式</h4><ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>：居中</li>
<li><code>space-between</code>：两端对齐，项目之间间隔相等</li>
<li><code>space-around</code>：每个项目两侧间隔相等，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<h4 id="align-items-定义项目在交叉轴上如何对齐"><a href="#align-items-定义项目在交叉轴上如何对齐" class="headerlink" title="align-items 定义项目在交叉轴上如何对齐"></a>align-items 定义项目在交叉轴上如何对齐</h4><ul>
<li><code>flex-start</code>：交叉轴起点对齐</li>
<li><code>flex-end</code>：交叉轴终点对齐</li>
<li><code>center</code>：交叉轴中点对齐</li>
<li><code>baseline</code>：项目第一行文字的基线对齐</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或者<code>auto</code>，将占满整个容器的高度</li>
</ul>
<h4 id="align-content-定义多根轴线的对齐方式-如果项目只有一根轴线-则不起作用"><a href="#align-content-定义多根轴线的对齐方式-如果项目只有一根轴线-则不起作用" class="headerlink" title="align-content 定义多根轴线的对齐方式 如果项目只有一根轴线 则不起作用"></a>align-content 定义多根轴线的对齐方式 如果项目只有一根轴线 则不起作用</h4><ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴</li>
</ul>
<h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><h4 id="order-定义项目的排列顺序"><a href="#order-定义项目的排列顺序" class="headerlink" title="order 定义项目的排列顺序"></a>order 定义项目的排列顺序</h4><p>数值越小，排列越靠前，默认为0</p>
<h4 id="flex-grow-定义项目的方法比例"><a href="#flex-grow-定义项目的方法比例" class="headerlink" title="flex-grow 定义项目的方法比例"></a>flex-grow 定义项目的方法比例</h4><p>默认为0，即如果存在剩余空间，也不放大</p>
<p>如果所有项目的flex-grow属性都是1，则将它们等分剩余空间</p>
<p>如果有一个项目的flex-grow属性都是2，其余都为1，则前者占据的空间比其他项多一倍</p>
<h4 id="flex-shrink-定义项目的缩小比例"><a href="#flex-shrink-定义项目的缩小比例" class="headerlink" title="flex-shrink 定义项目的缩小比例"></a>flex-shrink 定义项目的缩小比例</h4><p>默认为1，即如果空间不足，则将该项目缩小</p>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小</p>
<p>如果一个项目的flex-shrink属性都为0，其余项目都为1，则空间不足，前者不缩小</p>
<h4 id="flex-basis-定义了在分配多余空间之前项目占据的主轴空间main-size"><a href="#flex-basis-定义了在分配多余空间之前，项目占据的主轴空间（main-size）" class="headerlink" title="flex-basis 定义了在分配多余空间之前，项目占据的主轴空间（main size）"></a>flex-basis 定义了在分配多余空间之前，项目占据的主轴空间（main size）</h4><p>默认值为auto，即原本的大小</p>
<p>可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间</p>
<h4 id="flex-flex-grow-flex-shrink-和-flex-basis的简写"><a href="#flex-flex-grow-flex-shrink-和-flex-basis的简写" class="headerlink" title="flex  flex-grow, flex-shrink 和 flex-basis的简写"></a>flex  <code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写</h4><p>默认值为<code>0 1 auto</code></p>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)</p>
<h4 id="align-self-允许单个项目有与其他项目不一样的对齐方式可覆盖align-items属性"><a href="#align-self-允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性" class="headerlink" title="align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性"></a>align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</h4><p>默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code></p>
<ul>
<li><code>auto</code></li>
<li><code>flex-start</code></li>
<li><code>flex-end</code></li>
<li><code>center</code></li>
<li><code>baseline</code></li>
<li><code>stretch</code></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex布局</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo | next主题添加搜索功能</title>
    <url>/2022/07/06/Hexo/Hexo-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>随着posts增多，考虑增加一个搜索功能（起初是因为看了NexT主题官方有个搜索功能觉得很酷），于是乎有了想法就立马行动起来！</p>
<p>其实搜索next主题的_config.yml文件，next主题已经帮我们写好了搜索功能相关的配置。</p>
<img src="/2022/07/06/Hexo/Hexo-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD1.png" class title="搜索功能1">

<p>所以打开上图中的github仓库进行相关配置即可。</p>
<h3 id="step1安装hexo-generator-searchdb"><a href="#Step1：安装hexo-generator-searchdb" class="headerlink" title="Step1：安装hexo-generator-searchdb"></a>Step1：安装hexo-generator-searchdb</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator-searchdb</span></span><br></pre></td></tr></table></figure>

<h3 id="step2在site里的_configxml增加如下配置"><a href="#Step2：在site里的-config-xml增加如下配置" class="headerlink" title="Step2：在site里的_config.xml增加如下配置"></a>Step2：在site里的_config.xml增加如下配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 站点搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>

<h3 id="step3把next主题的_configxml的配置打开"><a href="#Step3：把next主题的-config-xml的配置打开" class="headerlink" title="Step3：把next主题的_config.xml的配置打开"></a>Step3：把next主题的_config.xml的配置打开</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>    <span class="comment"># 这里原本是false 改为true即可</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li>侧边菜单增加了search</li>
</ul>
<img src="/2022/07/06/Hexo/Hexo-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD2.png" class title="搜索功能2">

<blockquote>
<p>注意：配置好了search功能后侧边菜单会自动更新，不需要去menu那里设置search</p>
</blockquote>
<ul>
<li>可以正常搜索</li>
</ul>
<img src="/2022/07/06/Hexo/Hexo-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD3.png" class title="搜索功能3">

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a></p>
<p><a href="https://blog.csdn.net/weixin_45877759/article/details/107141789">https://blog.csdn.net/weixin_45877759/article/details/107141789</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next个性化</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo | 初体验之建立个人博客</title>
    <url>/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="hexo建立个人博客"><a href="#Hexo建立个人博客" class="headerlink" title="Hexo建立个人博客"></a>Hexo建立个人博客</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>安装Git</li>
<li>安装Node</li>
<li>新建github仓库 仓库名为username.github.io</li>
<li>安装hexo 及初始化</li>
</ul>
<h3 id="hexo-command"><a href="#Hexo-Command" class="headerlink" title="Hexo Command"></a>Hexo Command</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span>  <span class="comment">#安装Hexo</span></span><br><span class="line">npm update hexo <span class="literal">-g</span> <span class="comment">#升级</span></span><br><span class="line">hexo init <span class="comment">#初始化博客</span></span><br><span class="line"></span><br><span class="line">hexo n <span class="string">&#x27;我的文章&#x27;</span> == hexo new <span class="string">&#x27;我的文章&#x27;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo g == hexo gengerate <span class="comment">#生成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动</span></span><br><span class="line">hexo d == hexo deploy <span class="comment">#部署</span></span><br><span class="line"></span><br><span class="line">hexo server <span class="comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span></span><br><span class="line">hexo server <span class="literal">-s</span> <span class="comment">#静态模式</span></span><br><span class="line">hexo server <span class="literal">-p</span> <span class="number">5000</span> <span class="comment">#更改端口</span></span><br><span class="line">hexo server <span class="literal">-i</span> <span class="number">192.168</span>.<span class="number">1.1</span> <span class="comment">#自定义IP</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存，若是网页正常情况可以忽略这条命令</span></span><br></pre></td></tr></table></figure>

<h2 id="新建post"><a href="#新建post" class="headerlink" title="新建post"></a>新建post</h2><p>按如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo new (post name)</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h2><img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E8%AF%B4%E6%98%8E1.png" class title="说明1">

<h3 id="关联hexo和github"><a href="#关联Hexo和Github" class="headerlink" title="关联Hexo和Github"></a>关联Hexo和Github</h3><p>在blog&#x2F;_config.yml中作如下修改：</p>
<img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%85%8D%E7%BD%AE1.png" class title="配置1">

<h3 id="保存站点配置文件"><a href="#保存站点配置文件" class="headerlink" title="保存站点配置文件"></a>保存站点配置文件</h3><p>意思是给hexo deploy这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，显然，要部署在github仓库中</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-deployer-git</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<p>继续输入以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>然后在网址栏输入：XXX.github.io 就可以在线上访问个人博客了！</p>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>没买 直接跳过！</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p><a href="https://hexo.io/zh-cn/docs/themes">https://hexo.io/zh-cn/docs/themes</a></p>
<p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
<p>秉承简约风格，我选择了Next主题</p>
<h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next<span class="literal">-theme</span>/hexo<span class="literal">-theme-next</span> themes/next</span><br></pre></td></tr></table></figure>

<p>可以看到theme文件夹里面已经有next文件夹了</p>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p>打开site的配置文件（blog&#x2F;_config.yml）,把theme改为next</p>
<img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%85%8D%E7%BD%AE2.png" class title="配置2">

<p>NexT主题有四个样式可以选择配置：（next&#x2F;_config.yml）</p>
<img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E9%85%8D%E7%BD%AE3.png" class title="配置3">


<h4 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h4 id="远程配置"><a href="#远程配置" class="headerlink" title="远程配置"></a>远程配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><p>文章主要用markdown编写，放置在&#x2F;blog&#x2F;source&#x2F;_posts文件夹下</p>
<h3 id="预览文章"><a href="#预览文章" class="headerlink" title="预览文章"></a>预览文章</h3><p>自带Markdown编辑器或者本地hexo预览</p>
<h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%B8%AA%E6%80%A7%E5%8C%961.png" class title="个性化1">

<p>标题、副标题、描述、关键词、语言、时区</p>
<h3 id="主题配置"><a href="#主题配置-1" class="headerlink" title="主题配置"></a>主题配置</h3><p><a href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a></p>
<h4 id="设置社交账号"><a href="#设置社交账号" class="headerlink" title="设置社交账号"></a>设置社交账号</h4><img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%B8%AA%E6%80%A7%E5%8C%962.png" class title="个性化2">

<h4 id="侧边栏配置"><a href="#侧边栏配置" class="headerlink" title="侧边栏配置"></a>侧边栏配置</h4><p>把想要的开启即可</p>
<img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%BE%A7%E8%BE%B9%E6%A0%8F1.png" class title="侧边栏1">

<p>文档中有提及：除了Home和archives，其他的页面都需要自己配置，配置流程看</p>
<ul>
<li>Step1：Adding new pages</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<ul>
<li>Step2: Setting page type</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tags</span><br><span class="line">date: 2022-07-04 21:00:03</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是tag和categoty的话，需要在文章里面配置就会显示到页面上</li>
</ul>
<h2 id="踩坑ampamp问题记录"><a href="#踩坑-amp-amp-问题记录" class="headerlink" title="踩坑&amp;&amp;问题记录"></a>踩坑&amp;&amp;问题记录</h2><h3 id="1-github-和-hexo关联没有关联上"><a href="#1-github-和-hexo关联没有关联上" class="headerlink" title="1. github 和 hexo关联没有关联上"></a>1. github 和 hexo关联没有关联上</h3><ul>
<li><p>原因1：注意仓库大小写问题</p>
<img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E8%B8%A9%E5%9D%911_1.png" class title="踩坑1_1">
</li>
<li><p>原因2：配置url</p>
<img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E8%B8%A9%E5%9D%911_3.png" class title="踩坑1_3">

<p>注意这里一定要根据你的仓库来，因为我是直接配置在仓库里的，而我之前手贱错吧SuperKatrina_Blog当成了project name，所以后面样式失效了，控制台查看原因后发现是路径的问题</p>
<img src="/2022/07/04/Hexo/Hexo_%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8B%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E8%B8%A9%E5%9D%911_2.png" class title="踩坑1_2"></li>
</ul>
<h3 id="2-配置主题后本地生效-但是-站点一直没生效"><a href="#2-配置主题后本地生效-但是-站点一直没生效" class="headerlink" title="2. 配置主题后本地生效 但是 站点一直没生效"></a>2. 配置主题后本地生效 但是 站点一直没生效</h3><ul>
<li><p>解决方法：清除缓存法</p>
<p>依次输入下列命令行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-图片显示问题"><a href="#3-图片显示问题" class="headerlink" title="3. 图片显示问题"></a>3. 图片显示问题</h3><ul>
<li><p>站点_config.yml中，post_asset_folder设置为true，目的是为了新建文章时自动帮我们建一个与文章名相同的文件夹用来从放图片文件</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">post<span class="emphasis">_asset_</span>folder: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo-asset-image</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-asset-image</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开&#x2F;node_modules&#x2F;hexo-asset-image&#x2F;index.js，内容替换为如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    	<span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">	<span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">	<span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">			<span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">			   !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) &#123;</span><br><span class="line">			  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.<span class="title function_">shift</span>();</span><br><span class="line">			  src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			  $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">			  <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">			<span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片按照如下格式引入</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% asset<span class="emphasis">_img example.jpg This is an example image %&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>根据步骤来</p>
<p><a href="https://github.com/next-theme/hexo-word-counter">https://github.com/next-theme/hexo-word-counter</a></p>
<p>注意（踩坑！！！）：配置完成后必须hexo clean，否则会出现时间为NaN 的情况！</p>
<h3 id="版权声明_hexo-addlink"><a href="#版权声明-hexo-addlink" class="headerlink" title="版权声明_hexo-addlink"></a>版权声明_hexo-addlink</h3><p>安装后在站点配置文件中配置</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 版权信息</span></span><br><span class="line">addlink:</span><br><span class="line">  before<span class="emphasis">_text: 本文作者：XXX，本文地址： # text before the post link</span></span><br><span class="line"><span class="emphasis">  after_</span>text: 转载请注明出处！ # text after the post link</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/26625249%EF%BC%88GitHub+Hexo">https://zhuanlan.zhihu.com/p/26625249（GitHub+Hexo</a> 搭建个人网站详细教程）</p>
<p><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a> （Hexo中文文档）</p>
<p><a href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a> （主题配置）</p>
<p><a href="https://theme-next.js.org/%EF%BC%88NexT%E4%B8%BB%E9%A2%98%E6%96%87%E6%A1%A3%EF%BC%89">https://theme-next.js.org/（NexT主题文档）</a></p>
<p><a href="https://github.com/next-theme/hexo-word-counter%EF%BC%88%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6%EF%BC%89">https://github.com/next-theme/hexo-word-counter（字数统计插件）</a></p>
<p><a href="https://juejin.cn/post/7006594302604214280">https://juejin.cn/post/7006594302604214280</a> （图片显示问题）</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>React | hashRouter和browserRouter的区别</title>
    <url>/2022/07/17/React/React_hashRouter&amp;&amp;browserRouter/</url>
    <content><![CDATA[<h2 id="react-router的工作方式"><a href="#react-router的工作方式" class="headerlink" title="react-router的工作方式"></a>react-router的工作方式</h2><blockquote>
<p>顶层是一个Router组件，在组件树中散落着许多Route组件</p>
<p>顶层的Router组件负责分析监听URL的变化，在此之下Route组件可以直接读取这些信息</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>((</span><br><span class="line">    <span class="comment">/*HashRouter监听着App这个组件的url的变化*/</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span><span class="tag">&lt;<span class="name">App</span> /&gt;</span><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span>  </span><br><span class="line">), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>路由需要实现的三个功能：</p>
<ol>
<li>当浏览器地址变化时，切换页面；</li>
<li>点击浏览器后退、前进按钮，网页内容发送变化；</li>
<li>刷新浏览器，页面加载内容对应当前路由对应的地址；</li>
</ol>
<p>在单页面web网页中，单纯的浏览器地址改变，网页不会重载，如单纯的hash值改变，网页是不会变化的，因此我们的路由需要监听事件，并利用js实现动态改变网页</p>
<ul>
<li>hash模式（onhashchange）：监听浏览器地址hash值变化，并执行相应的js切换【前进后退等】</li>
<li>history模式（popstate）：利用H5 history API实现url地址改变，网页内容改变</li>
</ul>
<h2 id="browserrouter和hashrouter的区别和特点"><a href="#BrowserRouter和HashRouter的区别和特点" class="headerlink" title="BrowserRouter和HashRouter的区别和特点"></a>BrowserRouter和HashRouter的区别和特点</h2><h3 id="browserrouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><blockquote>
<p>window.history对象表示的是当前窗口得浏览历史，当发生改变时，只会改变路径，不会刷新页面</p>
</blockquote>
<p>History对象就是一个堆栈</p>
<p>方法：</p>
<ul>
<li>History.back：移动上一个网址，等同于浏览器的后退</li>
<li>History.forward：移动到下一个网址，等同于浏览器前进</li>
<li>History.go(n)：接受一个参数，以当前网页为基准，来进行跳转，默认history.go(0)，刷新当前页面</li>
<li>History.pushState()：往history堆栈中添加一条记录，不会刷新页面，只会导致history对象变化，地址栏发生变化</li>
<li>History.replaceState()：替换当前history堆栈中最上层的记录，不会刷新页面，只会导致history对象变化，地址栏发生变化</li>
</ul>
<blockquote>
<p>每当history对象发生变化，就会触发popstate事件：window.addEventListener(‘popstate’, function(){});</p>
<p>[只调用pushState或者replaceState是不会触发该事件的，只有调用back forward go才会触发该事件]</p>
</blockquote>
<h3 id="hashrouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><blockquote>
<p>使用window.location.hash属性和window.onhashchange事件，可以监听浏览器hash值的变化，去执行相应的js切换路由</p>
</blockquote>
<p>hash路由实现原理：</p>
<ol>
<li>hash指的是地址#号以及后面的字符，称为散列值</li>
<li>散列值不会随着请求发送到服务端的，所以改变hash，不会重新加载页面</li>
<li>监听onhashchange事件，hash改变时，可以通过window.location.hash来获取和设置hash值</li>
<li>location.hash值得变化直接反应在浏览器得地址栏</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="底层原理不一样"><a href="#底层原理不一样" class="headerlink" title="底层原理不一样"></a>底层原理不一样</h3><ul>
<li>BrowserRouter：利用HTML5 history的API，有低版本兼容性问题</li>
<li>HashRouter：利用URL的哈希值，window.location.hash</li>
</ul>
<h3 id="地址栏表现形式不一样"><a href="#地址栏表现形式不一样" class="headerlink" title="地址栏表现形式不一样"></a>地址栏表现形式不一样</h3><ul>
<li>BrowserRouter路径：localhost:3000&#x2F;demo&#x2F;a</li>
<li>HashRouter路径：localhost:3000&#x2F;#&#x2F;demo&#x2F;a</li>
</ul>
<h3 id="刷新后对路由state参数的影响"><a href="#刷新后对路由state参数的影响" class="headerlink" title="刷新后对路由state参数的影响"></a>刷新后对路由state参数的影响</h3><ul>
<li>BrowserRouter没有任何影响，因为state保存在history对象中</li>
<li>HashRouter刷新后会导致路由state参数丢失</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
        <category>常见方法对比</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react-router</tag>
        <tag>常见方法对比</tag>
      </tags>
  </entry>
  <entry>
    <title>React | react-router原理</title>
    <url>/2022/07/17/React/React_react-router%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="理解react-router"><a href="#理解react-router" class="headerlink" title="理解react-router"></a>理解react-router</h2><h3 id="单页面应用spa-single-page-application"><a href="#单页面应用（SPA-single-page-application）" class="headerlink" title="单页面应用（SPA single page application）"></a>单页面应用（SPA single page application）</h3><p>单页面应用是指只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源，公共资源（js css等）仅需加载一次，常用于PC端应用、购物等网站</p>
<h3 id="react-router-dom-react-router-history库三者关系"><a href="#react-router-dom-react-router-history库三者关系" class="headerlink" title="react-router-dom react-router history库三者关系"></a>react-router-dom react-router history库三者关系</h3><p>history可以理解为react-router的核心，也就是整个路由的核心，里面集成了popState history.pushState等底层路由实现的原理方法</p>
<p>react-router可以理解为是react-router-dom的核心，里面封装了Router Route Switch等核心组件，实现了从路由的改变到组件的更新的核心功能</p>
<p>一般在项目中只需要引入react-router-dom即可</p>
<h2 id="单页面实现核心原理"><a href="#单页面实现核心原理" class="headerlink" title="单页面实现核心原理"></a>单页面实现核心原理</h2><h3 id="history模式原理"><a href="#history模式原理" class="headerlink" title="history模式原理"></a>history模式原理</h3><h4 id="改变路由"><a href="#改变路由" class="headerlink" title="改变路由"></a>改变路由</h4><ul>
<li><code>history.pushState</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.<span class="title function_">pushState</span>(state, title, path);</span><br></pre></td></tr></table></figure>

<ol>
<li>state：一个与指定网址相关的状态对象，popState事件触发，该对象会传入回调函数，如果不需要可以填null</li>
<li>title：新页面的标题，但是所有浏览器目前都忽略这个值，可填null</li>
<li>path：新的网址，必须与当前页面处在同一个域，浏览器的地址栏将显示这个地址</li>
</ol>
<ul>
<li><code>history.replaceState</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.<span class="title function_">replaceState</span>()</span><br></pre></td></tr></table></figure>

<p>参数同上，这个方法会修改当前的history记录，history.length的长度不会改变</p>
<h4 id="监听路由"><a href="#监听路由" class="headerlink" title="监听路由"></a>监听路由</h4><ul>
<li><code>popstate</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">	<span class="comment">/*监听改变*/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> popstate事件只会在浏览器某些行为下触发，比如点击后退按钮（或者在JS中调用history.back()方法），即在同一文档的history对象出现变化会触发该事件</p>
<p> history.pushState()或者history.replaceState()不会触发popstate事件</p>
</blockquote>
<h3 id="hash模式原理"><a href="#hash模式原理" class="headerlink" title="hash模式原理"></a>hash模式原理</h3><h4 id="改变路由"><a href="#改变路由-1" class="headerlink" title="改变路由"></a>改变路由</h4><ul>
<li>window.location.hash</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>window.location.hash</code>属性获取hash值和设置hash值</p>
<h4 id="监听路由"><a href="#监听路由-1" class="headerlink" title="监听路由"></a>监听路由</h4><ul>
<li>onhashchange</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">	<span class="comment">/*监听改变*/</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="history库"><a href="#history库" class="headerlink" title="history库"></a>history库</h2><p>react-router路由离不开history库，history专注于记录路由的history状态，以及path改变了我们应该做些什么？在history模式下用popstate监听路由变化，在hash模式下用hashchange监听路由变化</p>
<h3 id="createbrowserhistory"><a href="#createBrowserHistory" class="headerlink" title="createBrowserHistory"></a>createBrowserHistory</h3><p>Browser模式下路由的运行，一切都从 <code>createBrowserHistory</code>开始</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* popstate 和 hashchangeevent用于监听路由变化的底层方法 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PopStateEvent</span> = <span class="string">&#x27;popstate&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HashChangeEvent</span> = <span class="string">&#x27;hashchange&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里简化了createBrowserHistory，列出了几个核心api极其作用*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createBrowserHistory</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">/*全局history*/</span></span><br><span class="line">	<span class="keyword">const</span> globalHistory = <span class="variable language_">window</span>.<span class="property">history</span>;</span><br><span class="line">	<span class="comment">/*处理路由转换，记录listens信息*/</span></span><br><span class="line">	<span class="keyword">const</span> transitionManager = <span class="title function_">createTransitionManage</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">	(1)setState: 统一每个transitionManager管理的listener路由状态已经更新</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="comment">/*改变location对象，通知组件更新*/</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">setState</span> = (<span class="params">nextState</span>) =&gt; &#123;</span><br><span class="line">		<span class="comment">/*合并信息*/</span></span><br><span class="line">		<span class="title class_">Object</span>.<span class="title function_">assign</span>(history, nextState);</span><br><span class="line">		history.<span class="property">length</span> = globalHistory.<span class="property">length</span>;</span><br><span class="line">		<span class="comment">/*通知每一个listens路由已经发生了变化*/</span></span><br><span class="line">		transitionManager.<span class="title function_">notifyListeners</span>(</span><br><span class="line">			history.<span class="property">location</span>,</span><br><span class="line">			history.<span class="property">action</span>,</span><br><span class="line">		);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">	(4)handlePopState: 判断action类型为pop然后setState，从而新加载组件</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="comment">/*处理当path改变后，处理popstate变化的回调函数*/</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">handlePopState</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">		 <span class="comment">/* 获取当前location对象 */</span></span><br><span class="line">    		<span class="keyword">const</span> location = <span class="title function_">getDOMLocation</span>(event.<span class="property">state</span>)</span><br><span class="line">    		<span class="keyword">const</span> action = <span class="string">&#x27;POP&#x27;</span></span><br><span class="line"></span><br><span class="line">    		transitionManager.<span class="title function_">confirmTransitionTo</span>(location, action, getUserConfirmation, <span class="function">(<span class="params">ok</span>) =&gt;</span> &#123;</span><br><span class="line">        		<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">          			<span class="title function_">setState</span>(&#123; action, location &#125;)</span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          			<span class="title function_">revertPop</span>(location)</span><br><span class="line">        		&#125;</span><br><span class="line">    		&#125;)</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">	(3)push: </span></span><br><span class="line"><span class="comment">	流程：</span></span><br><span class="line"><span class="comment">		1. 生成一个最新的location对象</span></span><br><span class="line"><span class="comment">		2. 通过window.history.pushState方法改变浏览器当前路由（当前path）</span></span><br><span class="line"><span class="comment">		3. 通过setState方法通知react-router更新，并传递当前的location对象</span></span><br><span class="line"><span class="comment">			（由于这次url变化是由history.pushState产生的，并不会触发popState方法，所以需要手动setState，触发组件更新）</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*history.push方法，改变路由，通过全局对象history.pushState改变url，通知router触发更新，替换组件*/</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">push</span> = (<span class="params">path, state</span>) =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> action = <span class="string">&#x27;PUSH&#x27;</span>;</span><br><span class="line">		<span class="comment">/* 1. 创建location对象 */</span></span><br><span class="line">		<span class="keyword">const</span> loaction = <span class="title function_">createLocation</span>(path, state, <span class="title function_">createKey</span>(), history.<span class="property">location</span>);</span><br><span class="line">		<span class="comment">/* 确定是否能进行路由跳转，还在确认的时候又开始了另一个转变，可能会造成异常 */</span></span><br><span class="line">		transitionManager.<span class="title function_">confirmTransition</span>(location, action, getUserConfirmation, <span class="function">(<span class="params">ok</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">const</span> href = <span class="title function_">createHref</span>(location)</span><br><span class="line">      			<span class="keyword">const</span> &#123; key, state &#125; = location</span><br><span class="line">      			<span class="keyword">if</span> (canUseHistory) &#123;</span><br><span class="line">        			<span class="comment">/* 改变 url */</span></span><br><span class="line">        			globalHistory.<span class="title function_">pushState</span>(&#123; key, state &#125;, <span class="literal">null</span>, href)</span><br><span class="line">        			<span class="keyword">if</span> (forceRefresh) &#123;</span><br><span class="line">          				<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = href</span><br><span class="line">        			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         				<span class="comment">/* 改变 react-router location对象, 创建更新环境 */</span></span><br><span class="line">          				<span class="title function_">setState</span>(&#123; action, location &#125;)</span><br><span class="line">        			&#125;</span><br><span class="line">      			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        			<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = href</span><br><span class="line">      			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">	(2)listen: </span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="comment">/*底层应用事件监听器，监听popstate事件*/</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">listen</span> = (<span class="params">listener</span>) =&gt; &#123;</span><br><span class="line">		<span class="comment">/*添加listen*/</span></span><br><span class="line">		<span class="keyword">const</span> unlisten = transitionManager.<span class="title function_">appendListener</span>(listener);</span><br><span class="line">		<span class="title function_">checkDOMListeners</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="title function_">checkDOMListeners</span>(-<span class="number">1</span>);</span><br><span class="line">			<span class="title function_">unlisten</span>();</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*定义checkDOMListeners*/</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">checkDOMListeners</span> = (<span class="params">delta</span>) =&gt; &#123;</span><br><span class="line">		listenerCount += delta;</span><br><span class="line">		<span class="keyword">if</span> (listenerCount === <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="title function_">addEventListener</span>(<span class="variable language_">window</span>, <span class="title class_">PopStateEvent</span>, handlePopState);</span><br><span class="line">			<span class="keyword">if</span> (needsHashChangeListener) <span class="title function_">addEventListener</span>(<span class="variable language_">window</span>, <span class="title class_">HashChangeEvent</span>, handleHashChange)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenerCount === <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="title function_">removeEventListener</span>(<span class="variable language_">window</span>, <span class="title class_">PopStateEvent</span>, handlePopState);</span><br><span class="line">			<span class="keyword">if</span> (needsHashChangeListener) <span class="title function_">removeEventListener</span>(<span class="variable language_">window</span>, <span class="title class_">HashChangeEvent</span>, handleHashChange)</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		listen本质上是通过checkDOMListeners的参数-1或者1来绑定或者解绑popstate事件，</span></span><br><span class="line"><span class="comment">		当路由发生变化的时候，调用处理函数handlePopState</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		push,</span><br><span class="line">		listen,</span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="createhashhistory"><a href="#createHashHistory" class="headerlink" title="createHashHistory"></a>createHashHistory</h3><h4 id="监听哈希路由变化"><a href="#监听哈希路由变化" class="headerlink" title="监听哈希路由变化"></a>监听哈希路由变化</h4><p>hashchange监听</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HashChangeEvent</span> = <span class="string">&#x27;hashchange&#x27;</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">checkDOMListeners</span> = (<span class="params">delta</span>) =&gt; &#123;</span><br><span class="line"> 	listenerCount += delta</span><br><span class="line">    	<span class="keyword">if</span> (listenerCount === <span class="number">1</span>) &#123;</span><br><span class="line">      		<span class="title function_">addEventListener</span>(<span class="variable language_">window</span>, <span class="title class_">HashChangeEvent</span>, handleHashChange)</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenerCount === <span class="number">0</span>) &#123;</span><br><span class="line">      		<span class="title function_">removeEventListener</span>(<span class="variable language_">window</span>, <span class="title class_">HashChangeEvent</span>, handleHashChange)</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改变哈希路由"><a href="#改变哈希路由" class="headerlink" title="改变哈希路由"></a>改变哈希路由</h4><p>history.push底层调用了window.location.href改变路由</p>
<p>history.replace底层调用了window.location.replace改变路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对应 push 方法 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">pushHashPath</span> = (<span class="params">path</span>) =&gt;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> = path</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对应replace方法 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">replaceHashPath</span> = (<span class="params">path</span>) =&gt; &#123;</span><br><span class="line">  		<span class="keyword">const</span> hashIndex = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  		<span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(</span><br><span class="line">    			<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">slice</span>(<span class="number">0</span>, hashIndex &gt;= <span class="number">0</span> ? hashIndex : <span class="number">0</span>) + <span class="string">&#x27;#&#x27;</span> + path</span><br><span class="line">  		)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac7ed7a701714650b55c9193db2220ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="avatar"></p>
<h2 id="核心api"><a href="#核心api" class="headerlink" title="核心api"></a>核心api</h2><h3 id="router-接收location变化派发更新流"><a href="#Router-：接收location变化，派发更新流" class="headerlink" title="Router ：接收location变化，派发更新流"></a>Router ：接收location变化，派发更新流</h3><p>router的作用是把history location等路由信息传递下去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Router 作用是把 history location 等路由信息 传递下去  */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">computeRootMatch</span>(<span class="params">pathname</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">url</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">params</span>: &#123;&#125;, <span class="attr">isExact</span>: pathname === <span class="string">&#x27;/&#x27;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">location</span>: props.<span class="property">history</span>.<span class="property">location</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//记录pending位置</span></span><br><span class="line">    <span class="comment">//如果存在任何&lt;Redirect&gt;，则在构造函数中进行更改</span></span><br><span class="line">    <span class="comment">//在初始渲染时。如果有，它们将在</span></span><br><span class="line">    <span class="comment">//在子组件身上激活，我们可能会</span></span><br><span class="line">    <span class="comment">//在安装&lt;Router&gt;之前获取一个新位置。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_isMounted</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_pendingLocation</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/* 此时的history，是history创建的history对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (!props.<span class="property">staticContext</span>) &#123;</span><br><span class="line">      <span class="comment">/* 这里判断 componentDidMount 和 history.listen 执行顺序 然后把 location复制 ，防止组件重新渲染 */</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">unlisten</span> = props.<span class="property">history</span>.<span class="title function_">listen</span>(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* 创建监听者 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_isMounted</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; location &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_pendingLocation</span> = location;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_isMounted</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_pendingLocation</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">location</span>: <span class="variable language_">this</span>.<span class="property">_pendingLocation</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* 解除监听 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">unlisten</span>) <span class="variable language_">this</span>.<span class="title function_">unlisten</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">/*  这里可以理解 react.createContext 创建一个 context上下文 ，保存router基本信息。children */</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">RouterContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">children</span>=<span class="string">&#123;this.props.children</span> || <span class="attr">null</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">history:</span> <span class="attr">this.props.history</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">location:</span> <span class="attr">this.state.location</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">match:</span> <span class="attr">Router.computeRootMatch</span>(<span class="attr">this.state.location.pathname</span>),</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">staticContext:</span> <span class="attr">this.props.staticContext</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>初始化绑定listen, 路由变化,通知改变 <code>location</code>,改变组件。 react的history路由状态是保存在 <code>React.Content</code>上下文之间, 状态更新。</p>
<p><strong>一个项目应该有一个根 <code>Router</code> ， 来产生切换路由组件之前的更新作用。如果存在多个 <code>Router</code>会造成，会造成切换路由，页面不更新的情况。</strong></p>
<h3 id="switch-匹配正确的唯一的路由"><a href="#Switch-匹配正确的唯一的路由" class="headerlink" title="Switch: 匹配正确的唯一的路由"></a>Switch: 匹配正确的唯一的路由</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* switch组件 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;/* 含有 history location 对象的 context */&#125;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line">          invariant(context, &#x27;You should not use &lt;Switch&gt; outside a &lt;Router&gt;&#x27;);</span><br><span class="line">          const location = this.props.location || context.location;</span><br><span class="line">          let element, match;</span><br><span class="line">          //我们使用React.Children.forEach而不是React.Children.toArray（）.find（）</span><br><span class="line">          //这里是因为toArray向所有子元素添加了键，我们不希望</span><br><span class="line">          //为呈现相同的两个&lt;Route&gt;s触发卸载/重新装载</span><br><span class="line">          //组件位于不同的URL。</span><br><span class="line">          //这里只需然第一个 含有 match === null 的组件</span><br><span class="line">          React.Children.forEach(this.props.children, child =&gt; &#123;</span><br><span class="line">            if (match == null &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">              element = child;</span><br><span class="line">              // 子组件 也就是 获取 Route中的 path 或者 rediect 的 from</span><br><span class="line">              const path = child.props.path || child.props.from;</span><br><span class="line">              match = path</span><br><span class="line">                ? matchPath(location.pathname, &#123; ...child.props, path &#125;)</span><br><span class="line">                : context.match;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          return match</span><br><span class="line">            ? React.cloneElement(element, &#123; location, computedMatch: match &#125;)</span><br><span class="line">            : null;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;/RouterContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">matchPath</span>(<span class="params">pathname, options = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&quot;string&quot;</span> || <span class="title class_">Array</span>.<span class="title function_">isArray</span>(options)) &#123;</span><br><span class="line">    options = &#123; <span class="attr">path</span>: options &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; path, exact = <span class="literal">false</span>, strict = <span class="literal">false</span>, sensitive = <span class="literal">false</span> &#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paths = [].<span class="title function_">concat</span>(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> paths.<span class="title function_">reduce</span>(<span class="function">(<span class="params">matched, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!path &amp;&amp; path !== <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span> matched;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; regexp, keys &#125; = <span class="title function_">compilePath</span>(path, &#123;</span><br><span class="line">      <span class="attr">end</span>: exact,</span><br><span class="line">      strict,</span><br><span class="line">      sensitive</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> match = regexp.<span class="title function_">exec</span>(pathname);</span><br><span class="line">    <span class="comment">/* 匹配不成功，返回null */</span></span><br><span class="line">    <span class="keyword">if</span> (!match) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [url, ...values] = match;</span><br><span class="line">    <span class="keyword">const</span> isExact = pathname === url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exact &amp;&amp; !isExact) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      path, <span class="comment">// the path used to match</span></span><br><span class="line">      <span class="attr">url</span>: path === <span class="string">&quot;/&quot;</span> &amp;&amp; url === <span class="string">&quot;&quot;</span> ? <span class="string">&quot;/&quot;</span> : url, <span class="comment">// the matched portion of the URL</span></span><br><span class="line">      isExact, <span class="comment">// whether or not we matched exactly</span></span><br><span class="line">      <span class="attr">params</span>: keys.<span class="title function_">reduce</span>(<span class="function">(<span class="params">memo, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">        memo[key.<span class="property">name</span>] = values[index];</span><br><span class="line">        <span class="keyword">return</span> memo;</span><br><span class="line">      &#125;, &#123;&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="route组件页面承载容器"><a href="#Route：组件页面承载容器" class="headerlink" title="Route：组件页面承载容器"></a>Route：组件页面承载容器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for matching a single path and rendering.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Route</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; &#123;</span><br><span class="line">          /* router / route 会给予警告警告 */</span><br><span class="line">          invariant(context, &quot;You should not use &lt;Route&gt; outside a &lt;Router&gt;&quot;);</span><br><span class="line">          // computedMatch 为 经过 swich处理后的 path</span><br><span class="line">          const location = this.props.location || context.location;</span><br><span class="line">          const match = this.props.computedMatch </span><br><span class="line">            ? this.props.computedMatch // &lt;Switch&gt; already computed the match for us</span><br><span class="line">            : this.props.path</span><br><span class="line">            ? matchPath(location.pathname, this.props)</span><br><span class="line">            : context.match;</span><br><span class="line">          const props = &#123; ...context, location, match &#125;;</span><br><span class="line">          let &#123; children, component, render &#125; = this.props;</span><br><span class="line"></span><br><span class="line">          if (Array.isArray(children) &amp;&amp; children.length === 0) &#123;</span><br><span class="line">            children = null;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return (</span><br><span class="line">            &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class="line">              &#123;props.match</span><br><span class="line">                ? children</span><br><span class="line">                  ? typeof children === &quot;function&quot;</span><br><span class="line">                    ? __DEV__</span><br><span class="line">                      ? evalChildrenDev(children, props, this.props.path)</span><br><span class="line">                      : children(props)</span><br><span class="line">                    : children</span><br><span class="line">                  : component</span><br><span class="line">                  ? React.createElement(component, props)</span><br><span class="line">                  : render</span><br><span class="line">                  ? render(props)</span><br><span class="line">                  : null</span><br><span class="line">                : typeof children === &quot;function&quot;</span><br><span class="line">                ? __DEV__</span><br><span class="line">                  ? evalChildrenDev(children, props, this.props.path)</span><br><span class="line">                  : children(props)</span><br><span class="line">                : null&#125;</span><br><span class="line">            &lt;/RouterContext.Provider&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;/RouterContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redirect重定向"><a href="#Redirect：重定向" class="headerlink" title="Redirect：重定向"></a>Redirect：重定向</h3><ol>
<li>初始化页面跳转</li>
<li>组件更新的时候location不相等</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Redirect</span>(<span class="params">&#123; computedMatch, to, push = <span class="literal">false</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">RouterContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;context =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        const &#123; history, staticContext &#125; = context;</span></span><br><span class="line"><span class="language-xml">        /* method就是路由跳转方法。 */</span></span><br><span class="line"><span class="language-xml">        const method = push ? history.push : history.replace;</span></span><br><span class="line"><span class="language-xml">        /* 找到符合match的location ，格式化location */</span></span><br><span class="line"><span class="language-xml">        const location = createLocation(</span></span><br><span class="line"><span class="language-xml">          computedMatch</span></span><br><span class="line"><span class="language-xml">            ? typeof to === &#x27;string&#x27;</span></span><br><span class="line"><span class="language-xml">              ? generatePath(to, computedMatch.params)</span></span><br><span class="line"><span class="language-xml">              : &#123;</span></span><br><span class="line"><span class="language-xml">                  ...to,</span></span><br><span class="line"><span class="language-xml">                  pathname: generatePath(to.pathname, computedMatch.params)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            : to</span></span><br><span class="line"><span class="language-xml">        )</span></span><br><span class="line"><span class="language-xml">        /* 初始化的时候进行路由跳转，当初始化的时候，mounted执行push方法，当组件更新的时候，如果location不相等。同样会执行history方法重定向 */</span></span><br><span class="line"><span class="language-xml">        return (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Lifecycle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">onMount</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">              method(location);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">              onUpdate=&#123;(self, prevProps) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">              const prevLocation = createLocation(prevProps.to);</span></span><br><span class="line"><span class="language-xml">              if (</span></span><br><span class="line"><span class="language-xml">                !locationsAreEqual(prevLocation, &#123;</span></span><br><span class="line"><span class="language-xml">                  ...location,</span></span><br><span class="line"><span class="language-xml">                  key: prevLocation.key</span></span><br><span class="line"><span class="language-xml">                &#125;)</span></span><br><span class="line"><span class="language-xml">              ) &#123;</span></span><br><span class="line"><span class="language-xml">                method(location);</span></span><br><span class="line"><span class="language-xml">              &#125; </span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">              to=&#123;to&#125;</span></span><br><span class="line"><span class="language-xml">          /&gt;</span></span><br><span class="line"><span class="language-xml">        );</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">RouterContext.Consumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>history提供了核心api，如监听路由，更改路由的方法，已经保存路由状态state</li>
<li>react-router提供路由渲染组件，路由唯一性匹配组件，重定向组件等功能组件</li>
</ol>
<p>流程分析：</p>
<p><strong>1. 当地址栏改变url，组件的更新渲染都经历了什么？</strong></p>
<p>拿history模式做参考。当url改变，首先触发histoy，调用事件监听 <code>popstate</code>事件， 触发回调函数 <code>handlePopState</code>，触发history下面的 <code>setstate</code>方法，产生新的location对象，然后通知Router组件更新 <code>location</code>并通过context上下文传递，<code>switch</code>通过传递的更新流，匹配出符合的Route组件渲染，最后有 <code>Route</code>组件取出 <code>context</code>内容，传递给渲染页面，渲染更新</p>
<p><strong>2.当我们调用 <code>history.push</code>方法，切换路由，组件的更新渲染又都经历了什么呢？</strong></p>
<p>当我们调用 <code>history.push</code>方法，首先调用history的 <code>push</code>方法，通过 <code>history.pushState</code>来改变当前 <code>url</code>，接下来触发history下面的 <code>setState</code>方法，接下来的步骤就和上面一模一样了</p>
<h3 id="各个路由组件之间的关系"><a href="#各个路由组件之间的关系" class="headerlink" title="各个路由组件之间的关系"></a>各个路由组件之间的关系</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5de251f8dc649e3ae1b1fcf382330ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="avatar"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Object.create</title>
    <url>/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.create/</url>
    <content><![CDATA[<h3 id="mdn-文档"><a href="#MDN-文档" class="headerlink" title="MDN 文档"></a>MDN 文档</h3><blockquote>
<p>Object.create()方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型。</p>
</blockquote>
<p><strong>语法如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.create(proto);</span><br><span class="line">Object.create(proto, propertiesObject);</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<p><code>proto</code>：新建对象的原型对象</p>
<p><code>propertiesObject</code>（可选）：传入对象的可枚举属性将为新创建的对象添加指定的属性值和对应的属性描述符，这些属性对应于<code>Object.defineProperties()</code>的第二个参数</p>
<p><strong>返回值：</strong></p>
<p>一个新对象，带着指定的原型对象及其属性</p>
<h3 id="手写objectcreate"><a href="#手写Object-create" class="headerlink" title="手写Object.create()"></a>手写Object.create()</h3><p><strong>实现思路：</strong>定义一个空的构造函数，把构造函数的原型指定为传入的对象，利用<code>new</code>构造函数，返回构造函数的实例，达到创建空对象的目的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCreate</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">   	<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create()</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">__proto__</span> === obj);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.myCreate();</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Object</span>.<span class="title function_">myCreate</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">__proto__</span> === obj);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> obj.<span class="property">constructor</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> obj.<span class="property">constructor</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><p><a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_new/">手写new</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_instanceof/">手写instanceof</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Object.assign</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.assign/</url>
    <content><![CDATA[<p><code>Object.assign</code>方法将所有可枚举和自有属性从一个或多个源对象复制到目标对象，返回修改后的对象</p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>target</code>：目标对象</li>
<li><code>sources</code>：源对象</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>源对象可以有N个</li>
<li>相同属性，后面的会覆盖前面的</li>
<li>Symbol类型的属性会被拷贝，而且不会跳过那些值为null和undefined的源对象</li>
</ol>
<p><strong>实现思路</strong></p>
<ol>
<li>判断目标对象是否为正确，不能为null或者defined</li>
<li>使用for…in…循环遍历出所有可枚举属性（可以使用hasOwnProperty判断）并且复制给目标对象</li>
</ol>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myObjectAssign</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> target = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;   <span class="comment">// undefined == null 为true</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Cannot convert null or undefined to object.&#x27;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Object装箱</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="title class_">Object</span>(target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> source = <span class="variable language_">arguments</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">                <span class="comment">// 注意for in会遍历原型链上的属性</span></span><br><span class="line">                <span class="keyword">if</span> (source.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">                    obj[key] = source[key];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">myObjectAssign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Object.is</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.is/</url>
    <content><![CDATA[<p>Object.is()方法判断两个值是否为同一个值</p>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(val1, val2)</span><br></pre></td></tr></table></figure>

<p><strong>改变</strong></p>
<p>这里讨论<code>Object.is()</code>相对于严格相等<code>===</code>所作的改变：</p>
<ul>
<li><code>Object.is(NaN,NaN) === true</code></li>
<li><code>Object.is(-0, +0) === true</code></li>
</ul>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myObjectIs</span>(<span class="params">val1, val2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val1 === <span class="title class_">NaN</span> &amp;&amp; val1 === <span class="title class_">NaN</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val1 === <span class="number">0</span> &amp;&amp; val2 === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/val1 === <span class="number">1</span>/val2;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> val1 === val2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Promise.all</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.all/</url>
    <content><![CDATA[<blockquote>
<p><code>Promise.all</code> 方法接收一个promise的iterable类型（比如：Array，Map，Set）的输入，并且只返回一个Promise实例，如果所有的promise都是resolve状态，value就为结果数组，结果的顺序与传入顺序一致，如果promise中有reject，就会抛出错误，reason为抛出的是第一个reject的信息</p>
<p>应用场景：在请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景</p>
</blockquote>
<p><strong>实现思路及注意点</strong></p>
<ul>
<li>输入promises可以是一个iterator类型的参数，不一定需要局限在array（好多手写一上来就判断是不是array）</li>
<li>如果iterator为空，resolve返回空数组</li>
<li>非Promise实例的需要经过Promise.resolve包裹</li>
<li>如果都会resolve，输出的结果数组必须和原顺序一致，并不是谁先执行完谁先进入结果数组</li>
<li>返回一个Promise实例可以调用then和catch方法，then里面为保持原顺序的数组，catch里面则为最早reject的返回值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromiseAll</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> promiseResults = [];</span><br><span class="line">        <span class="comment">// 迭代的顺序</span></span><br><span class="line">        <span class="keyword">let</span> iteratorIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于记录已经完成的数量，注意这个不是顺序</span></span><br><span class="line">        <span class="keyword">let</span> fullCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 迭代开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;   <span class="comment">// for of就是用于遍历可迭代对象的</span></span><br><span class="line">            <span class="comment">// for of 是顺序执行的</span></span><br><span class="line">            <span class="keyword">let</span> resultIndex = iteratorIndex;</span><br><span class="line">            iteratorIndex++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 非Promise实例的需要经过Promise.resolve包裹</span></span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                promiseResults[resultIndex] = res;</span><br><span class="line">                <span class="comment">// then后表示完成</span></span><br><span class="line">                fullCount++;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Iterator接口无法单纯根据length和size判断长度</span></span><br><span class="line">                <span class="keyword">if</span> (fullCount === iteratorIndex) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(promiseResults);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果iterator为空，resolve返回空数组</span></span><br><span class="line">        <span class="keyword">if</span> (iteratorIndex === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(promiseResults);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="number">1337</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="title function_">myPromiseAll</span>([p1, p2, p3]);  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: [3, 1337, &quot;foo&quot;]&#125;</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values); <span class="comment">// [3, 1337, &quot;foo&quot;]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Promise.allSelected</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.allSelected/</url>
    <content><![CDATA[<blockquote>
<p><code>Promise.allSettled()</code>方法返回一个在所有给定的 promise 都已经<code>fulfilled</code>或<code>rejected</code>后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果</p>
<p><code>[ &#123;status: &#39;fulfilled&#39;, value: 3&#125;, &#123;status: &#39;rejected&#39;, reason: &#39;foo&#39;&#125;]</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromiseAllSelected</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="keyword">let</span> iteratorIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> fullCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> promises) &#123;</span><br><span class="line">          <span class="keyword">let</span> resIndex =  iteratorIndex;</span><br><span class="line">          iteratorIndex++;</span><br><span class="line">            </span><br><span class="line">          <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">              res[resIndex] = &#123;</span><br><span class="line">                  <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                  value,</span><br><span class="line">              &#125;;</span><br><span class="line">              fullCount++;</span><br><span class="line">              </span><br><span class="line">              <span class="keyword">if</span> (fullCount === iteratorIndex) &#123;</span><br><span class="line">                  <span class="title function_">resolve</span>(res);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">              res[resIndex] = &#123;</span><br><span class="line">                  <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                  reason,</span><br><span class="line">              &#125;;</span><br><span class="line">              fullCount++;</span><br><span class="line">              </span><br><span class="line">              <span class="keyword">if</span> (fullCount === iteratorIndex) &#123;</span><br><span class="line">                  <span class="title function_">resolve</span>(res);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2]).<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;). <span class="keyword">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        &#123; status: &#x27;fulfilled&#x27;, value: 3 &#125;,</span></span><br><span class="line"><span class="comment">        &#123; status: &#x27;rejected&#x27;, reason: 2 &#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">myPromiseAllSelected</span>([p1,p2]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res), <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Promise</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存初始的状态</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义初始的状态为pending</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于保存resolve reject传入的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = [];</span><br><span class="line">    <span class="comment">// 用于保存resolve reject的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectCallbacks</span> = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态转变为resolve的操作</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">            <span class="keyword">return</span> value.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">                resolveCallbacks.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span>=&gt;</span><span class="title function_">callback</span>(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态转变为reject的操作</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">value</span> = reason;</span><br><span class="line">                resolveCallbacks.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span>=&gt;</span><span class="title function_">callback</span>(reason));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把两个函数传入fn中</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Promise.finally</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.finally/</url>
    <content><![CDATA[<blockquote>
<p>Promise.finally()返回一个Promise实例，在promise结束时，无论结果是fulfilled还是rejected，都会执行指定的回调函数</p>
<p>应用场景：无论Promise是成功还是失败都会执行，避免了在then和catch各写一次的情况</p>
</blockquote>
<p>finally和then(onFinally, onFinally)类似，不同之处在于：</p>
<ul>
<li>调用内联函数时，不需要多次声明该函数或为该函数创建一个变量保存它</li>
<li>由于无法知道 <code>promise</code> 的最终状态，所以 <code>finally</code> 的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况</li>
<li>与<code>Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</code>（resolved 的结果为<code>undefined</code>[因为这里的then没有显式的返回语句，所以结果为undefined]）不同，<code>Promise.resolve(2).finally(() =&gt; &#123;&#125;)</code> resolved 的结果为 <code>2</code></li>
<li>同样，<code>Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</code> (fulfilled 的结果为<code>undefined</code>[因为这里的then没有显式的返回语句，所以结果为undefined]), <code>Promise.reject(3).finally(() =&gt; &#123;&#125;)</code> rejected 的结果为 <code>3</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromiseFinally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Promise.race</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.race/</url>
    <content><![CDATA[<blockquote>
<p><code>Promise.race</code>返回一个<code>Promise</code>实例，一旦迭代器中的某个 <code>promise </code>解决或拒绝，返回的 <code>promise</code> 就会解决或拒绝</p>
<p>应用场景：可以测试接口的响应速度</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromiseRace</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> promises) &#123;</span><br><span class="line">         	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(res);</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;)    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | Promise.then</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.then/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先判断resolve 和 reject是否为function类型</span></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span> ? onResolved : <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span> ? onRejected : <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是等待状态，则将函数加入对应的列表中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span>.<span class="title function_">push</span>(onResolved);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span>.<span class="title function_">push</span>(onRejected);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果状态已经改变（凝固），则执行对应状态的函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">RESOLVED</span>) &#123;</span><br><span class="line">        <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | instanceof</title>
    <url>/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_instanceof/</url>
    <content><![CDATA[<h3 id="mdn"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h3><blockquote>
<p>instanceof 运算符用于检测构造函数的prototype属性是否出现在实例对象的原型链上</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object instancof constructor</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>object</code>：某个实例对象</p>
<p><code>constructor</code>：某个构造函数</p>
<p><strong>返回值</strong></p>
<p>布尔值</p>
<h3 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h3><p><strong>实现思路</strong>：根据原型链的思想，判断实例对象的<code>__proto__</code>是否指向构造函数的原型，一级一级向上判断，直至<code>null</code></p>
<p><strong>注意</strong>：instanceof只能用于判断引用数据类型，不能判断基本数据类型，直接返回<code>false</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">object, constructor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> object !== <span class="string">&#x27;object&#x27;</span> || object === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> left = object.<span class="property">__proto__</span>;</span><br><span class="line">	<span class="keyword">let</span> right = constructor.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 终止条件1：找到原型了</span></span><br><span class="line">        <span class="keyword">if</span> (left === right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 终止条件2：遍历到了尽头也没找到</span></span><br><span class="line">        <span class="keyword">if</span> (left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 还没找到：继续找呗！</span></span><br><span class="line">        left = left.<span class="property">__proto__</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;KK&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(p, <span class="title class_">Person</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(p, <span class="title class_">Object</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.create/">手写Object.create</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_new/">手写new</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | new操作符</title>
    <url>/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_new/</url>
    <content><![CDATA[<h3 id="mdn"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h3><blockquote>
<p>new运算符创建一个用户定义的对象类型的实例或者具有构造函数的内置对象的实例</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> constructor[([<span class="variable language_">arguments</span>])]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>constructor</code>：一个指定对象实例的类型的类或函数</p>
<p><code>arguments</code>：一个用于被<code>constructor</code>调用的参数列表</p>
<h3 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h3><p><strong>new关键字会进行如下操作</strong></p>
<ol>
<li>创建一个空对象</li>
<li>为空对象添加<code>__proto__</code>，指向构造函数的<code>prototype</code>对象</li>
<li>将新对象作为<code>this</code>的上下文，并且执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果该函数没有返回对象，则返回<code>this</code></li>
</ol>
<p><strong>对于返回值的说明</strong></p>
<ul>
<li>如果构造函数有返回值且是对象，则返回这个对象</li>
<li>如果构造函数有返回值且不是对象，则返回创建的空对象</li>
<li>如果构造函数没有返回值，返回创建的空对象</li>
</ul>
<p><strong>手写new</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">	<span class="keyword">let</span> constr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>([...<span class="variable language_">arguments</span>]);</span><br><span class="line">    <span class="keyword">let</span> proto = constr.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line">    <span class="keyword">let</span> res = constr.<span class="title function_">apply</span>(newObj, [...<span class="variable language_">arguments</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res : newObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);   <span class="comment">// &#123;name: &#x27;Katrina&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Person</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_instanceof/">手写instanceof</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.create/">手写Object.create</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | 柯里化</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><blockquote>
<p><strong>柯里化</strong>：是一种函数的转化，它是指将接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术</p>
<p>简单地说，就是固定一个参数，返回一个接受剩余参数的函数，<strong>实质上就是使用闭包返回一个延迟执行函数</strong></p>
</blockquote>
<p>看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">f</span>) &#123;   <span class="comment">// curry(f)执行柯里化转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">f</span>(a,b)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = <span class="title function_">curry</span>(sum);    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	curriedSum = function(a) &#123;</span></span><br><span class="line"><span class="comment">		return function(b) &#123;</span></span><br><span class="line"><span class="comment">		return sum(a,b);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">curriedSum</span>(<span class="number">1</span>)(<span class="number">2</span>);   <span class="comment">// 3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分解</span></span><br><span class="line"><span class="comment">	curriedSum(1) = function(b) &#123;</span></span><br><span class="line"><span class="comment">		return sum(1,b)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	curriedSum(2) = sum(1,2);   // 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>curry的实现如上面代码所示，十分简单：只要有两个包装器（wrapper）</p>
<ul>
<li><code>curry(func)</code> 的结果就是一个包装器 <code>function(a)</code>。</li>
<li>当它被像 <code>curriedSum(1)</code> 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 <code>function(b)</code>。</li>
<li>然后这个包装器被以 <code>2</code> 为参数调用，并且，它将该调用传递给原始的 <code>sum</code> 函数。</li>
</ul>
<h3 id="柯里化优点"><a href="#柯里化优点" class="headerlink" title="柯里化优点"></a>柯里化优点</h3><h4 id="参数复用或者说是固定参数避免重复传参"><a href="#参数复用，或者说是固定参数，避免重复传参" class="headerlink" title="参数复用，或者说是固定参数，避免重复传参"></a>参数复用，或者说是固定参数，避免重复传参</h4><p>比如说我们用正则验证一个手机号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...callbackArgs</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> currentArgs = [...args, ...callbackArgs];</span><br><span class="line">        <span class="keyword">return</span> callbackArgs.<span class="property">length</span> === <span class="number">0</span> || currentArgs.<span class="property">length</span> === fn.<span class="property">length</span> ? <span class="title function_">fn</span>(...currentArgs) : <span class="title function_">curry</span>(fn, ...currentArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> phoneReg = <span class="regexp">/^1[3-9]\d&#123;9&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_checkPhone</span>(<span class="params">reg, phone</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(phone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">_checkPhone</span>(phoneReg, <span class="number">19956526362</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="keyword">const</span> checkPhone = <span class="title function_">curry</span>(_checkPhone)(phoneReg);  <span class="comment">// 这样我们就复用了验证手机的正则，这就是复用参数，或者说是固定参数</span></span><br><span class="line"><span class="title function_">checkPhone</span>(<span class="number">19956526362</span>);</span><br><span class="line"><span class="title function_">checkPhone</span>(<span class="number">16956526362</span>);</span><br></pre></td></tr></table></figure>

<h4 id="提前返回或者说是提前确认避免重复判断-和-延迟执行"><a href="#提前返回，或者说是提前确认，避免重复判断-和-延迟执行" class="headerlink" title="提前返回，或者说是提前确认，避免重复判断 和 延迟执行"></a>提前返回，或者说是提前确认，避免重复判断 和 延迟执行</h4><p>再做一个拓展，我们需要对一个正确的手机号做一系列不同步的操作（同步的话就没有意义了）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething1</span>(<span class="params">reg, phone, callback</span>) &#123;</span><br><span class="line">    reg.<span class="title function_">test</span>(phone) &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething2</span>(<span class="params">reg, phone, callback</span>) &#123;</span><br><span class="line">    reg.<span class="title function_">test</span>(phone) &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething1</span>(phoneReg, <span class="number">19956526362</span>，callback1)；</span><br><span class="line"><span class="title function_">doSomething2</span>(phoneReg, <span class="number">19956526362</span>，callback2)；</span><br><span class="line"><span class="comment">// 既然是对同一个号码做判断，我们当然可以先将判断结果保存下来，这样就不用每次都做判断了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_doSomething</span>(<span class="params">reg, phone, callback</span>) &#123;</span><br><span class="line">    reg.<span class="title function_">test</span>(phone) &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="title function_">curry</span>(_doSomething)(<span class="number">19956526362</span>);  <span class="comment">// 这里就是提前返回电话号码是否正确了</span></span><br><span class="line"><span class="title function_">doSomething</span>(callback1);                                <span class="comment">// 这里就是延迟执行</span></span><br><span class="line"><span class="title function_">doSomething</span>(callback2);</span><br></pre></td></tr></table></figure>

<h4 id="动态创建函数"><a href="#动态创建函数" class="headerlink" title="动态创建函数"></a>动态创建函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addEvent = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">elem, type, fn, capture</span>) =&gt;</span> &#123;</span><br><span class="line">            elem.<span class="title function_">addEventListener</span>(type, <span class="function">(<span class="params">e</span>) =&gt;</span> fn.<span class="title function_">call</span>(elem, e), capture);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">elem, type, fn, capture</span>) =&gt;</span> &#123;</span><br><span class="line">            elem.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + type, <span class="function">(<span class="params">e</span>) =&gt;</span> fn.<span class="title function_">call</span>(elem, e));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCurry</span>(<span class="params">func, ...args</span>) &#123;   <span class="comment">// func为需要柯里化的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 合并参数</span></span><br><span class="line">        args = [...args, ...<span class="variable language_">arguments</span>];</span><br><span class="line">        <span class="comment">// 判断参数的个数是否足够</span></span><br><span class="line">        <span class="keyword">if</span> (args.<span class="property">length</span> &lt; func.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 不够继续递归</span></span><br><span class="line">            <span class="comment">// 注意这里每一次递归都会形成新的闭包</span></span><br><span class="line">            <span class="comment">// 保证柯里化函数每一步都是独立的 互不影响</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">myCurry</span>(func, ...args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 参数足够，执行函数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">func</span>(...args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b,c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sumCurried = <span class="title function_">myCurry</span>(sum);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sumCurried</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>));   <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sumCurried = <span class="title function_">myCurry</span>(sum);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sumCurried</span>(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>));    <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sumCurried = <span class="title function_">myCurry</span>(sum);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sumCurried</span>(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>));    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.javascript.info/currying-partials">柯里化（Currying）</a></p>
<p><a href="https://juejin.cn/post/6844904105643606030">看完这个，你还不懂函数柯里化？</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
      </tags>
  </entry>
  <entry>
    <title>手写场景 | Promise实现并发数控制</title>
    <url>/2022/07/15/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF_Promise%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>实现一个输入<code>url</code>数组与并发数的并发数量，控制请求队列函数</p>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>控制并发数量，关键点是利用promise，当一个请求完成之后再去发起下一个请求</p>
<ul>
<li>要完成一个继续一个，保证同时有limit个在同时执行，所以需要一个递归的执行函数run（用于执行并发limit个url）</li>
<li>首先在函数执行时，需要将执行中的任务按顺序填满，数量为限制并发数（利用for循环执行）</li>
<li>执行函数中，需要在执行完成后，判断是否有下一个待执行任务：（如果执行完毕的数量小于urls的长度，说明还没有执行完）<ul>
<li>声明变量i来计数，与最终需要执行的总数比较判断是否需要递归执行下一个任务</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// url执行函数（充当着发送请求的任务）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里用Promise来模拟发送请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;完成一个任务&#x27;</span>, url, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            url, </span><br><span class="line">            <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制并发url函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	传入参数为：</span></span><br><span class="line"><span class="comment">		1. urls[数组]</span></span><br><span class="line"><span class="comment">		2. limit[允许并发数]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">limitQueue</span>(<span class="params">urls, limit</span>) &#123;</span><br><span class="line">    <span class="comment">// 完成任务数量（记录）</span></span><br><span class="line">    <span class="keyword">let</span> fulfilledIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 填充执行队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> executeIndex = <span class="number">0</span>; executeIndex &lt; limit; executeIndex++) &#123;</span><br><span class="line">        <span class="title function_">run</span>();   <span class="comment">// 执行任务</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行任务函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 构造待执行任务，当该任务完成后，如果还有待完成得任务 就继续执行</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> url = urls[fulfilledIndex++];  <span class="comment">// 获取当前url</span></span><br><span class="line">            <span class="title function_">resolve</span>(<span class="title function_">fn</span>(url));    <span class="comment">// resolve fn执行得结果</span></span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fulfilledIndex &lt; urls.<span class="property">length</span>) &#123;  <span class="comment">// 说明还有没执行完的</span></span><br><span class="line">                <span class="title function_">run</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> urls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> _ =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">limitQueue</span>(urls, <span class="number">4</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	完成一个任务 1 2022-07-16T07:23:41.283Z</span></span><br><span class="line"><span class="comment">    完成一个任务 2 2022-07-16T07:23:41.287Z</span></span><br><span class="line"><span class="comment">    完成一个任务 3 2022-07-16T07:23:41.288Z</span></span><br><span class="line"><span class="comment">    完成一个任务 4 2022-07-16T07:23:41.288Z</span></span><br><span class="line"><span class="comment">    完成一个任务 5 2022-07-16T07:23:41.288Z</span></span><br><span class="line"><span class="comment">    完成一个任务 6 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 7 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 8 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 9 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 10 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 11 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 12 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 13 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 14 2022-07-16T07:23:41.289Z</span></span><br><span class="line"><span class="comment">    完成一个任务 15 2022-07-16T07:23:41.290Z</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
        <category>手写场景</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写场景</tag>
        <tag>异步函数</tag>
      </tags>
  </entry>
  <entry>
    <title>手写原理 | 防抖节流</title>
    <url>/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><blockquote>
<p>事件触发n秒之后再执行，如果n秒内有触发就重新计时</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line"> 	<span class="keyword">let</span> timer;</span><br><span class="line">    <span class="comment">// 这里的this指向window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 这里this指向要接收事件的HTML元素，比如我们给button绑定一个click事件并应用节流，那么这里的this就指向bnt</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 原本setTimeout的this是指向window的，但是这里用了箭头函数，所以也是指向bnt</span></span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><blockquote>
<p>事件被连续触发但是n秒内只执行一次</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里的this指向window</span></span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 这里this指向要接收事件的HTML元素，比如我们给button绑定一个click事件并应用节流，那么这里的this就指向bnt</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 原本setTimeout的this是指向window的，但是这里用了箭头函数，所以也是指向bnt</span></span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
      </tags>
  </entry>
  <entry>
    <title>手写场景 | setTimeout实现setInterval</title>
    <url>/2022/07/15/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF_setTimeout%E5%AE%9E%E7%8E%B0setInterval/</url>
    <content><![CDATA[<blockquote>
<p><code>setTimeout()</code> ：在指定的毫秒数后调用函数或计算表达式，只执行一次<br> <code>setInterval()</code> ：按照指定的周期（以毫秒计）来调用函数或计算表达式，方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭</p>
</blockquote>
<h3 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInterval</span>(<span class="params">cb, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">cb</span>();</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">fn</span>(), delay)     <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">fn</span>(), delay);      <span class="comment">// 触发递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">myInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在打印&#x27;</span>), <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除定时器</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timer);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
        <category>手写场景</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写场景</tag>
      </tags>
  </entry>
  <entry>
    <title>手写场景 | 实现lazyMan</title>
    <url>/2022/07/14/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF_%E5%AE%9E%E7%8E%B0lazyMan/</url>
    <content><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">实现一个LazyMan，可以按照以下方式调用:</span><br><span class="line">LazyMan(&quot;Hank&quot;)输出:</span><br><span class="line">Hi! This is Hank!</span><br><span class="line"> </span><br><span class="line">LazyMan(&quot;Hank&quot;).sleep(10).eat(&quot;dinner&quot;)</span><br><span class="line">输出</span><br><span class="line">Hi! This is Hank!</span><br><span class="line">//等待10秒..</span><br><span class="line">Wake up after 10</span><br><span class="line">Eat dinner~</span><br><span class="line"> </span><br><span class="line">LazyMan(&quot;Hank&quot;).eat(&quot;dinner&quot;).eat(&quot;supper&quot;)</span><br><span class="line">输出</span><br><span class="line">Hi This is Hank!</span><br><span class="line">Eat dinner~</span><br><span class="line">Eat supper~</span><br><span class="line"> </span><br><span class="line">LazyMan(&quot;Hank&quot;).sleepFirst(5).eat(&quot;supper&quot;)</span><br><span class="line">输出</span><br><span class="line">//等待5秒</span><br><span class="line">Wake up after 5</span><br><span class="line">Hi This is Hank!</span><br><span class="line">Eat supper</span><br><span class="line"> </span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure>

<h3 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h3><ul>
<li>方法链式调用</li>
<li>类的使用和面向对象编程的思路</li>
<li>设计模式引用</li>
<li>代码解耦</li>
<li>最少知识原则</li>
<li>代码的书写结果和命名</li>
</ul>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol>
<li>看题目输出示例，这是一个拟人化的输出 &#x3D;&gt; 定义一个名为<code>LazyMan</code>的类，类里面有<code>sayName</code>、<code>eat</code>、<code>sleep</code>等方法</li>
<li>从输出结果来看：<code>sleepFirst</code>的优先级最高，其余的行为优先级一致</li>
<li><code>LazyMan</code>首先需要初始化人，才能继续后面的行为，因此<code>LazyMan</code>是一个接口  &#x3D;&gt; <code>sayName</code>方法一定在构造函数中</li>
<li>按调用的方法次序进行顺序执行，是一个队列</li>
</ol>
<h3 id="实现思路及代码"><a href="#实现思路及代码" class="headerlink" title="实现思路及代码"></a>实现思路及代码</h3><h4 id="1任务队列实现"><a href="#（1）任务队列实现" class="headerlink" title="（1）任务队列实现"></a>（1）任务队列实现</h4><p>这种模式类似于<strong>中间件模式</strong>，其核心是<code>next</code>方法，每当队列中的一个方法执行完都会调用<code>next</code>方法来执行队列中的另一个方法，直到全部执行完成</p>
<p>构造函数中需要setTimeout保证队列开始执行的时间是在下一个事件循环中，从而确保当前的链式调用中的所有行为在调用之前被加载进队列中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LazyMan</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">sayName</span>(name);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">next</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> task = <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">shift</span>();   <span class="comment">// 拿出队列最前面的方法，并且要在队列里面删除它</span></span><br><span class="line">        task &amp;&amp; <span class="title function_">task</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! This is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">next</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(task);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sleep</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">_sleepWrapper</span>(time));</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sleepFirst</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">unshift</span>(<span class="variable language_">this</span>.<span class="title function_">_sleepWrapper</span>(time));</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">_sleepWrapper</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Wake up afeter <span class="subst">$&#123;time&#125;</span> second`</span>);</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">next</span>();</span><br><span class="line">            &#125;, time * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="title function_">eat</span>(<span class="params">type</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Eat <span class="subst">$&#123;type&#125;</span>~`</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">next</span>();</span><br><span class="line">      &#125;; </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(task);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyMan</span> = (<span class="params">name</span>) =&gt; <span class="keyword">new</span> <span class="title function_">_LazyMan</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="title class_">LazyMan</span>(<span class="string">&quot;Hank&quot;</span>).<span class="title function_">sleepFirst</span>(<span class="number">5</span>).<span class="title function_">eat</span>(<span class="string">&quot;supper&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Wake up afeter 5 second</span></span><br><span class="line"><span class="comment">	Hi! This is Hank!</span></span><br><span class="line"><span class="comment">	Eat supper~</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2任务队列-promise实现"><a href="#（2）任务队列-Promise实现" class="headerlink" title="（2）任务队列 + Promise实现"></a>（2）任务队列 + Promise实现</h4><blockquote>
<p>用Promise代替next调用方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LazyMan</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">sayName</span>(name);</span><br><span class="line">        </span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> task = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                task = task.<span class="title function_">then</span>(item);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! This is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(task);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sleep</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">_sleepWrapper</span>(time));</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sleepFirst</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">unshift</span>(<span class="variable language_">this</span>.<span class="title function_">_sleepWrapper</span>(time));</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">_sleepWrapper</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Wake up afeter <span class="subst">$&#123;time&#125;</span> second`</span>);</span><br><span class="line">                <span class="title function_">resolve</span>();</span><br><span class="line">            &#125;, time * <span class="number">1000</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="title function_">eat</span>(<span class="params">type</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`eat <span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyMan</span> = (<span class="params">name</span>) =&gt; <span class="keyword">new</span> <span class="title function_">_LazyMan</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="title class_">LazyMan</span>(<span class="string">&quot;Hank&quot;</span>).<span class="title function_">sleepFirst</span>(<span class="number">5</span>).<span class="title function_">eat</span>(<span class="string">&quot;supper&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Wake up afeter 5 second</span></span><br><span class="line"><span class="comment">	Hi! This is Hank!</span></span><br><span class="line"><span class="comment">	Eat supper~</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="3任务队列-async实现"><a href="#（3）任务队列-async实现" class="headerlink" title="（3）任务队列 + async实现"></a>（3）任务队列 + async实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LazyMan</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">sayName</span>(name);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">tasks</span>) &#123;</span><br><span class="line">                <span class="keyword">await</span> <span class="title function_">task</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! This is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(task);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sleep</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">_sleepWrapper</span>(time));</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sleepFirst</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">unshift</span>(<span class="variable language_">this</span>.<span class="title function_">_sleepWrapper</span>(time));</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">_sleepWrapper</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Wake up afeter <span class="subst">$&#123;time&#125;</span> second`</span>);</span><br><span class="line">                <span class="title function_">resolve</span>();</span><br><span class="line">            &#125;, time * <span class="number">1000</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="title function_">eat</span>(<span class="params">type</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`eat <span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LazyMan</span> = (<span class="params">name</span>) =&gt; <span class="keyword">new</span> <span class="title function_">_LazyMan</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="title class_">LazyMan</span>(<span class="string">&quot;Hank&quot;</span>).<span class="title function_">sleepFirst</span>(<span class="number">5</span>).<span class="title function_">eat</span>(<span class="string">&quot;supper&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Wake up afeter 5 second</span></span><br><span class="line"><span class="comment">	Hi! This is Hank!</span></span><br><span class="line"><span class="comment">	Eat supper~</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/f1b7cb456d37">LazyMan的深入解析和实现</a></p>
<p><a href="https://juejin.cn/post/6883706752487915534">多种方式实现 LazyMan</a></p>
<p><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/22387417">如何实现一个LazyMan?</a></p>
<p><a href="https://link.juejin.cn/?target=https://github.com/fi3ework/blog/issues/36">LazyMan 有几样写法，你知道么？</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>手写场景</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写场景</tag>
        <tag>异步函数</tag>
      </tags>
  </entry>
  <entry>
    <title>手写场景 | 三种不同的网络请求方式实现列表动态渲染</title>
    <url>/2022/07/15/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF_%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>突（<del>预</del>）发（<del>谋</del>）奇（<del>已</del>）想（<del>久</del>）想基于AJAX封装、axios、fetch实现同一种效果</p>
<p>我想实现的效果很简单：基于URL返回数据并且动态渲染在页面上</p>
<p>在此感谢，Github某老哥提供的接口：<a href="https://github.com/Binaryify/NeteaseCloudMusicApi">https://github.com/Binaryify/NeteaseCloudMusicApi</a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>BASE_URL：<code>&#39;http://localhost:3000&#39;</code></li>
<li>接口文档：<code>&#39;/artist/top/song?id=&#39; + id </code>，示例为<code>&#39;/artist/top/song?id=6452&#39;</code></li>
<li>data数据结构如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mock</span></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123;<span class="attr">name</span>: xxx, <span class="attr">xxx</span>: xxx, ...&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: xxx, <span class="attr">xxx</span>: xxx, ...&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: xxx, <span class="attr">xxx</span>: xxx, ...&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: xxx, <span class="attr">xxx</span>: xxx, ...&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: xxx, <span class="attr">xxx</span>: xxx, ...&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: xxx, <span class="attr">xxx</span>: xxx, ...&#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>动态渲染函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getList</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取ul</span></span><br><span class="line">        <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 动态渲染数据</span></span><br><span class="line">        data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 创建li节点</span></span><br><span class="line">            <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">            <span class="comment">// 给li添加文本内容</span></span><br><span class="line">            li.<span class="property">innerHTML</span> = item.<span class="property">name</span>;    <span class="comment">// 我只想渲染name</span></span><br><span class="line">            <span class="comment">// 把li添加到ul下作为子节点</span></span><br><span class="line">            ul.<span class="title function_">appendChild</span>(li);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式1基于promise封装的ajax"><a href="#方式1：基于Promise封装的AJAX" class="headerlink" title="方式1：基于Promise封装的AJAX"></a>方式1：基于Promise封装的AJAX</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>axios<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>ajax<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>发送GET请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>数据展示<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span> = <span class="string">&#x27;list&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// Promise封装AJAX</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">myAJAX</span>(<span class="params">method=<span class="string">&#x27;GET&#x27;</span>, url=<span class="string">&#x27;&#x27;</span>, isAysnc=<span class="literal">true</span>, data=<span class="literal">null</span></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 新建xhr对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 监听状态变化</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span> || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">reject</span>(xhr.<span class="property">statusText</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 建立连接</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">open</span>(method, url, isAysnc);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">send</span>(data);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 动态渲染函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">getList</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(&#x27;d&#x27;, data);</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取ul</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 循环输出数据</span></span></span><br><span class="line"><span class="language-javascript">            data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 创建li</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 指定文本内容插入li中</span></span></span><br><span class="line"><span class="language-javascript">                li.<span class="property">innerHTML</span> = item.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 创建的li插入ul中</span></span></span><br><span class="line"><span class="language-javascript">                ul.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="variable constant_">BASE_URL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 需求1：获取热门50首歌曲 id为6452</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">hotSongsRequest</span> = (<span class="params">id</span>) =&gt; <span class="title function_">myAJAX</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="variable constant_">BASE_URL</span> + <span class="string">&#x27;/artist/top/song?id=&#x27;</span> + id, <span class="literal">true</span>, <span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        btns[<span class="number">0</span>].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> res = <span class="title function_">hotSongsRequest</span>(<span class="number">6452</span>);</span></span><br><span class="line"><span class="language-javascript">            res.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(value);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">getList</span>(data.<span class="property">songs</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="方式2axios"><a href="#方式2：axios" class="headerlink" title="方式2：axios"></a>方式2：axios</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ajax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.26.0/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>axios<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>发送GET请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>数据展示<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span> = <span class="string">&#x27;list&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 动态渲染函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">getList</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(&#x27;d&#x27;, data);</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取ul</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 循环输出数据</span></span></span><br><span class="line"><span class="language-javascript">            data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 创建li</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 指定文本内容插入li中</span></span></span><br><span class="line"><span class="language-javascript">                li.<span class="property">innerHTML</span> = item.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 创建的li插入ul中</span></span></span><br><span class="line"><span class="language-javascript">                ul.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="variable constant_">BASE_URL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 需求1：获取热门50首歌曲 id为6452</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">hotSongsRequest</span> = (<span class="params">id</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>: <span class="variable constant_">BASE_URL</span> + <span class="string">&#x27;/artist/top/song?id=&#x27;</span> + id,</span></span><br><span class="line"><span class="language-javascript">            &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> data = value.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">getList</span>(data.<span class="property">songs</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        btns[<span class="number">0</span>].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> <span class="title function_">hotSongsRequest</span>(<span class="number">6452</span>));</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="方式3fetch"><a href="#方式3：fetch" class="headerlink" title="方式3：fetch"></a>方式3：fetch</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>fetch<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>fetch<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>发送GET请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>数据展示<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span> = <span class="string">&#x27;list&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 动态渲染函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">getList</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(&#x27;d&#x27;, data);</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取ul</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;ul&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 循环输出数据</span></span></span><br><span class="line"><span class="language-javascript">            data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 创建li</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 指定文本内容插入li中</span></span></span><br><span class="line"><span class="language-javascript">                li.<span class="property">innerHTML</span> = item.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 创建的li插入ul中</span></span></span><br><span class="line"><span class="language-javascript">                ul.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="variable constant_">BASE_URL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 需求1：获取热门50首歌曲 id为6452</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title function_">hotSongsRequest</span> = (<span class="params">id</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> url = <span class="variable constant_">BASE_URL</span> + <span class="string">&#x27;/artist/top/song?id=&#x27;</span> + id;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                response.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">let</span> data = value.<span class="property">songs</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">getList</span>(data);</span></span><br><span class="line"><span class="language-javascript">                &#125;)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        btns[<span class="number">0</span>].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">hotSongsRequest</span>(<span class="number">6452</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/05/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_AJAX/">网络请求 | AJAX</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_Fetch_API/">网络请求 | Fetch_API 基本用法</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">MDN Fetch API</a></p>
<p><a href="https://www.w3schools.com/xml/ajax_intro.asp">AJAX Introduction</a></p>
<p><a href="https://axios-http.com/docs/api_intro">axios API</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>手写场景</category>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写场景</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title>手写场景 | 手写全选框</title>
    <url>/2022/07/16/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF_%E6%89%8B%E5%86%99%E5%85%A8%E9%80%89%E6%A1%86/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>手写全选框</p>
<p>设置一个全选框和全不选框以及若干个选择框</p>
<p>要求如下：</p>
<ol>
<li>选中全选框或者全不选框：其余若干个选择框都要选中或者不选</li>
<li>选中若干个选择框全部选中&#x2F;不选时：全选框和全不选框自动选上</li>
</ol>
<h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><ol>
<li>选择框：<code>&lt;input type=&#39;checkbox&#39;&gt;</code></li>
<li>通过<code>.checked</code>属性判断选择框是否被选择，true为选择，false为不选择</li>
<li>通过控制<code>xxx.checked = true</code>控制选中，同理通过控制<code>xxx.checked = false</code>控制不选中</li>
</ol>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><h4 id="1-全选框思路"><a href="#1-全选框思路" class="headerlink" title="1. 全选框思路"></a>1. 全选框思路</h4><p>通过监听全选框的click事件，获取全选框的checked的状态，获取到状态之后，则遍历选择框，将选择框的状态设置为和全选框状态一样</p>
<h4 id="2-全不选框思路"><a href="#2-全不选框思路" class="headerlink" title="2. 全不选框思路"></a>2. 全不选框思路</h4><p>通过监听全不选框的click事件，获取全不选框的checked的状态，获取到状态之后，则遍历选择框，将选择框的状态设置为和全不选框状态相反</p>
<h4 id="3-选择框思路"><a href="#3-选择框思路" class="headerlink" title="3. 选择框思路"></a>3. 选择框思路</h4><p>通过对每一个选择框增加click事件，获取checked状态为true的选择框的数量，根据不同的情况处理全选框和全不选框</p>
<ul>
<li>情况1：数量为0 &#x3D;&gt; 设置全不选框checked属性为true，全选框为false</li>
<li>情况2：数量不为0<ul>
<li>数量等于选择框数量 &#x3D;&gt; 设置全不选框checked属性为false，全选框为true</li>
<li>数量不等于选择框数量  &#x3D;&gt; 设置全不选框checked属性为false，全选框为false</li>
</ul>
</li>
</ul>
<h4 id="4-细节处理"><a href="#4-细节处理" class="headerlink" title="4. 细节处理"></a>4. 细节处理</h4><p>全选和全不选永远是互斥的</p>
<p>所以在对全不选和全选框事件监听的时候，不仅仅要改变选择框的状态，也要改变对方的状态</p>
<h3 id="js原生实现"><a href="#JS原生实现" class="headerlink" title="JS原生实现"></a>JS原生实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;checkedAll&quot;</span>&gt;</span>全选</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;unCheckedAll&quot;</span>&gt;</span>全不选</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;check&quot;</span>&gt;</span>选择1</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;check&quot;</span>&gt;</span>选择2</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;check&quot;</span>&gt;</span>选择3</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;check&quot;</span>&gt;</span>选择4</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;check&quot;</span>&gt;</span>选择5</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">class</span>=<span class="string">&quot;check&quot;</span>&gt;</span>选择6</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取全选框，全不选框，选择框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> selectAll = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.checkedAll&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> unSelectAll = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.unCheckedAll&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> checks = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.check&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 全选方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      实现思路：</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        通过监听全选框的checked状态，一次遍历选择框，将它们的checked状态设置为和全选框一样的状态</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    */</span></span></span><br><span class="line"><span class="language-javascript">    selectAll.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> selectAllState = selectAll.<span class="property">checked</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 细节处理：全选和全不选永远是互斥的</span></span></span><br><span class="line"><span class="language-javascript">       unSelectAll.<span class="property">checked</span> = !selectAllState;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 对选择框进行处理</span></span></span><br><span class="line"><span class="language-javascript">       checks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          item.<span class="property">checked</span> = selectAllState;</span></span><br><span class="line"><span class="language-javascript">       &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 全不选方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      实现思路：</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        与全选框一样，只是状态设置的时候取反即可</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    unSelectAll.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> unSelectAllState = unSelectAll.<span class="property">checked</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 细节处理：全选和全不选永远是互斥的</span></span></span><br><span class="line"><span class="language-javascript">      selectAll.<span class="property">checked</span> = !unSelectAllState;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 对选择框进行处理 </span></span></span><br><span class="line"><span class="language-javascript">      checks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          item.<span class="property">checked</span> = !unSelectAllState;</span></span><br><span class="line"><span class="language-javascript">       &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 反选方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; checks.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="comment">// 对每一个选择框都要进行监听</span></span></span><br><span class="line"><span class="language-javascript">      checks[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="comment">// 统计此时选中选择框的个数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> checkCount = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.check:checked&#x27;</span>).<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// console.log(&#x27;checkCount&#x27;,checkCount);</span></span></span><br><span class="line"><span class="language-javascript">	<span class="comment">// 不同的情况进行判断</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (checkCount) &#123;</span></span><br><span class="line"><span class="language-javascript">          unSelectAll.<span class="property">checked</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (checkCount === checks.<span class="property">length</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            selectAll.<span class="property">checked</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            selectAll.<span class="property">checked</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">          &#125; </span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          selectAll.<span class="property">checked</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">          unSelectAll.<span class="property">checked</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><input type="checkbox" class="checkedAll">全选      <input type="checkbox" class="unCheckedAll">全不选<br><input type="checkbox" class="check">选择1<br><input type="checkbox" class="check">选择2<br><input type="checkbox" class="check">选择3<br><input type="checkbox" class="check">选择4<br><input type="checkbox" class="check">选择5<br><input type="checkbox" class="check">选择6</p>
<script type="text/javascript">
    const selectAll = document.querySelector('.checkedAll');
    const unSelectAll = document.querySelector('.unCheckedAll');
    const checks = document.querySelectorAll('.check');
    selectAll.addEventListener('click', function () {
      let selectAllState = selectAll.checked;
      unSelectAll.checked = !selectAllState;
      checks.forEach((item, index) => {
        item.checked = selectAllState;
      })
    })
    unSelectAll.addEventListener('click', function () {
      let unSelectAllState = unSelectAll.checked;
      selectAll.checked = !unSelectAllState;
      checks.forEach((item, index) => {
        item.checked = !unSelectAllState;
      })
    })
    for (let i = 0; i < checks.length; i++) {
      checks[i].addEventListener('click', function () {
        let checkCount = document.querySelectorAll('.check:checked').length;
        // console.log('checkCount',checkCount);
        if (checkCount) {
          unSelectAll.checked = false;
          if (checkCount === checks.length) {
            selectAll.checked = true;
          } else {
            selectAll.checked = false;
          }
        } else {
          selectAll.checked = false;
          unSelectAll.checked = true;
        }
      })
    }
</script>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>手写场景</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写场景</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | Tree2List&amp;&amp;List2Tree</title>
    <url>/2022/07/17/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_Tree2List&amp;&amp;List2Tree/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>典型的数结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> treeData = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;p1&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;浙江&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="string">&#x27;p1-1&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;杭州&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: [],</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="string">&#x27;p1-2&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;绍兴&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: [],</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;p2&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;江苏&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="string">&#x27;p2-1&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;南京&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: [],</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="string">&#x27;p2-2&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;苏州&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: [],</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>平铺list结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listData = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;p1&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;浙江&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;p2&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;江苏&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;p1-1&#x27;</span>, <span class="attr">pid</span>:<span class="string">&#x27;p1&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;杭州&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;p1-2&#x27;</span>, <span class="attr">pid</span>:<span class="string">&#x27;p1&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;绍兴&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;p2-1&#x27;</span>, <span class="attr">pid</span>:<span class="string">&#x27;p2&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;南京&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;p2-2&#x27;</span>, <span class="attr">pid</span>:<span class="string">&#x27;p2&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;苏州&#x27;</span>&#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="list转tree"><a href="#List转Tree" class="headerlink" title="List转Tree"></a>List转Tree</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">list2tree</span>(<span class="params">listData</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> treeData = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> listData) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node.<span class="property">pid</span>) &#123;   <span class="comment">// 没有pid，说明是父节点</span></span><br><span class="line">            <span class="keyword">let</span> p = &#123;...node&#125;;   <span class="comment">// 对象的解构</span></span><br><span class="line">            p.<span class="property">children</span> = <span class="title function_">getChildren</span>(p.<span class="property">id</span>, listData);</span><br><span class="line">            treeData.<span class="title function_">push</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到子节点</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getChildren</span>(<span class="params">id, listData</span>) &#123;</span><br><span class="line">        <span class="comment">// 过滤出pid === id的所有结果并且存在数组中，把这个数组作为父节点的children</span></span><br><span class="line">        <span class="comment">// 注意：这里不能用find，因为find是返回找到的第一个结果</span></span><br><span class="line">        <span class="keyword">return</span> listData.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">pid</span> === id)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> treeData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双层循环"><a href="#双层循环" class="headerlink" title="双层循环"></a>双层循环</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">list2tree</span>(<span class="params">listData</span>) &#123;</span><br><span class="line">  listData.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pid = child.<span class="property">pid</span></span><br><span class="line">    <span class="keyword">if</span>(pid) &#123;</span><br><span class="line">      listData.<span class="title function_">forEach</span>(<span class="function"><span class="params">parent</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent.<span class="property">id</span> === pid) &#123;</span><br><span class="line">          parent.<span class="property">children</span> = parent.<span class="property">children</span> || []</span><br><span class="line">          parent.<span class="property">children</span>.<span class="title function_">push</span>(child)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> listData.<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> !n.<span class="property">pid</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">list2tree</span>(<span class="params">listData</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(),</span><br><span class="line">          treeData = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listData.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        m.<span class="title function_">set</span>(listData[i].<span class="property">id</span>, i);   <span class="comment">// 把节点的id存入映射</span></span><br><span class="line">        listData[i].<span class="property">children</span> = [];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次遍历节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listData.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = listData[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有父节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">pid</span> &amp;&amp; m.<span class="title function_">has</span>(node.<span class="property">pid</span>)) &#123;</span><br><span class="line">            listData[m.<span class="title function_">get</span>(node.<span class="property">pid</span>)].<span class="property">children</span>.<span class="title function_">push</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果没有</span></span><br><span class="line">            treeData.<span class="title function_">push</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> treeData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tree转list"><a href="#Tree转List" class="headerlink" title="Tree转List"></a>Tree转List</h3><h4 id="bfs"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tree2list</span>(<span class="params">treeData</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> listData = [];</span><br><span class="line">    <span class="keyword">const</span> queue = [...treeData];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>();   <span class="comment">// 取出节点</span></span><br><span class="line">        <span class="keyword">const</span> children = node.<span class="property">children</span>;  <span class="comment">// 取出节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (children) &#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(...children);</span><br><span class="line">        &#125;</span><br><span class="line">        listData.<span class="title function_">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dfs"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tree2list</span>(<span class="params">treeData</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> listData  = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [...treeData];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">const</span> children = node.<span class="property">children</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (children) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(...children);</span><br><span class="line">        &#125;</span><br><span class="line">        listData.<span class="title function_">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/6952442048708345863">list和tree的相互转换</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
        <tag>和我一起做总结</tag>
      </tags>
  </entry>
  <entry>
    <title>手写场景 | 实现mergePromise函数</title>
    <url>/2022/07/22/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF_%E5%AE%9E%E7%8E%B0mergePromise%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现<code>mergePromise</code>函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数据data里面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">time</span> = (<span class="params">timer</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;, timer);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax1</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax2</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax3</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="comment">// code in here</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data:&#x27;</span>, data); <span class="comment">// data: [1,2,3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>这里要按照顺序执行，也就是执行1-2-3这样的顺序，但是1-2-3都用了setTimeout并且时间是不一致的，如果按照普通的思路，那么2-3会在1之前去执行，这样显然是不对的</p>
<ul>
<li><p>可以在执行ajax函数之前包装一个promise实例，让ajax在then里面执行</p>
</li>
<li><p>定义一个数组data用于保存所有的结果</p>
</li>
<li><p><code>mergePromise</code>一定返回一个promise实例</p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span>(<span class="params">ajaxArray</span>) &#123;</span><br><span class="line">    <span class="comment">// promises = [ajax1, ajax2, ajax3];</span></span><br><span class="line">    <span class="comment">// 存放结果</span></span><br><span class="line">    <span class="keyword">let</span> data = [];</span><br><span class="line">    <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">    ajaxArray.<span class="title function_">forEach</span>(<span class="function"><span class="params">ajax</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次then是为了调用ajax函数</span></span><br><span class="line">        <span class="comment">// 第二次then是为了获取结果</span></span><br><span class="line">        promise = promise.<span class="title function_">then</span>(ajax).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            data.<span class="title function_">push</span>(res);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	promise执行结果如下</span></span><br><span class="line"><span class="comment">	初始化：</span></span><br><span class="line"><span class="comment">	Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="comment">	第一次：</span></span><br><span class="line"><span class="comment">	Promise &#123;&lt;fulfilled&gt;: [1]&#125;</span></span><br><span class="line"><span class="comment">	第二次：</span></span><br><span class="line"><span class="comment">	Promise &#123;&lt;fulfilled&gt;: [1，2]&#125;</span></span><br><span class="line"><span class="comment">	第三次：</span></span><br><span class="line"><span class="comment">	Promise &#123;&lt;fulfilled&gt;: [1，2，3]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果为：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    done</span></span><br><span class="line"><span class="comment">    data: [ 1, 2, 3 ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
        <category>手写场景</category>
        <category>异步函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步函数</tag>
      </tags>
  </entry>
  <entry>
    <title>手写场景 | 虚拟DOM转真实DOM</title>
    <url>/2022/07/17/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF/%E6%89%8B%E5%86%99%E5%9C%BA%E6%99%AF_%E8%99%9A%E6%8B%9FDOM%E8%BD%AC%E7%9C%9F%E5%AE%9EDOM/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>虚拟DOM是一种轻量级的JS对象，包含以下属性：</p>
<ul>
<li>tag：标签名</li>
<li>attrs：属性，一般有id class name等等</li>
<li>children：子节点的标签名属性子节点等…</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟DOM</span></span><br><span class="line"><span class="keyword">const</span> vnode = &#123;</span><br><span class="line">	<span class="attr">tag</span>:<span class="string">&#x27;DIV&#x27;</span>,</span><br><span class="line">	<span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">tag</span>: <span class="string">&#x27;SPAN&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                &#123;<span class="attr">tag</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">children</span>: []&#125;</span><br><span class="line">            ],</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">tag</span>: <span class="string">&#x27;SPAN&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                &#123;<span class="attr">tag</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">children</span>: []&#125;,</span><br><span class="line">                &#123;<span class="attr">tag</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">children</span>: []&#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实DOM</span></span><br><span class="line">&lt;div id = <span class="string">&#x27;app&#x27;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	<span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>获取父节点的tag属性，通过document.createElement生成节点</li>
<li>若有属性，则通过setAttrubite(key, value)添加属性</li>
<li>如有子节点，则遍历子节点，重复步骤1，2</li>
<li>把子节点通过appendChild添加到父节点</li>
</ul>
<p>注意：最后会遇到节点为文本的情况，则可以通过createTextNode方式转义HTML字符，如果是number，可以先转换成string</p>
<h3 id="js实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myRender</span>(<span class="params">vnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是number类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        vnode = <span class="title class_">String</span>(vnode);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是string类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(vnode);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是普通的dom</span></span><br><span class="line">    <span class="keyword">let</span> dom = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">tag</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (vnode.<span class="property">attrs</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> vnode.<span class="property">attrs</span>) &#123;</span><br><span class="line">            dom.<span class="title function_">setAttribute</span>(key, vnode.<span class="property">attrs</span>[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子数组递归</span></span><br><span class="line">    <span class="keyword">if</span> (vnode.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        vnode.<span class="title function_">children</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> dom.<span class="title function_">appendChild</span>(<span class="title function_">myRender</span>(child)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
        <category>手写场景</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写场景</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | 大数相加</title>
    <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>因为JavaScript的number有安全范围：<code>[-2^53-1, 2^53]</code>，所以在大数相加的时候会出问题</p>
<p>比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">9007199254740991</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1234567899999999999</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a+b);   <span class="comment">// 1243575099254741000</span></span><br></pre></td></tr></table></figure>

<p>可知，相加的结果是在整数范围内的，小于b，结果肯定不准确</p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol>
<li>将大数转为字符串</li>
<li>对齐字符串</li>
<li>利用对齐位数相加并记录是否有进位</li>
<li>输出数字</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumBigInt</span>(<span class="params">val1, val2</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到两者最大长度</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(val1.<span class="property">length</span>, val2.<span class="property">length</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用0补齐字符串</span></span><br><span class="line">    val1 = val1.<span class="title function_">padStart</span>(maxLen, <span class="number">0</span>);</span><br><span class="line">    val2 = val2.<span class="title function_">padStart</span>(maxLen, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> remainer = <span class="number">0</span>;   <span class="comment">// 余数</span></span><br><span class="line">    <span class="keyword">let</span> digit = <span class="number">0</span>;      <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = maxLen - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        remainer = <span class="built_in">parseInt</span>(val1[index]) + <span class="built_in">parseInt</span>(val2[index]) + digit;</span><br><span class="line">        digit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(remainer / <span class="number">10</span>);</span><br><span class="line">        sum = remainer % <span class="number">10</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (digit === <span class="number">1</span>) &#123;</span><br><span class="line">        sum = <span class="string">&#x27;1&#x27;</span> + sum;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;9007199254740991&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;1234567899999999999&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">sumBigInt</span>(a, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);   <span class="comment">// 1243575099254740990</span></span><br></pre></td></tr></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhuanlan.zhihu.com/p/72179476">JS 实现两个大数相加？</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | 数组去重</title>
    <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h4 id="方式1展平数组再求和"><a href="#方式1：展平数组再求和" class="headerlink" title="方式1：展平数组再求和"></a>方式1：展平数组再求和</h4><p>数组扁平化方式有很多，请参照：<a href="https://superkatrina123.github.io/2022/07/14/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/">数据处理 | 数组扁平化（3种）</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="comment">// 先将数组展平</span></span><br><span class="line">    <span class="keyword">const</span> newArray = array.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里我利用reduce求和</span></span><br><span class="line">    <span class="keyword">return</span> newArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, c</span>) =&gt;</span> p+c, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">   <span class="number">5</span>,</span><br><span class="line">   <span class="number">7</span>,</span><br><span class="line">   [ <span class="number">4</span>, [<span class="number">2</span>], <span class="number">8</span>, [<span class="number">1</span>,<span class="number">3</span>], <span class="number">2</span> ],</span><br><span class="line">   [ <span class="number">9</span>, [] ],</span><br><span class="line">   <span class="number">1</span>,</span><br><span class="line">   <span class="number">8</span></span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2递归求和"><a href="#方式2：递归求和" class="headerlink" title="方式2：递归求和"></a>方式2：递归求和</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> array) &#123;</span><br><span class="line">        sum += <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) ? <span class="title function_">fn</span>(item) : item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">   <span class="number">5</span>,</span><br><span class="line">   <span class="number">7</span>,</span><br><span class="line">   [ <span class="number">4</span>, [<span class="number">2</span>], <span class="number">8</span>, [<span class="number">1</span>,<span class="number">3</span>], <span class="number">2</span> ],</span><br><span class="line">   [ <span class="number">9</span>, [] ],</span><br><span class="line">   <span class="number">1</span>,</span><br><span class="line">   <span class="number">8</span></span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<h4 id="方式3-同2但用reduce实现"><a href="#方式3：-同2但用reduce实现" class="headerlink" title="方式3： 同2但用reduce实现"></a>方式3： 同2但用reduce实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> acc += <span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">fn</span>(cur) : cur;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">   <span class="number">5</span>,</span><br><span class="line">   <span class="number">7</span>,</span><br><span class="line">   [ <span class="number">4</span>, [<span class="number">2</span>], <span class="number">8</span>, [<span class="number">1</span>,<span class="number">3</span>], <span class="number">2</span> ],</span><br><span class="line">   [ <span class="number">9</span>, [] ],</span><br><span class="line">   <span class="number">1</span>,</span><br><span class="line">   <span class="number">8</span></span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
        <tag>和我一起做总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | 数字按千分位隔开</title>
    <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E6%95%B0%E5%AD%97%E6%8C%89%E5%8D%83%E5%88%86%E4%BD%8D%E9%9A%94%E5%BC%80/</url>
    <content><![CDATA[<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1234567</span></span><br><span class="line"><span class="comment">// 转换为</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1</span>,<span class="number">234</span>,<span class="number">567</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有小数点，小数后面的不用转换</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">1234567.1234567</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">1</span>,<span class="number">234</span>,<span class="number">567.1234567</span></span><br></pre></td></tr></table></figure>

<h3 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h3><h4 id="方式1遍历添加"><a href="#方式1：遍历添加" class="headerlink" title="方式1：遍历添加"></a>方式1：遍历添加</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="comment">// 分隔小数</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="title class_">String</span>(num).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);  <span class="comment">// 转为字符串形式再进行分隔</span></span><br><span class="line">    <span class="comment">// 分成整数部分和小数部分</span></span><br><span class="line">    <span class="keyword">let</span> n1 = n[<span class="number">0</span>], n2 = n[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理整数部分</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	注意添加逗号是从后面开始添加的</span></span><br><span class="line"><span class="comment">    	不然会出现这样的情况</span></span><br><span class="line"><span class="comment">    	123,456,7</span></span><br><span class="line"><span class="comment">    	这样是不对的，所以可以先翻转，处理完后再翻转</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> temp = [...n1].<span class="title function_">reverse</span>();    <span class="comment">// 转为[&#x27;7&#x27;, &#x27;6&#x27;, &#x27;5&#x27;,&#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;,&#x27;1&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index  = <span class="number">0</span>; index &lt; temp.<span class="property">length</span>; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index % <span class="number">3</span> === <span class="number">0</span> &amp;&amp; index !== <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(temp[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res.<span class="title function_">reverse</span>();   <span class="comment">// 翻转</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> final = res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果有小数</span></span><br><span class="line">    n2.<span class="property">length</span> ? final = final + <span class="string">&#x27;.&#x27;</span> + [...n2].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) : final;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> final</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">1234567.1234567</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(num));   <span class="comment">// 1,234,567.1234567</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2正则表达式-replace-正则表达式我表示记不住啊~"><a href="#方式2：正则表达式-replace-【正则表达式我表示记不住啊-】" class="headerlink" title="方式2：正则表达式 replace 【正则表达式我表示记不住啊~】"></a>方式2：正则表达式 replace 【正则表达式我表示记不住啊~】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=num.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/\d+/</span>, <span class="keyword">function</span>(<span class="params">n</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> n.<span class="title function_">replace</span>(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>,<span class="keyword">function</span>(<span class="params">$<span class="number">1</span></span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> $<span class="number">1</span>+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">         &#125;);</span><br><span class="line">   &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">1234567.1234567</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(num));   <span class="comment">// 1,234,567.1234567</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | 数组乱序输出（3种）</title>
    <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h3 id="灵魂拷问数组乱序输出的方式你知道多少呢"><a href="#灵魂拷问：数组乱序输出的方式你知道多少呢？" class="headerlink" title="灵魂拷问：数组乱序输出的方式你知道多少呢？"></a>灵魂拷问：数组乱序输出的方式你知道多少呢？</h3><h4 id="方式1随机排序"><a href="#方式1：随机排序" class="headerlink" title="方式1：随机排序"></a>方式1：随机排序</h4><blockquote>
<p>随机抽取一个数，放进新数组中</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n^2)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSortArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>);    <span class="comment">// 可以在现有数组中随意抽取</span></span><br><span class="line">        res.<span class="title function_">push</span>(arr[index]);</span><br><span class="line">        <span class="comment">// 记得删除这个元素哦 不然会重复抽取</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">randomSortArray</span>(arr))   <span class="comment">// [8, 4, 2, 9, 7, 6, 1, 3, 5]  [温馨提示：结果勿轻信，每次都是随机的呀~]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2sort法"><a href="#方式2：sort法" class="headerlink" title="方式2：sort法"></a>方式2：<code>sort</code>法</h4><blockquote>
<p>元素之间的位置交换取决于<code>Math.random() - 0.5</code>的结果是大于0 小于0 还是等于0</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomSortArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">randomSortArray</span>(arr))   <span class="comment">// [3, 6, 2, 9, 4, 8, 5, 7, 1] [温馨提示：结果勿轻信，每次都是随机的呀~]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式3洗牌法"><a href="#方式3：洗牌法" class="headerlink" title="方式3：洗牌法"></a>方式3：洗牌法</h4><blockquote>
<p>将数组中的索引值随机打乱，交换当前索引值和随机变化后的索引值互换</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSortArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// randomIndex 处于 0 - arr.length之间，因为值不能是arr.length,所以Math.floor向下取值</span></span><br><span class="line">        <span class="keyword">let</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i+<span class="number">1</span>));   </span><br><span class="line">        <span class="comment">// 交换位置</span></span><br><span class="line">        [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">randomSortArray</span>(arr))   <span class="comment">// [4, 3, 5, 1, 8, 7, 6, 9, 2] [温馨提示：结果勿轻信，每次都是随机的呀~]</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
        <tag>和我一起做总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | 数组扁平化（3种）</title>
    <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<h3 id="灵魂拷问数组扁平化的方式你知道多少呢"><a href="#灵魂拷问：数组扁平化的方式你知道多少呢？" class="headerlink" title="灵魂拷问：数组扁平化的方式你知道多少呢？"></a>灵魂拷问：数组扁平化的方式你知道多少呢？</h3><h4 id="方式1arrayprototypeflat"><a href="#方式1：Array-prototype-flat" class="headerlink" title="方式1：Array.prototype.flat"></a>方式1：<code>Array.prototype.flat</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">flat</span>(depth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, [<span class="number">4</span>,<span class="number">5</span>], [[<span class="number">6</span>]], [[<span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]]], <span class="number">10</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr, <span class="number">2</span>))   <span class="comment">// [1, 2, 3, 4, 5, 6, 7, [8, 9], 10]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2reduce"><a href="#方式2：reduce" class="headerlink" title="方式2：reduce"></a>方式2：<code>reduce</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur)) &#123;</span><br><span class="line">            <span class="keyword">return</span> acc.<span class="title function_">concat</span>(cur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> acc.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(cur, depth-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? acc.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(cur, depth-<span class="number">1</span>)) : acc.<span class="title function_">concat</span>(cur);</span><br><span class="line">    &#125; ,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, [<span class="number">4</span>,<span class="number">5</span>], [[<span class="number">6</span>]], [[<span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]]], <span class="number">10</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr, <span class="number">2</span>))   <span class="comment">// [1, 2, 3, 4, 5, 6, 7, [8, 9], 10]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式3-手写递归"><a href="#方式3：-手写递归" class="headerlink" title="方式3： 手写递归"></a>方式3： 手写递归</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(...<span class="title function_">flatten</span>(item))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, [<span class="number">4</span>,<span class="number">5</span>], [[<span class="number">6</span>]], [[<span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]]], <span class="number">10</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr))   <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
        <tag>和我一起做总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | 数组去重（13种）</title>
    <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<h3 id="灵魂拷问数组去重的方式你知道多少呢"><a href="#灵魂拷问：数组去重的方式你知道多少呢？" class="headerlink" title="灵魂拷问：数组去重的方式你知道多少呢？"></a>灵魂拷问：数组去重的方式你知道多少呢？</h3><h4 id="方式1遍历-indexof"><a href="#方式1：遍历-indexOf" class="headerlink" title="方式1：遍历 + indexOf"></a>方式1：遍历 + <code>indexOf</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2-遍历-findindex"><a href="#方式2：-遍历-findIndex" class="headerlink" title="方式2： 遍历 + findIndex"></a>方式2： 遍历 + <code>findIndex</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="title function_">findIndex</span>(<span class="function"><span class="params">i</span> =&gt;</span> i === item) === -<span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式3-遍历-find"><a href="#方式3：-遍历-find" class="headerlink" title="方式3： 遍历 + find"></a>方式3： 遍历 + <code>find</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="title function_">find</span>(<span class="function"><span class="params">i</span> =&gt;</span> i === item)) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式4-遍历-includes"><a href="#方式4：-遍历-includes" class="headerlink" title="方式4： 遍历 + includes"></a>方式4： 遍历 + <code>includes</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="title function_">includes</span>(item)) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式5foreach-重复方式1234"><a href="#方式5：forEach-重复方式1234" class="headerlink" title="方式5：forEach + 重复方式1234"></a>方式5：<code>forEach</code> + 重复方式1234</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">	arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他的换汤不换药，不写了</span></span><br></pre></td></tr></table></figure>

<h4 id="方式6reduce-concat或者扩展运算符合并数组重复方式1234"><a href="#方式6：reduce-concat或者扩展运算符合并数组-重复方式1234" class="headerlink" title="方式6：reduce + concat或者扩展运算符合并数组+重复方式1234"></a>方式6：<code>reduce</code> + <code>concat</code>或者扩展运算符合并数组+重复方式1234</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.<span class="title function_">indexOf</span>(cur) === -<span class="number">1</span>) &#123;</span><br><span class="line">            acc  = acc.<span class="title function_">concat</span>(cur);</span><br><span class="line">            <span class="comment">// 或者是</span></span><br><span class="line">            <span class="comment">// acc = [...acc, ...cur];</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他的换汤不换药，不写了</span></span><br></pre></td></tr></table></figure>

<h4 id="方式7-filter-indexof"><a href="#方式7：-filter-indexOf" class="headerlink" title="方式7： filter + indexOf"></a>方式7： <code>filter</code> + <code>indexOf</code></h4><p>利用<code>indexOf</code>是返回第一个搜索到的<code>index</code>，来过滤非第一个搜索到的<code>index</code>的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr.<span class="title function_">indexOf</span>(item) === index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式8-set-扩展运算符"><a href="#方式8：-Set-扩展运算符" class="headerlink" title="方式8： Set + 扩展运算符"></a>方式8： <code>Set</code> + 扩展运算符</h4><p>最快的方式，一行搞定</p>
<p>利用：</p>
<ol>
<li>Set()中没有重复元素</li>
<li>扩展运算符：任何定义了遍历器接口的对象，都可以用扩展运算符转为数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式9-map-keys-扩展运算符"><a href="#方式9：-Map-keys-扩展运算符" class="headerlink" title="方式9： Map  + keys() + 扩展运算符"></a>方式9： <code>Map</code>  + <code>keys()</code> + 扩展运算符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.<span class="title function_">has</span>(item)) &#123;</span><br><span class="line">            m.<span class="title function_">set</span>(item, <span class="literal">true</span>);     <span class="comment">// 值随便指定无所谓</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [...m.<span class="title function_">keys</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式10嵌套循环-splice去重"><a href="#方式10：嵌套循环-splice去重" class="headerlink" title="方式10：嵌套循环 + splice去重"></a>方式10：嵌套循环 + <code>splice</code>去重</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j&lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] === arr[i]) &#123;</span><br><span class="line">                arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式11sort-嵌套循环"><a href="#方式11：sort-嵌套循环" class="headerlink" title="方式11：sort() + 嵌套循环"></a>方式11：<code>sort()</code> + 嵌套循环</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> res = [arr[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] !== arr[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式12hasownproperty"><a href="#方式12：hasOwnProperty" class="headerlink" title="方式12：hasOwnProperty"></a>方式12：<code>hasOwnProperty</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item, index, arr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="title function_">hasOwnProperty</span>(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (m[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式13-递归去重"><a href="#方式13：-递归去重" class="headerlink" title="方式13： 递归去重"></a>方式13： 递归去重</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a- b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] === arr[index-<span class="number">1</span>]) &#123;</span><br><span class="line">                arr.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">bar</span>(index-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bar</span>(arr.<span class="property">length</span>-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(arr));   <span class="comment">// [1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
        <tag>和我一起做总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | 类数组转数组（3种）</title>
    <url>/2022/07/16/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="灵魂拷问类数组转数组的方式你知道多少呢"><a href="#灵魂拷问：类数组转数组的方式你知道多少呢？" class="headerlink" title="灵魂拷问：类数组转数组的方式你知道多少呢？"></a>灵魂拷问：类数组转数组的方式你知道多少呢？</h3><h4 id="方式1-arrayprototypeslice"><a href="#方式1：-Array-prototype-slice" class="headerlink" title="方式1： Array.prototype.slice()"></a>方式1： Array.prototype.slice()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arrayLike2Array</span>(<span class="params">arrayLike</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;Kate&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;Jenny&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title function_">arrayLike2Array</span>(arrayLike);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);   <span class="comment">// [&#x27;Katrina&#x27;, &#x27;Jack&#x27;, &#x27;Kate&#x27;, &#x27;Jenny&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2arrayfrom"><a href="#方式2：Array-from" class="headerlink" title="方式2：Array.from()"></a>方式2：Array.from()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arrayLike2Array</span>(<span class="params">arrayLike</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...arrayLike];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;Kate&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;Jenny&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title function_">arrayLike2Array</span>(arrayLike);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);   <span class="comment">// [&#x27;Katrina&#x27;, &#x27;Jack&#x27;, &#x27;Kate&#x27;, &#x27;Jenny&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="方式3-拓展运算符"><a href="#方式3：-拓展运算符" class="headerlink" title="方式3： 拓展运算符"></a>方式3： 拓展运算符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arrayLike2Array</span>(<span class="params">arrayLike</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...arrayLike];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> [...<span class="variable language_">arguments</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = <span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);   <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
        <tag>和我一起做总结</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理 | 链表数组互转</title>
    <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[<h3 id="链表转数组"><a href="#链表转数组" class="headerlink" title="链表转数组"></a>链表转数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeList2Array</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array = [];</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        array.<span class="title function_">push</span>(head.<span class="property">val</span>);</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// 设置一个链表   1-&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line"><span class="keyword">const</span> head = &#123; <span class="attr">val</span>: <span class="number">1</span>, <span class="attr">next</span>: &#123; <span class="attr">val</span>: <span class="number">2</span>, <span class="attr">next</span>: &#123; <span class="attr">val</span>: <span class="number">3</span>, <span class="attr">next</span>: &#123; <span class="attr">val</span>: <span class="number">4</span>, <span class="attr">next</span>: &#123; <span class="attr">val</span>: <span class="number">5</span>, <span class="attr">next</span>: <span class="literal">null</span>&#125;&#125;&#125;&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title function_">nodeList2Array</span>(head);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);  <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="数组转链表"><a href="#数组转链表" class="headerlink" title="数组转链表"></a>数组转链表</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NodeList</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val ? val : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next ? next : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">array2NodeList</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!array.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> dum = <span class="keyword">new</span> <span class="title class_">NodeList</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">let</span> newHead = dum;</span><br><span class="line">    <span class="keyword">while</span> (array.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = array.<span class="title function_">shift</span>();</span><br><span class="line">        newHead.<span class="property">next</span> = &#123;</span><br><span class="line">            <span class="attr">val</span>: node,</span><br><span class="line">            <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        newHead = newHead.<span class="property">next</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> dum.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> array = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];</span><br><span class="line"><span class="keyword">const</span> head = <span class="title function_">array2NodeList</span>(array);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(head);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
        <category>数据处理</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据处理</tag>
        <tag>和我一起做总结</tag>
      </tags>
  </entry>
  <entry>
    <title>函数 | callee属性和caller属性</title>
    <url>/2022/07/09/JavaScript/%E5%87%BD%E6%95%B0_callee%E5%B1%9E%E6%80%A7%E5%92%8Ccaller%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ul>
<li><p>arguments对象是一个类数组对象，包含调用函数时传入的所有参数，可以使用中括号语法访问其中的元素</p>
</li>
<li><p>arguments可以用length属性来检查传入参数的个数，主要length由实参决定，而不是形参（这里需要区分的是，函数也有length属性，函数的length表示函数需要传入形参的个数）</p>
</li>
<li><p>arguments的值始终会与对应的命名参数同步</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处arguments如下</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	arguments = &#123;</span></span><br><span class="line"><span class="comment">    		0: 1,</span></span><br><span class="line"><span class="comment">    		1: 2,</span></span><br><span class="line"><span class="comment">    		length: 2</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 此处arguments如下</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	arguments = &#123;</span></span><br><span class="line"><span class="comment">    		0: 10,</span></span><br><span class="line"><span class="comment">    		1: 2,</span></span><br><span class="line"><span class="comment">    		length: 2</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// 所以打印结果为10+2 = 12</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="callee属性arguments的属性"><a href="#callee属性：arguments的属性" class="headerlink" title="callee属性：arguments的属性"></a>callee属性：arguments的属性</h2><blockquote>
<p>arguments的callee属性，是一个指向arguments对象所在函数的指针</p>
</blockquote>
<img src="/2022/07/09/JavaScript/%E5%87%BD%E6%95%B0_callee%E5%B1%9E%E6%80%A7%E5%92%8Ccaller%E5%B1%9E%E6%80%A7/callee%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0.png" class title="callee指向函数">

<h3 id="callee作用让函数逻辑与函数名解耦"><a href="#callee作用：让函数逻辑与函数名解耦" class="headerlink" title="callee作用：让函数逻辑与函数名解耦"></a>callee作用：让函数逻辑与函数名解耦</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经典阶乘例子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="title function_">fractorial</span>(num - <span class="number">1</span>);   <span class="comment">// 这里需要递归factorial，说明这个函数和factorial是紧密耦合的，修改了函数名函数就会有问题</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用callee可以让函数逻辑与函数名解耦</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>);    <span class="comment">// 这样的话无论之后函数叫什么都没什么问题了</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小缺陷-严格模式下不能访问argumentscallee"><a href="#小缺陷：-严格模式下不能访问arguments-callee" class="headerlink" title="小缺陷： 严格模式下不能访问arguments.callee"></a>小缺陷： 严格模式下不能访问arguments.callee</h4><p>可以使用命名函数表达式进行优化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="title function_">f</span>(num - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="caller属性函数对象的属性"><a href="#caller属性：函数对象的属性" class="headerlink" title="caller属性：函数对象的属性"></a>caller属性：函数对象的属性</h2><blockquote>
<p>caller属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则是null</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(inner.<span class="property">caller</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>();   <span class="comment">// function outer() &#123; inner()&#125;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/07/09/JavaScript/%E5%87%BD%E6%95%B0_callee%E5%B1%9E%E6%80%A7%E5%92%8Ccaller%E5%B1%9E%E6%80%A7/caller%E5%B1%9E%E6%80%A7%E6%8C%87%E5%90%91.png" class title="caller属性指向">

<p>如果要降低耦合度，可以使用<code>arguments.callee</code>属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">caller</span>);   <span class="comment">// arguments.callee指向inner函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在严格模式下访问<code>arguments.callee</code>会报错，在ES5中也定义了<code>arguments.caller</code>，严格模式下访问会报错，非严格模式下为<code>undefined</code>，在严格模式下，不能给函数的<code>caller</code>属性赋值</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>小众知识点</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript函数</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域 | 执行上下文与作用域</title>
    <url>/2022/07/10/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F_%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote>
<p> <strong>执行上下文</strong>：当前代码的执行环境，变量或者函数的上下文决定了它们可以访问哪些数据，以及它们的行为</p>
</blockquote>
<p>执行上下文可以分为：</p>
<ul>
<li>全局执行上下文：只有一个，程序首次运行时创建，它会在浏览器中创建一个全局对象（<code>window</code>对象），使<code>this</code>指向这个全局对象</li>
<li>函数执行上下文：函数被调用时创建，每次调用都会为该函数创建一个新的执行上下文</li>
<li>Eval 函数执行上下文：运行<code>eval</code>函数中的代码时创建的执行上下文，少用且不建议使用</li>
</ul>
<p>执行上下文会在其所有代码执行完毕后被销毁，包括定义在它上面的所有变量和函数</p>
<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><blockquote>
<p>执行上下文栈是一种拥有后进先出的数据解构，用于存储代码执行时创建的执行上下文</p>
</blockquote>
<p><strong>代码实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> anotherColor = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">swapColors</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">swapColors</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(color); <span class="comment">// red</span></span><br></pre></td></tr></table></figure>

<p>执行过程可以在 <code>devTool</code> 的 <code>call stack</code> 中看到，其中 <code>anonyomus</code> 为全局上下文栈；其余为函数上下文栈</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d205c65fa2457ba02efd5b5871cc31~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>图解： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d8c1d1571f4a69a57cb37939073a75~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>执行过程：</p>
<ol>
<li>首先创建了<code>全局执行上下文</code>，压入执行栈，其中的可执行代码开始执行。</li>
<li>然后调用 <code>changeColor</code> 函数，JS引擎停止执行全局执行上下文，激活函数 <code>changeColor</code> 创建它自己的执行上下文，且把该函数上下文放入执行上下文栈顶，其中的可执行代码开始执行。</li>
<li><code>changeColor</code> 调用了 <code>swapColors</code> 函数，此时暂停了 <code>changeColor</code> 的执行上下文，创建了 <code>swapColors</code> 函数的新执行上下文，且把该函数执行上下文放入执行上下文栈顶。</li>
<li>当 <code>swapColors</code> 函数执行完后，其执行上下文从栈顶出栈，回到了 <code>changeColor</code> 执行上下文中继续执行。</li>
<li><code>changeColor</code> 没有可执行代码，也没有再遇到其他执行上下文了，将其执行上下文从栈顶出栈，回到了 <code>全局执行上下文</code> 中继续执行。</li>
<li>一旦所有代码执行完毕，JS引擎将从当前栈中移除 <code>全局执行上下文</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</span><br></pre></td></tr></table></figure>

<h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>每个执行上下文都有一个关联的<strong>变量对象（variable object）</strong>，这个执行上下文中定义的所有变量和函数都存在于这个变量上</p>
<p>如果执行上下文是函数，则其<strong>活动对象（activation object）</strong>作为变量对象，活动对象最初只有一个定义变量<code>arguments</code></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><blockquote>
<p>作用域由函数或代码块创建，变量只能在定义它的函数或代码块内使用，超出范围则不可访问，作用域决定了代码区块中变量和其他资源的可见性</p>
</blockquote>
<p>作用域可分为：</p>
<ul>
<li>全局作用域：</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><blockquote>
<p>在代码中任何地方都能访问到的对象拥有全局作用域</p>
</blockquote>
<ul>
<li>最外层函数 和 在最外层函数外面 定义的变量拥有全局作用域</li>
<li>所有未定义直接复制的变量自动声明为拥有全局作用域</li>
<li>所有 window 对象的属性拥有全局作用域</li>
</ul>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><blockquote>
<p>函数作用域顾名思义就是指声明在函数内部的变量，函数作用域一般只在固定的代码片段内可以访问到</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Katrina&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">innerSay</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">innerSay</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayName</span>();   <span class="comment">// Katrina</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);  <span class="comment">// name is not defined</span></span><br><span class="line"><span class="title function_">innerSay</span>();   <span class="comment">// innerSay is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><blockquote>
<p>块级作用域可以通过let和const声明，所声明的变量在指定块级作用域外无法被访问，会将变量的作用域限制在当前代码块中</p>
</blockquote>
<p>块级作用域的特点详见：<a href="https://superkatrina123.github.io/2022/07/05/JavaScript/%E5%8F%98%E9%87%8F_var%20let%20const%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8/">变量 | var let const区别及应用</a></p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><blockquote>
<p>词法作用域是定义表达式并能被访问到的区间，即一个声明的词法作用域就是它被<strong>定义</strong>时所在的作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局作用域变量</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Katrina&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数体内调用name变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayName</span>());   <span class="comment">// Katrina</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	name的词法作用域是全局作用域，因为name是在全局环境定义的，词法作用域正是取决于变量定义时的作用域而不是调用时的作用域</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote>
<p>在当前作用域没有找到所需变量，就去父级寻找，父级没有找到再一层层向上找，直到全局作用域还没找到就放弃，这种一层层的关系就是作用域链</p>
</blockquote>
<h3 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h3><p>JavaScript 属于解释型语言，JavaScript 的执行分为：<strong>解释</strong>和<strong>执行</strong>两个阶段,这两个阶段所做的事并不一样：</p>
<h4 id="解释阶段"><a href="#解释阶段：" class="headerlink" title="解释阶段："></a>解释阶段：</h4><ul>
<li>词法分析</li>
<li>语法分析</li>
<li>作用域规则确定</li>
</ul>
<h4 id="执行阶段"><a href="#执行阶段：" class="headerlink" title="执行阶段："></a>执行阶段：</h4><ul>
<li>创建执行上下文</li>
<li>执行函数代码</li>
<li>垃圾回收</li>
</ul>
<p>JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的</p>
<p>执行上下文最明显的就是 this 的指向是执行时确定的，而作用域访问的变量是编写代码的结构确定的</p>
<p>作用域和执行上下文之间最大的区别是：<br><strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变</strong></p>
<p>一个作用域下可能包含若干个上下文环境，有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）</p>
<p><strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值</strong> </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6945240902625394718">你真的了解执行上下文吗？</a></p>
<p><a href="https://juejin.cn/post/6874829017006997511#heading-1">掌握JavaScript面试：什么是闭包？</a></p>
<p><a href="https://blog.fundebug.com/2019/03/15/understand-javascript-scope/">深入理解 JavaScript 作用域和作用域链</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>作用域</tag>
        <tag>和我一起读红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title>函数 | call apply bind区别（含手写）</title>
    <url>/2022/07/09/JavaScript/%E5%87%BD%E6%95%B0_call%20apply%20bind%E5%8C%BA%E5%88%AB%EF%BC%88%E5%90%AB%E6%89%8B%E5%86%99%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>call apply bind都可用于修改this的指向</p>
</blockquote>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.<span class="title function_">call</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>thisArg</code>：在function函数运行时使用的this值，在非严格模式下，如果指定为<code>null</code>或者<code>undefined</code>，<code>this</code>为<code>window</code></li>
<li><code>arg1 arg2 arg3</code>：指定的参数列表</li>
</ul>
<p><strong>返回值</strong></p>
<p>使用<code>thisArg</code>和参数调用该函数的返回值，若该方法没有返回值，则返回<code>undefined</code></p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.<span class="title function_">apply</span>(thisArg, argsArray)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>thisArg</code>：在function函数运行时使用的this值，在非严格模式下，如果指定为<code>null</code>或者<code>undefined</code>，<code>this</code>为<code>window</code></li>
<li><code>argsArray</code>：一个数组或者是类数组对象，其中数组元素将作为单独的参数传给<code>function</code>函数，如果该参数的值为<code>null</code>或者<code>undefined</code>，则表示不需要传入任何参数</li>
</ul>
<p><strong>返回值</strong></p>
<p>使用<code>thisArg</code>和参数调用该函数的返回值，若该方法没有返回值，则返回<code>undefined</code></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.<span class="title function_">bind</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>thisArg</code>：在function函数运行时使用的this值，在非严格模式下，如果指定为<code>null</code>或者<code>undefined</code>，<code>this</code>为<code>window</code></li>
<li><code>arg1 arg2 arg3</code>：指定的参数列表</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回一个绑定了指定的<code>this</code>值和初始函数的原函数的拷贝</p>
<h2 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h2><ul>
<li><p><code>call</code> 和<code>apply</code>： 传入形式不同，<code>call</code>第二个参数开始都是<code>function</code>所需要的参数，而<code>apply</code>则把<code>function</code>所需的参数以数组的形式作为第二个参数传入</p>
</li>
<li><p><code>call</code> <code>apply</code> 和 <code>bind</code>：call 和 apply 是立即执行，而bind的方法是创建一个新的函数，这个函数是原函数的拷贝</p>
</li>
</ul>
<h2 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h2><h3 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context,...args</span>) &#123;   <span class="comment">// ...rest： ...剩余参数数组名称</span></span><br><span class="line">    <span class="comment">// 1. 判断传入context是否为空</span></span><br><span class="line"> 	context = context ? context : <span class="variable language_">window</span>;</span><br><span class="line">    <span class="comment">// 2. 给context指定一个方法，指向this</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 3. 执行fn</span></span><br><span class="line">    <span class="keyword">let</span> res = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="comment">// 4. 执行完毕后删除自定义的方法</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="comment">// 5. 返回调用函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kate&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params">p1, p2, p3</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, they are my friends, <span class="subst">$&#123;p1&#125;</span>, <span class="subst">$&#123;p2&#125;</span>, <span class="subst">$&#123;p3&#125;</span>.`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="property">sayName</span>.<span class="title function_">myCall</span>(person2, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);  <span class="comment">// Hello, Katrina, they are my friends, Jack, Jenny, John.</span></span><br></pre></td></tr></table></figure>

<h3 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context, args=[]</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断传入context是否为空</span></span><br><span class="line"> 	context = context ? context : <span class="variable language_">window</span>;</span><br><span class="line">    <span class="comment">// 2. 给context指定一个方法，指向this</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 3. 执行fn</span></span><br><span class="line">    <span class="keyword">let</span> res = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="comment">// 4. 执行完毕后删除自定义的方法</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="comment">// 5. 返回调用函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kate&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params">p1, p2, p3</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, they are my friends, <span class="subst">$&#123;p1&#125;</span>, <span class="subst">$&#123;p2&#125;</span>, <span class="subst">$&#123;p3&#125;</span>.`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="property">sayName</span>.<span class="title function_">myApply</span>(person2, [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;John&#x27;</span>]);  <span class="comment">// Hello, Katrina, they are my friends, Jack, Jenny, John.</span></span><br></pre></td></tr></table></figure>

<h3 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断传入context是否为空</span></span><br><span class="line"> 	context = context ? context : <span class="variable language_">window</span>;</span><br><span class="line">    <span class="comment">// 2. 保存this</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 返回函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">        <span class="comment">// 4. 柯里化函数</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="title function_">myApply</span>(context, [...args, ...newArgs]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kate&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params">p1, p2, p3</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, they are my friends, <span class="subst">$&#123;p1&#125;</span>, <span class="subst">$&#123;p2&#125;</span>, <span class="subst">$&#123;p3&#125;</span>.`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = person.<span class="property">sayName</span>.<span class="title function_">myBind</span>(person2)(<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);  <span class="comment">// Hello, Katrina, they are my friends, Jack, Jenny, John.</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>常见方法对比</category>
      </categories>
      <tags>
        <tag>常见方法对比</tag>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>this指向</tag>
      </tags>
  </entry>
  <entry>
    <title>函数 | new.target属性</title>
    <url>/2022/07/09/JavaScript/%E5%87%BD%E6%95%B0_new.targer%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>new.target属性是ES6中新增的函数属性，new.target用于<strong>检测函数是否使用new关键字调用</strong></p>
</blockquote>
<p>如果函数是正常调用的，new.target的值为undefined；如果是使用new关键字调用的，则new.target将引用被调用的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;King must be instantiated unsing &quot;new&quot;!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;King instantiated unsing &quot;new&quot;!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>();  <span class="comment">// King instantiated unsing &quot;new&quot;!</span></span><br><span class="line"><span class="title class_">King</span>();  <span class="comment">// Error: King instantiated unsing &quot;new&quot;!</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
        <category>小众知识点</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript函数</tag>
      </tags>
  </entry>
  <entry>
    <title>函数 | this指向</title>
    <url>/2022/07/09/JavaScript/%E5%87%BD%E6%95%B0_this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>thist指向问题是非常重要的，主要有以下几种情况：</p>
<table>
<thead>
<tr>
<th align="center">函数所处位置</th>
<th align="center">this指向</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全局函数且没有直接调用的对象</td>
<td align="center">非严格模式下，<code>this</code>指向全局<code>window</code>或者<code>global</code><br>严格模式下，<code>this</code>指向<code>undefined</code></td>
</tr>
<tr>
<td align="center">属性方法</td>
<td align="center">this指向调用这个方法的对象</td>
</tr>
<tr>
<td align="center">构造函数</td>
<td align="center"><code>this</code>指向实例对象</td>
</tr>
<tr>
<td align="center">属性方法</td>
<td align="center"><code>this</code>指向调用这个方法的对象</td>
</tr>
<tr>
<td align="center">定时器</td>
<td align="center"><code>this</code>指向<code>window</code></td>
</tr>
<tr>
<td align="center">事件函数</td>
<td align="center"><code>this</code>指向绑定这个事件的对象</td>
</tr>
<tr>
<td align="center">call apply bind</td>
<td align="center"><code>this</code>指向第一个参数，若第一个参数是<code>null</code>，在非严格模式下，<code>this</code>指向<code>window</code></td>
</tr>
<tr>
<td align="center">箭头函数</td>
<td align="center"><code>this</code>指向定义箭头函数的上下文</td>
</tr>
</tbody></table>
<h3 id="全局函数window"><a href="#全局函数：window" class="headerlink" title="全局函数：window"></a>全局函数：window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;全局函数this&#x27;</span>, <span class="variable language_">this</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 全局函数this window</span></span><br></pre></td></tr></table></figure>

<h3 id="属性方法调用方法的对象"><a href="#属性方法：调用方法的对象" class="headerlink" title="属性方法：调用方法的对象"></a>属性方法：调用方法的对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;对象中的this&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayHello</span>();   <span class="comment">// 对象中的this &#123;name: &#x27;Katrina&#x27;, sayHello: f&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数实例对象"><a href="#构造函数：实例对象" class="headerlink" title="构造函数：实例对象"></a>构造函数：实例对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;构造函数中的this&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>);  <span class="comment">// Person &#123;name: &#x27;Katrina&#x27;, age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="定时器-window"><a href="#定时器：-window" class="headerlink" title="定时器： window"></a>定时器： window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器的this&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    sayHello,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayHello</span>();   <span class="comment">// 定时器的this Window</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：<code>setTimeout()</code>等同于<code>window.setTimeout()</code></p>
</blockquote>
<p>若要让定时器的this指向person对象，可以把定期器的函数改为箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器的this&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    sayHello,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayHello</span>();   <span class="comment">// 定时器的this &#123;name: &#x27;Katrina&#x27;, sayHello: f&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件函数绑定事件的对象"><a href="#事件函数：绑定事件的对象" class="headerlink" title="事件函数：绑定事件的对象"></a>事件函数：绑定事件的对象</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>:pink;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;box&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;box&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件绑定函数的this&#x27;</span>, <span class="variable language_">this</span>);    <span class="comment">//  事件绑定函数的this &lt;div class = &#x27;box&#x27;&gt;&lt;/div&gt;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="call-apply-bind指定的第一个参数"><a href="#call-apply-bind：指定的第一个参数" class="headerlink" title="call apply bind：指定的第一个参数"></a>call apply bind：指定的第一个参数</h3><p>补课：<a href="https://superkatrina123.github.io/2022/07/09/JavaScript/%E5%87%BD%E6%95%B0_call%20apply%20bind%E5%8C%BA%E5%88%AB%EF%BC%88%E5%90%AB%E6%89%8B%E5%86%99%EF%BC%89/">函数 | call apply bind区别（含手写）</a></p>
<h3 id="箭头函数-定义箭头函数时的上下文"><a href="#箭头函数：-定义箭头函数时的上下文" class="headerlink" title="箭头函数： 定义箭头函数时的上下文"></a>箭头函数： 定义箭头函数时的上下文</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sayColor</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);  <span class="comment">// 箭头函数的this引用定义时的上下文，此时是window</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">sayColor</span>();   <span class="comment">// red</span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line">o.<span class="title function_">sayColor</span>();  <span class="comment">// res</span></span><br></pre></td></tr></table></figure>

<p>在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象，此时将回调函数写成箭头函数就可以解决问题</p>
<p>这是因为箭头函数中的this 会保留定义该函数时的上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">King</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">	<span class="comment">// this 引用King 的实例</span></span><br><span class="line">	setTimeout(() =&gt; console.log(<span class="built_in">this</span>.royaltyName), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="title function_">Queen</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Elizabeth&#x27;</span>;</span><br><span class="line">	<span class="comment">// this 引用window 对象</span></span><br><span class="line">	setTimeout(function() &#123; console.log(<span class="built_in">this</span>.royaltyName); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// Henry</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Queen</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript函数</tag>
        <tag>this指向</tag>
      </tags>
  </entry>
  <entry>
    <title>函数 | 函数声明与函数表达式</title>
    <url>/2022/07/05/JavaScript/%E5%87%BD%E6%95%B0_%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数通常可以以（1）<strong>函数声明</strong>；（2）<strong>函数表达式</strong> ；（3）<strong>Function构造函数</strong>【不推荐】 三种方式进行定义。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>（一般来说，函数声明最后没有分号，因为在代码块的结尾不需要加分号）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> 	reutrn num1 + num2;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>（函数表达式实际上是赋值的形式，建议加上分号）</p>
<blockquote>
<p>函数表达式就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量functionName，这样创建的函数叫做匿名函数（未赋值给其他变量的匿名函数的name属性是空字符串）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数表达式有几种不同的形式：</p>
<ul>
<li><p>形式一（最常见）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">	<span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>形式二：一个函数把另一个函数当作值返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">		<span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> value1 + value2;</span><br><span class="line">	&#125;;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>createComparisonFunction()函数返回一个匿名函数，这个匿名函数可以被赋值给一个变量或者直接调用，<strong>任何时候，只要函数被当作值来使用，它就是一个函数表达式</strong></p>
</blockquote>
</li>
</ul>
<h2 id="函数声明-和-函数表达式的区别"><a href="#函数声明-和-函数表达式的区别" class="headerlink" title="函数声明 和 函数表达式的区别"></a>函数声明 和 函数表达式的区别</h2><p><strong>两者最主要的区别是：函数声明提前</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eg1:函数声明提前</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> 	reutrn num1 + num2;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//eg2:函数表达式不提前 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));   <span class="comment">// Uncaught ReferenceError: sum is not defined</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这个报错并不是let引起的，将let改为var也会报错，即使var也会声明提前，但console.log的时候，sum为undefined，所以会引起报错：Uncaught TypeError: sum is not a function</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>红宝书解释如下： JavaScript引擎在任何代码执行之前，会先读取函数声明，并在执行器上下文中生成函数定义，而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p>
</blockquote>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eg1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>));           <span class="comment">// 打印结果为13，函数声明提前+函数覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> num+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> num+<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript函数</tag>
      </tags>
  </entry>
  <entry>
    <title>函数 | 深刻理解函数名是指向函数的指针</title>
    <url>/2022/07/05/JavaScript/%E5%87%BD%E6%95%B0_%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E5%90%8D%E6%98%AF%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ul>
<li><p>每一个函数都是Function类型的实例，Function有属性和方法</p>
</li>
<li><p>函数是对象，函数名就是指向函数对象的指针</p>
</li>
<li><p>所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息</p>
<ul>
<li>情况一：正常情况 &#x3D;&gt; 标识符，或者字符串化的变量名</li>
<li>情况二：函数没有名称 &#x3D;&gt; 空字符串</li>
<li>情况三：构造函数创建 &#x3D;&gt; anonymous</li>
<li>情况四：如果函数是set get 函数或者使用bind实例化 &#x3D;&gt; 前缀 + 函数名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>);                 <span class="comment">// foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>);                 <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">name</span>);                 <span class="comment">// baz</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="function">() =&gt;</span> &#123;&#125;).<span class="property">name</span>);          <span class="comment">// (空字符串)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span>);    <span class="comment">// anonymous</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>);      <span class="comment">// bind foo</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数名是函数指针"><a href="#函数名是函数指针" class="headerlink" title="函数名是函数指针"></a>函数名是函数指针</h2><blockquote>
<p>注意：使用不带括号的函数名会访问函数指针，而不会执行函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));   <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;   <span class="comment">// #1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>));   <span class="comment">//  20</span></span><br><span class="line"></span><br><span class="line">sum = <span class="literal">null</span>;  <span class="comment">// #2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>));   <span class="comment">//  20</span></span><br></pre></td></tr></table></figure>

<p>以上过程可抽象为下图：</p>
<img src="/2022/07/05/JavaScript/%E5%87%BD%E6%95%B0_%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E5%90%8D%E6%98%AF%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%881.png" class title="指针1">

<p>Step1：将sum赋值给anotherSum的时候其实是相当于把指针赋值给anotherSum，于是anotherSum也指向求和函数</p>
<p>Step2：将sum的指针指向null，这并没有改变anotherSum的指针指向，所以并不会影响anotherSum执行</p>
<h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><blockquote>
<p>重载函数：允许在同一范围中声明几个功能类似的同名函数，但是同名函数的签名不同，比如形参类型不同，数量不同等。</p>
</blockquote>
<p><strong>如果在JS中定义两个同名函数会发生什么情况？</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> num += <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> num+=<span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">100</span>)); <span class="comment">// 300</span></span><br></pre></td></tr></table></figure>

<p>从打印结果来看，前一个add被后一个add给覆盖了</p>
<p>其实理解了”函数名是函数指针“之后，很容易能够抽象出下图：</p>
<img src="/2022/07/05/JavaScript/%E5%87%BD%E6%95%B0_%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E5%90%8D%E6%98%AF%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%882.png" class title="指针2">

<p>当然，函数表达式也是一样的情况，这里不再赘述。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript函数</tag>
        <tag>和我一起读红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型 | 深刻理解所有函数的参数都是按值传递的</title>
    <url>/2022/07/05/JavaScript/%E5%87%BD%E6%95%B0_%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84/</url>
    <content><![CDATA[<p>这部分有一句很重要但是比较难理解的话：</p>
<blockquote>
<p><strong>ECMAScript 中所有函数的参数都是按值传递的</strong></p>
</blockquote>
<p>一看很懵，红宝书紧接着就做出了解释：</p>
<blockquote>
<p> 这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样</p>
<p>如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样</p>
</blockquote>
<p>大概理解了，但是还是云里雾里，那么我们首先要清楚，按值传递和按引用传递参数会造成什么样的结果？</p>
<blockquote>
<p>按值传递参数：值会被复制到一个局部变量（可以理解为<code>arguments</code>的一个槽位【补充：<code>agruments</code>是一个类数组对象，包含调用函数时传入的所有参数】）</p>
<p>按引用传递参数：在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部（在ECMAScript中显得不科学）</p>
</blockquote>
<ul>
<li>看一下这个例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">addTen</span>(count);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 10  没有变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>原始值的例子很容易理解，<code>num</code>是一个局部变量，在调用时，<code>count</code>作为参数传入，被复制到<code>num</code>一边在<code>addTen</code>内部使用</p>
<p>在函数内部，参数<code>num</code>的值被加上了10，但这不会影响函数外部的原始变量<code>count</code>，参数<code>num</code> 和变量<code>count </code>互不干扰，如果<code>num </code>是按引用传递的，那么<code>count</code> 的值也会被修改为20</p>
<ul>
<li>再看一下一个引用数据类型的例子：（比较不容易理解）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">	obj.<span class="property">name</span> = <span class="string">&#x27;Jenny&#x27;</span>;    <span class="comment">// 修改传入obj的name属性的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setName</span>(person);   <span class="comment">// 调用函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);  <span class="comment">// &#123;name: &#x27;Jenny&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这次创建了一个对象并保存在<code>person</code>中，然后这个对象被传给<code>setName</code>方法，并且复制给<code>obj</code></p>
<p>在函数内部，<code>obj</code>和<code>person</code>是指向同一个对象的，这样就会导致，即使对象是按值传进函数的，<code>obj</code>也会通过引用访问对象，这样的话，当函数内部修改了<code>obj</code>的<code>name</code>属性的值的时候，函数外部的对象也会反映这个变化，因为，<code>obj</code>指向的对象保存在全局作用域的堆内存上</p>
<img src="/2022/07/05/JavaScript/%E5%87%BD%E6%95%B0_%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84/%E4%B8%BE%E4%BE%8B1.png" class title="举例1">

<p>上面的过程会给人一种错觉：你在函数局部作用域中修改对象而导致反映到全局，不就意味着参数是按引用传递的吗？（一开始我也这样以为的！！！）</p>
<p>那么请看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">	obj.<span class="property">name</span> = <span class="string">&#x27;Jenny&#x27;</span>;    </span><br><span class="line">    obj = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setName</span>(person);   <span class="comment">// 调用函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);  <span class="comment">// &#123;name: &#x27;Jenny&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个例子比上面的例子就多了一行，也就是在函数内部将obj重新定义为了一个有着不同name的新对象</p>
<p>分析整个过程：</p>
<ul>
<li><p>创建了一个对象并保存在<code>person</code>中，然后这个对象被传给<code>setName</code>方法，并且复制给<code>obj</code></p>
</li>
<li><p>在函数内部内部修改了<code>obj</code>的<code>name</code>属性的值，并且又作妖地把<code>obj</code>设置为<code>name</code>为<code>&#39;Jack&#39;</code>的一个新对象</p>
</li>
<li><p>但是，当我们访问<code>person.name</code>的时候，打印的结果是<code>Jenny</code>而不是<code>Jack</code></p>
</li>
<li><p>这表明函数中参数的值改变之后，原始的引用仍然没变，当<code>obj </code>在函数内部被重写时，它变成了一个指向本地对象的指针，而那个本地对象在函数执行结束时就被销毁了</p>
</li>
</ul>
<img src="/2022/07/05/JavaScript/%E5%87%BD%E6%95%B0_%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84/%E4%B8%BE%E4%BE%8B2.png" class title="举例2">











]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起读红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title>函数 | 闭包</title>
    <url>/2022/07/10/JavaScript/%E5%87%BD%E6%95%B0_%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p><strong>闭包</strong>指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj1, obj2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> val1 = obj1[propertyName];</span><br><span class="line">        <span class="keyword">let</span> val2 = obj2[propertyName];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val1 &gt; val2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内部的匿名函数引用了外部函数的变量<code>propertyName</code>，在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量，这是因为内部函数的作用域链包含<code>createComparisonFunction()</code>函数的作用域</p>
<blockquote>
<p>变量对象（variable object）：在执行上下文创建阶段，都会有一个变量对象，变量对象中存储着形参，函数声明，变量声明等）</p>
<p>活动对象（activation object）：在执行上下文执行阶段，会把活动对象当作变量对象，用arguments对象和其他命名参数来初始化这个对象</p>
</blockquote>
<blockquote>
<p>回顾一下，在调用一个函数是会发生什么？</p>
<ol>
<li>创建一个执行上下文并创建一个作用域链（这个作用域链一直向外串起了所有包含函数的活动对象）</li>
<li>用arguments和其他命名参数来初始化这个函数的活动对象（外部函数的活动对象是内部函数作用域链上的第二个对象）</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">val1, val2</span>) &#123;</span><br><span class="line"> 	<span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val1 &gt; val2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义的<code>compare()</code>函数是在全局上下文中调用的。第一次调用<code>compare()</code>时，会为它创建一个包含<code>arguments</code>、<code>value1</code> 和<code>value2 </code>的活动对象，这个对象是其作用域链上的第一个对象。而全局上下文的变量对象则是<code>compare()</code>作用域链上的第二个对象，其中包含<code>this</code>、<code>result </code>和<code>compare</code></p>
<img src="/2022/07/10/JavaScript/%E5%87%BD%E6%95%B0_%E9%97%AD%E5%8C%85/%E7%A4%BA%E6%84%8F%E5%9B%BE1.png" class title="示意图1">

<p>从上图也可以直到，作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象</p>
<h3 id="闭包底层原理"><a href="#闭包底层原理" class="headerlink" title="闭包底层原理"></a>闭包底层原理</h3><blockquote>
<p>闭包只是定义嵌套函数时的外在表现，闭包的本质是包含函数的活动对象加长了其作用域链，通俗来说，在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中</p>
</blockquote>
<p>看这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj1, obj2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> val1 = obj1[propertyName];</span><br><span class="line">        <span class="keyword">let</span> val2 = obj2[propertyName];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val1 &gt; val2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compare = <span class="title function_">createComparisonFunction</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">compare</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在<code>createComparisonFunction()</code>返回匿名函数后，它的作用域链被初始化为包含<code>createComparisonFunction()</code>的活动对象和全局变量对象。这样，匿名函数就可以访问到<code>createComparisonFunction()</code>可以访问的所有变量</p>
<img src="/2022/07/10/JavaScript/%E5%87%BD%E6%95%B0_%E9%97%AD%E5%8C%85/%E7%A4%BA%E6%84%8F%E5%9B%BE2.png" class title="示意图2">

<h3 id="闭包的副作用"><a href="#闭包的副作用" class="headerlink" title="闭包的副作用"></a>闭包的副作用</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>上述闭包存在副作用，即<code>createComparisonFunction()</code>的活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用</p>
<p>在<code>createComparisonFunction()</code>执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁</p>
<blockquote>
<p>这就是内存泄漏</p>
</blockquote>
<h4 id="消除内存泄漏的方法"><a href="#消除内存泄漏的方法" class="headerlink" title="消除内存泄漏的方法"></a>消除内存泄漏的方法</h4><blockquote>
<p>把<code>compareNames</code>设置为等于<code>null </code>会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉</p>
<p>作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建比较函数</span></span><br><span class="line"><span class="keyword">let</span> compareNames = <span class="title function_">createComparisonFunction</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">compareNames</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// 解除对函数的引用，这样就可以释放内存了</span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>



<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/10/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F_%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/">作用域 | 执行上下文与作用域</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript函数</tag>
        <tag>和我一起读红宝书</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链 | 分解Function与Object的原型关系</title>
    <url>/2022/07/08/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E5%88%86%E8%A7%A3Function%E4%B8%8EObject%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ul>
<li>只要创建一个函数，就会按照特定的规则为这个函数创建一个<code>prototype</code>属性（指向原型对象）</li>
<li>默认情况下，所有的原型的对象自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数</li>
<li>原型对象上包含由构造函数的实例共享的属性和方法</li>
<li>在自定义构造函数时，原型对象默认只会获得<code>constructor</code>属性，其他的所有方法都继承自<code>Object</code></li>
<li>每次调用构造函数创建一个新实例，这个实例内部<code>[[prototype]]</code>指针就会被赋值为构造函数的原型对象，一般我们通过<code>__proto__</code>进行访问对象的原型</li>
<li>每个函数都是<code>Function</code>类型的实例，所有的函数都继承或间接继承<code>Function.prototype</code></li>
<li><code>Function</code>也有属性和方法，跟其他引用类型一样</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><img src="/2022/07/08/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E5%88%86%E8%A7%A3Function%E4%B8%8EObject%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB/Function%E5%92%8CObject.jpg" class title="Function和Object">

<h3 id="分解1构造函数-原型-实例之间的关系"><a href="#分解1：构造函数-原型-实例之间的关系" class="headerlink" title="分解1：构造函数 原型 实例之间的关系"></a>分解1：构造函数 原型 实例之间的关系</h3><img src="/2022/07/08/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E5%88%86%E8%A7%A3Function%E4%B8%8EObject%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB/%E5%88%86%E8%A7%A31.png" class title="分解1">

<p>这部分是最容易理解的，不再赘述，不理解的看这篇<a href="http://localhost:4000/2022/07/06/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B/">原型和原型链 | 理解原型和原型层级</a></p>
<h3 id="分解2-functionprototype的__proto__指向objectprototype"><a href="#分解2：-Function-prototype的-proto-指向Object-prototype" class="headerlink" title="分解2：  Function.prototype的__proto__指向Object.prototype"></a>分解2：  Function.prototype的<code>__proto__</code>指向Object.prototype</h3><img src="/2022/07/08/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E5%88%86%E8%A7%A3Function%E4%B8%8EObject%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB/%E5%88%86%E8%A7%A32.png" class title="分解2">

<p>因为<code>Function.prototype</code>本身是一个<code>function</code>类型（用<code>typeof</code>检测一下），<code>Function.prototype</code>本身是没有<code>valueof</code>属性的，需要从<code>Object.prototype</code>中继承</p>
<h3 id="分解3object的__proto__指向-functionprototype"><a href="#分解3：Object的-proto-指向-Function-prototype" class="headerlink" title="分解3：Object的__proto__指向 Function.prototype"></a>分解3：Object的<code>__proto__</code>指向 Function.prototype</h3><img src="/2022/07/08/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E5%88%86%E8%A7%A3Function%E4%B8%8EObject%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB/%E5%88%86%E8%A7%A33.png" class title="分解3">

<p><code>Object</code>是构造函数，在<strong>回顾</strong>中说道：**每个函数都是<code>Function</code>类型的实例，所有的函数都继承或间接继承<code>Function.prototype</code>**，所以<code>Object</code>作为构造函数的实例，<code>Object</code>的<code>__proto__</code>指向<code>Function.prototype</code>就容易理解了</p>
<p>同理，<code>Foo的</code><strong>proto</strong><code>指向 Function.prototype</code>也就不奇怪了（<code>Foo</code>是构造函数）</p>
<img src="/2022/07/08/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E5%88%86%E8%A7%A3Function%E4%B8%8EObject%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB/%E5%88%86%E8%A7%A33-2.png" class title="分解3-2">

<h3 id="分解4function的__proto__指向functionprototype"><a href="#分解4：Function的-proto-指向Function-prototype" class="headerlink" title="分解4：Function的__proto__指向Function.prototype"></a>分解4：Function的<code>__proto__</code>指向Function.prototype</h3><img src="/2022/07/08/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E5%88%86%E8%A7%A3Function%E4%B8%8EObject%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB/%E5%88%86%E8%A7%A34.png" class title="分解4">

<p>这里可以这样理解Function的<code>__proto__</code>指向Function.prototype是为了保证原型链的完整性，让<code>Function</code>能够获得<code>Object.prototype</code>上的方法</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://localhost:4000/2022/07/06/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B/">原型和原型链 | 理解原型和原型层级</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型和原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链 | 理解原型和原型层级</title>
    <url>/2022/07/06/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>原型和原型链是JavaScript中很重要的一块知识点，因为实例、构造函数、原型函数之前关系，有时候会被绕晕，遂计划进行一波总结~</p>
</blockquote>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ol>
<li><p>只要创建一个函数，就会按照特定的规则为这个函数创建一个<code>prototype</code>属性（指向原型对象）</p>
</li>
<li><p>默认情况下，所有的原型的对象自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数</p>
</li>
<li><p>原型对象上包含由构造函数的实例共享的属性和方法</p>
</li>
<li><p>在自定义构造函数时，原型对象默认只会获得<code>constructor</code>属性，其他的所有方法都继承自<code>Object</code></p>
</li>
<li><p>每次调用构造函数创建一个新实例，这个实例内部<code>[[prototype]]</code>指针就会被赋值为构造函数的原型对象，一般我们通过<code>__proto__</code>进行访问对象的原型</p>
</li>
</ol>
<h2 id="实例-构造函数-原型-三者之间的关系"><a href="#实例-构造函数-原型-三者之间的关系" class="headerlink" title="实例 构造函数 原型 三者之间的关系"></a>实例 构造函数 原型 三者之间的关系</h2><p>根据之前回顾的知识，若设<code>Person</code>为构造函数，<code>Person.prototype</code>即为原型对象，<code>p=new Person()</code>为构造函数创建的实例，不难可以手绘此图~</p>
<img src="/2022/07/06/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B/%E5%85%B3%E7%B3%BB%E5%9B%BE1.png" class title="关系图1">

<blockquote>
<p>根据上图，不难理解：<strong>实例与构造函数原型之间有直接的联系，而实例与构造函数之间没有直接联系。</strong></p>
</blockquote>
<h3 id="1-原型行为"><a href="#1-原型行为" class="headerlink" title="1. 原型行为"></a>1. 原型行为</h3><p>下面根据一个例子来说明三者之间的关系</p>
<h4 id="1构造函数和原型链循环引用"><a href="#（1）构造函数和原型链循环引用" class="headerlink" title="（1）构造函数和原型链循环引用"></a>（1）构造函数和原型链循环引用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立构造函数Person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据回顾1：只要创建一个函数，就会有原型对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		constructor: f Person</span></span><br><span class="line"><span class="comment">		[[prototype]]: Object</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据回顾2：默认情况下，所有的原型的对象自动获得一个名为``constructor``的属性，指回与之关联的构造函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	结合回顾1&amp;&amp;2，不难得到构造函数和原型之间的循环引用关系</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	Person &lt;————&gt; Person.prototype</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2原型链终止于object原型对象"><a href="#（2）原型链终止于Object原型对象" class="headerlink" title="（2）原型链终止于Object原型对象"></a>（2）原型链终止于Object原型对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	正常的原型链都会终止于Object的原型对象</span></span><br><span class="line"><span class="comment">	Object原型的原型是null</span></span><br><span class="line"><span class="comment">	这个在图中已经展示了，下面通过代码进行验证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="literal">null</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3实例访问原型对象"><a href="#（3）实例访问原型对象" class="headerlink" title="（3）实例访问原型对象"></a>（3）实例访问原型对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	实例通过new构造函数进行创建</span></span><br><span class="line"><span class="comment">	根据回顾5：实例可通过__proto__访问到构造函数的原型</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="4原型操作方法"><a href="#（4）原型操作方法" class="headerlink" title="（4）原型操作方法"></a>（4）原型操作方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	instaceof的原理是：检测构造函数的原型是否存在于实例对象的原型链上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	isPrototyeoOf() 用于检测两个对象之间的原型关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Object.getPrototypeOf() 用于获取对象的原型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Object.setPrototypeOf() 用于获取对象的原型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1, person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) === person);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Object.setPrototype()会严重影响代码性能，</span></span><br><span class="line"><span class="comment">	[Mozilla在文档里说，在所有浏览器和JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行Object.setPrototypeOf()</span></span><br><span class="line"><span class="comment">	语句那么简单，而是会涉及所有访问了那些修改过[[Prototype]]的对象的代码]</span></span><br><span class="line"><span class="comment">	所以可以通过Object.create()来创建一个新对象，同时为其指定原型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person2) === person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上述关系均可抽象为下图：</p>
<img src="/2022/07/06/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B/%E5%85%B3%E7%B3%BB%E5%9B%BE2.png" class title="关系图2">

<h3 id="2-原型层级"><a href="#2-原型层级" class="headerlink" title="2. 原型层级"></a>2. 原型层级</h3><h3 id="1对象属性的查找机制"><a href="#（1）对象属性的查找机制" class="headerlink" title="（1）对象属性的查找机制"></a>（1）对象属性的查找机制</h3><blockquote>
<p><strong>对象属性的查找机制：</strong>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值，如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。如果直接原型中没有找到，就会去原型的原型进行寻找，直到找到<code>Object.prototype</code>的原型，指向<code>null</code>为止。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Katrina&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;y2d&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>);  <span class="comment">// y2d</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">name</span>);  <span class="comment">// Katrina</span></span><br></pre></td></tr></table></figure>

<p>从上面这个例子不难理解<strong>对象属性的查找机制</strong>，在<code>p1</code>对象中含有<code>name</code>属性，打印结果为<code>y2d</code>，而<code>p2</code>对象中不含<code>name</code>属性，就沿着指针去对原型寻找<code>name</code>属性并打印出<code>Katrina</code>，同时也可以说明<strong>如果实例对象有和原型对象相同的属性，实例对象的属性会遮盖住原型对象的属性</strong>，会屏蔽对原型同名属性的访问。</p>
<h3 id="2方法"><a href="#（2）方法" class="headerlink" title="（2）方法"></a>（2）方法</h3><ul>
<li>delete删除属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Katrina&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;y2d&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>);  <span class="comment">// y2d</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">name</span>);  <span class="comment">// Katrina</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>);  <span class="comment">// Katrina</span></span><br></pre></td></tr></table></figure>

<ul>
<li>hasOwnProperty() 方法用于确定某个属性是实例的属性还是原型的属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Katrina&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="property">gender</span> = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;gender&#x27;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>hasOwnProperty() 方法可用于改进for…in枚举对象属性时会枚举原型链上的可枚举属性的缺陷：<a href="https://superkatrina123.github.io/2022/07/05/JavaScript/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5_for-in&&for-of%E7%9A%84%E5%8C%BA%E5%88%AB/">循环语句 | for-in&amp;&amp;for-of的区别</a></p>
<h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><p><a href="%E5%8D%A0%E4%B8%AA%E4%BD%8D">手写new</a></p>
<p><a href="%E5%8D%A0%E4%B8%AA%E4%BD%8D">手写instanceof</a></p>
<p>手写Object.create</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起读红宝书</tag>
        <tag>原型和原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>变量 | var let const区别及应用</title>
    <url>/2022/07/05/JavaScript/%E5%8F%98%E9%87%8F_var%20let%20const%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-var"><a href="#1-var" class="headerlink" title="1. var"></a>1. var</h2><h3 id="1var声明作用域"><a href="#（1）var声明作用域" class="headerlink" title="（1）var声明作用域"></a>（1）var声明作用域</h3><blockquote>
<p>使用var操作符定义的变量会成为包含它的函数的局部变量，换句话说var声明的变量的作用域是它当前的执行上下文及其闭包</p>
<p>局部变量说明：在函数调用完之后会被销毁</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> message = <span class="string">&#x27;hi&#x27;</span>;   <span class="comment">// message是test函数的局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);  <span class="comment">//  报错</span></span><br></pre></td></tr></table></figure>

<h3 id="2var声明提升"><a href="#（2）var声明提升" class="headerlink" title="（2）var声明提升"></a>（2）var声明提升</h3><blockquote>
<p>var声明的变量会自动提升到作用域顶部</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-let"><a href="#2-let" class="headerlink" title="2. let"></a>2. let</h2><h3 id="1块级作用域"><a href="#（1）块级作用域" class="headerlink" title="（1）块级作用域"></a>（1）块级作用域</h3><blockquote>
<p>let声明的范围是块级作用域，var声明的范围是函数作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(name);   <span class="comment">// Matt</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);  <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(age);  <span class="comment">// 26</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure>

<h3 id="2不允许重复声明"><a href="#（2）不允许重复声明" class="headerlink" title="（2）不允许重复声明"></a>（2）不允许重复声明</h3><blockquote>
<p>let不允许在<strong>同一个块作用域中</strong>出现冗余声明，注意是同一块级作用域！</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age;  <span class="comment">// SyntaxError: 标识符age已经声明过了</span></span><br></pre></td></tr></table></figure>

<h3 id="3暂时性死区"><a href="#（3）暂时性死区" class="headerlink" title="（3）暂时性死区"></a>（3）暂时性死区</h3><blockquote>
<p>let声明的变量不会在作用域中提升</p>
<p>暂时性死区：在let声明之前不允许任何方式来引用未声明变量，会抛出错误ReferenceError</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name会被提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);   <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// age不会被提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);   <span class="comment">// ReferenceError:age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4全局声明"><a href="#（4）全局声明" class="headerlink" title="（4）全局声明"></a>（4）全局声明</h3><blockquote>
<p>let声明的变量不会成为window对象的属性，而var会</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(windew.<span class="property">name</span>);   <span class="comment">// Matt </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">16</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">age</span>);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="3-const"><a href="#3-const" class="headerlink" title="3. const"></a>3. const</h2><blockquote>
<p>const具有let的以上行为</p>
</blockquote>
<h3 id="1声明即初始化"><a href="#（1）声明即初始化" class="headerlink" title="（1）声明即初始化"></a>（1）声明即初始化</h3><blockquote>
<p>const声明变量时必须同时初始化</p>
</blockquote>
<h3 id="2声明后不允许改变"><a href="#（2）声明后不允许改变" class="headerlink" title="（2）声明后不允许改变"></a>（2）声明后不允许改变</h3><blockquote>
<p>const声明后为常量，不允许改变</p>
</blockquote>
<p>const声明的限制只适用于它指向的变量的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;  <span class="comment">// 不会报错！</span></span><br></pre></td></tr></table></figure>

<h3 id="4-面试题"><a href="#4-面试题" class="headerlink" title="4. 面试题"></a>4. 面试题</h3><h3 id="1for循环中的let声明"><a href="#（1）for循环中的let声明" class="headerlink" title="（1）for循环中的let声明"></a>（1）for循环中的let声明</h3><ul>
<li><p>循环泄漏问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// i is undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代变量的奇特声明和修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">	setTimeout(() =&gt; console.log(i), 0);</span><br><span class="line">&#125;;</span><br><span class="line">// 5 5 5 5 5</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">	setTimeout(() =&gt; console.log(i), 0);</span><br><span class="line">&#125;;</span><br><span class="line">// 0 1 2 3 4</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>常见方法对比</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>常见方法对比</tag>
        <tag>JavaScript</tag>
        <tag>JavaScript变量</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串 | slice substr substring的区别</title>
    <url>/2022/07/08/JavaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2_slice%20substr%20substring%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>三个方法都是用来从字符串中提取子字符串的，因为是提取，三个方法都不改变原字符串</p>
</blockquote>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">slice</span>(startIndex, [endIndex])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>startIndex</code>：从该索引开始</li>
<li><code>endIndex</code>（可选）：在该索引处结束提取字符串（不含），默认为字符串长度</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回提取出来的子字符串</p>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">substring</span>(startIndex, [endIndex])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>startIndex</code>：从该索引开始</li>
<li><code>endIndex</code>（可选）：在该索引处结束提取字符串（不含），默认为字符串长度</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回提取出来的子字符串</p>
<h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">substr</span>(startIndex, [length])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>startIndex</code>：从该索引开始</li>
<li><code>length</code>（可选）：提取的字符数</li>
</ul>
<p><strong>返回值</strong><br>返回提取出来的子字符串</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>三者的主要区别在于面对0参数的处理上</p>
<ul>
<li><code>slice</code>方法会将所有负值参数都使用<code>负值+length</code>的方法进行处理</li>
<li><code>substr</code>方法会将第一个负参数值使用<code>负值+length</code>的方法进行处理，第二个负参数转为0</li>
<li><code>substring</code>方法会将所有的负参数转为0</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>常见方法对比</category>
      </categories>
      <tags>
        <tag>常见方法对比</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>对象 | Object_API</title>
    <url>/2022/07/06/JavaScript/%E5%AF%B9%E8%B1%A1_Object_API/</url>
    <content><![CDATA[<blockquote>
<p>Object的API众多且重要，按照Object原型方法、进行分类</p>
</blockquote>
<h3 id="object原型方法所有实例共享"><a href="#Object原型方法（所有实例共享）" class="headerlink" title="Object原型方法（所有实例共享）"></a>Object原型方法（所有实例共享）</h3><blockquote>
<p>以下方法来自于Object.prototype，参考《红宝书》P56</p>
</blockquote>
<h4 id="1constructor"><a href="#（1）constructor" class="headerlink" title="（1）constructor"></a>（1）constructor</h4><p>用于创建当前对象的函数</p>
<h4 id="2hasownpropertypropertyname"><a href="#（2）hasOwnProperty-propertyName" class="headerlink" title="（2）hasOwnProperty(propertyName)"></a>（2）hasOwnProperty(propertyName)</h4><p>用于判断当前对象实例（不是原型）上是否存在给定的属性，要检查的属性名必须是字符串（如<code>obj.hasOwnProperty(&quot;name&quot;)</code>）或<code>Symbol</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="3isprototypeofobject"><a href="#（3）isPrototypeOf-object" class="headerlink" title="（3）isPrototypeOf(object)"></a>（3）isPrototypeOf(object)</h4><p>用于判断当前对象是否为另一个对象的原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">isPrototypeOf</span>(p));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="4propertyisenumerablepropertyname"><a href="#（4）propertyIsEnumerable-propertyName" class="headerlink" title="（4）propertyIsEnumerable(propertyName)"></a>（4）propertyIsEnumerable(propertyName)</h4><p>用于判断给定的属性是否可以使用for-in 语句枚举，属性名必须是字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">	<span class="attr">value</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">	<span class="attr">value</span>: <span class="number">18</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;name&#x27;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;age&#x27;</span>));   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="5tolocalestring"><a href="#（5）toLocaleString" class="headerlink" title="（5）toLocaleString()"></a>（5）toLocaleString()</h4><p>返回对象的字符串表示，该字符串反映对象所在的本地化执行环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">toLocaleString</span>();  <span class="comment">// &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="6tostring"><a href="#（6）toString" class="headerlink" title="（6）toString()"></a>（6）toString()</h4><p>返回对象的字符串表示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">toString</span>();  <span class="comment">// &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="7-valueof"><a href="#（7）-valueOf" class="headerlink" title="（7） valueOf()"></a>（7） valueOf()</h4><p>返回对象对应的字符串、数值或布尔值表示，通常与toString()的返回值相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">valueOf</span>());   <span class="comment">// &#123;name: Katrina, age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置原型方法"><a href="#设置原型方法" class="headerlink" title="设置原型方法"></a>设置原型方法</h3><h4 id="1objectcreate-es5"><a href="#（1）Object-create-【ES5】" class="headerlink" title="（1）Object.create()  【ES5】"></a>（1）Object.create()  【ES5】</h4><blockquote>
<p><code>Object.create()</code>用于创建一个新对象，使用现有的对象来作为新创建对象的原型。</p>
</blockquote>
<p><strong>语法如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.create(proto);</span><br><span class="line">Object.create(proto, propertiesObject);</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<p><code>proto</code>：新建对象的原型对象</p>
<p><code>propertiesObject</code>（可选）：传入对象的可枚举属性将为新创建的对象添加指定的属性值和对应的属性描述符，这些属性对应于<code>Object.defineProperties()</code>的第二个参数</p>
<p><strong>返回值：</strong></p>
<p>一个新对象，带着指定的原型对象及其属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">isPrototypeOf</span>(p));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="2objectsetprototypeofobj-prototype-es6"><a href="#（2）Object-setPrototypeOf-obj-prototype-【ES6】" class="headerlink" title="（2）Object.setPrototypeOf(obj, prototype)   【ES6】"></a>（2）Object.setPrototypeOf(obj, prototype)   【ES6】</h4><blockquote>
<p><code>Object.setPrototypeOf()</code>方法设置一个指定的对象的原型 ( 即，内部 [[Prototype]] 属性）到另一个对象或  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null"><code>null</code></a></p>
</blockquote>
<p><strong>语法如下</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, prototype)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><p>obj</p>
<p>要设置其原型的对象。</p>
</li>
<li><p>prototype</p>
<p>该对象的新原型 (一个对象 或 null）</p>
</li>
</ul>
<blockquote>
<p><strong>警告：</strong>由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 <code>[[Prototype]]</code> 在<em><strong>各个</strong></em>浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 <code>obj.__proto__ = ...</code> 语句上的时间花费，而且可能会延伸到<em><strong>任何</strong></em>代码，那些可以访问<em><strong>任何</strong></em> <code>[[Prototype]]</code> 已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 <code>[[Prototype]]</code>。相反，你应该使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create()</code></a> 来创建带有你想要的 <code>[[Prototype]]</code> 的新对象。</p>
</blockquote>
<h3 id="object属性方法"><a href="#Object属性方法" class="headerlink" title="Object属性方法"></a>Object属性方法</h3><p>自觉补课：<a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B/">Object属性类型</a></p>
<h4 id="1定义属性objectdefineproperty-es5-ampamp-objectdefineproperties-es5"><a href="#（1）定义属性：Object-defineProperty-【ES5】-amp-amp-Object-defineProperties-【ES5】" class="headerlink" title="（1）定义属性：Object.defineProperty()  【ES5】    &amp;&amp;    Object.defineProperties()    【ES5】"></a>（1）定义属性：Object.defineProperty()  【ES5】    &amp;&amp;    Object.defineProperties()    【ES5】</h4><blockquote>
<p>两者的区别在于前者单个定义，后者多个定义</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor);</span><br><span class="line"></span><br><span class="line">- <span class="attr">obj</span>: 要定义属性的对象</span><br><span class="line">- <span class="attr">prop</span>: 要定义或修改的属性的名称或<span class="title class_">Symbol</span></span><br><span class="line">- <span class="attr">descriptor</span>: 要定义或修改的属性描述符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj,props);</span><br><span class="line">- <span class="attr">obj</span>: 要定义属性的对象</span><br><span class="line">- <span class="attr">props</span>: 要定义其可枚举属性或者修改的属性描述符的对象</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.defineProperty(obj, prop, descriptor);</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.defineProperties(obj,props);</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(person, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    	<span class="attr">value</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2获取属性的特性objectgetownpropertydescriptor-es5-ampamp-objectgetownpropertydescriptors-es8"><a href="#（2）获取属性的特性：Object-getOwnPropertyDescriptor-【ES5】-amp-amp-Object-getOwnPropertyDescriptors-【ES8】" class="headerlink" title="（2）获取属性的特性：Object.getOwnPropertyDescriptor()   【ES5】  &amp;&amp; Object.getOwnPropertyDescriptors()   【ES8】"></a>（2）获取属性的特性：Object.getOwnPropertyDescriptor()   【ES5】  &amp;&amp; Object.getOwnPropertyDescriptors()   【ES8】</h4><blockquote>
<p>可以取得指定属性的属性描述符</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, prop);</span><br><span class="line"></span><br><span class="line">- <span class="attr">obj</span>:目标对象</span><br><span class="line">- <span class="attr">prop</span>:目标对象内的属性</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">- <span class="attr">obj</span>:目标对象</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(person, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    	<span class="attr">value</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor); <span class="comment">// &#123;value: &#x27;Katrina&#x27;, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">writable</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">enumerable</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="3获取属性名-objectgetownpropertynames-es5-ampamp-objectgetownpropertysymbols-es6"><a href="#（3）获取属性名：-Object-getOwnPropertyNames-【ES5】-amp-amp-Object-getOwnPropertySymbols-【ES6】" class="headerlink" title="（3）获取属性名： Object.getOwnPropertyNames()   【ES5】 &amp;&amp; Object.getOwnPropertySymbols()    【ES6】"></a>（3）获取属性名： Object.getOwnPropertyNames()   【ES5】 &amp;&amp; Object.getOwnPropertySymbols()    【ES6】</h4><blockquote>
<p><code>Object.getOwnPropertyNames()</code>返回一个由指定对象的<strong>所有自身属性的属性名</strong>（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组</p>
<p><code>Object.getOwnPropertySymbols()</code>返回一个给定对象自身的所有 Symbol 属性的数组</p>
<p>返回值都是数组，注意限定条件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.getOwnPropertyNames()</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(arr).<span class="title function_">sort</span>()); <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;length&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.getOwnPropertySymbols()</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&quot;localSymbol&quot;</span>;</span><br><span class="line">obj[b] = <span class="string">&quot;globalSymbol&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols)         <span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols[<span class="number">0</span>])      <span class="comment">// Symbol(a)</span></span><br></pre></td></tr></table></figure>

<h4 id="4对象不可扩展-objectpreventextensions-ampamp-objectseal-ampamp-objectfreeze-es5all"><a href="#（4）对象不可扩展：-Object-preventExtensions-amp-amp-Object-seal-amp-amp-Object-freeze-【ES5】ALL" class="headerlink" title="（4）对象不可扩展： Object.preventExtensions()   &amp;&amp; Object.seal()  &amp;&amp; Object.freeze()    【ES5】ALL"></a>（4）对象不可扩展： Object.preventExtensions()   &amp;&amp; Object.seal()  &amp;&amp; Object.freeze()    【ES5】ALL</h4><blockquote>
<p><code>Object.preventExtensions(obj)</code>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性，原有的属性可以修改和删除  【阻止】</p>
<p><code>Object.seal(obj)</code>方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置，当前属性的值只要原来是可写的就可以改变，即不允许删除和添加，能不能修改根据writable属性决定 【封闭】</p>
<p><code>Object.freeze(obj)</code>方法可以<strong>冻结</strong>一个对象，一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值，啥也干不了呗~ 【冻结】</p>
<p>【根据中文含义，锁定深度是层层递进的~】</p>
</blockquote>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.preventExtensions(obj)</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;c&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">3</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;d&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">4</span>, <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line">obj === obj2;  <span class="comment">// true</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">obj.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">obj.<span class="property">c</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">obj.<span class="property">d</span> = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>, obj.<span class="property">c</span>, obj.<span class="property">d</span>); <span class="comment">// a, undefined, 3, d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>, obj.<span class="property">c</span>, obj.<span class="property">d</span>); <span class="comment">// undefined, undefined, 3, d</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;c&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">obj.<span class="property">c</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;d&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">obj.<span class="property">d</span> = <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>, obj.<span class="property">c</span>, obj.<span class="property">d</span>); <span class="comment">// undefined, undefined, c, d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.seal()</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;c&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">3</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;d&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">4</span>, <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">seal</span>(obj);</span><br><span class="line">obj === obj2;  <span class="comment">// true</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">obj.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">obj.<span class="property">c</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">obj.<span class="property">d</span> = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>, obj.<span class="property">c</span>, obj.<span class="property">d</span>); <span class="comment">// a, undefined, 3, d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>, obj.<span class="property">c</span>, obj.<span class="property">d</span>); <span class="comment">// a, undefined, 3, d</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;c&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">true</span>&#125;); <span class="comment">// TypeError</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;d&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;); <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.freeze()</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;c&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">3</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;d&#x27;</span>, &#123;<span class="attr">value</span>: <span class="number">4</span>, <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">obj === obj2;  <span class="comment">// true</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">obj.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">obj.<span class="property">c</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">obj.<span class="property">d</span> = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>, obj.<span class="property">c</span>, obj.<span class="property">d</span>); <span class="comment">// a, undefined, 3, 4</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>, obj.<span class="property">b</span>, obj.<span class="property">c</span>, obj.<span class="property">d</span>); <span class="comment">// a, undefined, 3, 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;c&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">true</span>&#125;); <span class="comment">// TypeError</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;d&#x27;</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h4 id="5对象是否可扩展-是否被冻结-是否被封锁objectisextensible-objectisfrozen-objectissealed-es5all"><a href="#（5）对象是否可扩展-是否被冻结-是否被封锁：Object-isExtensible-Object-isFrozen-Object-isSealed-【ES5】ALL" class="headerlink" title="（5）对象是否可扩展 是否被冻结 是否被封锁：Object.isExtensible()    Object.isFrozen()   Object.isSealed()    【ES5】ALL"></a>（5）对象是否可扩展 是否被冻结 是否被封锁：Object.isExtensible()    Object.isFrozen()   Object.isSealed()    【ES5】ALL</h4><blockquote>
<p><code>Object.isExtensible</code>判断一个对象是否是可扩展的（是否可以添加新的属性）</p>
<p><code>Object.isFrozen()</code>方法判断一个对象是否被冻结</p>
<p><code>Object.isSealed()</code>判断一个对象是否被密封</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj)  <span class="comment">// 返回布尔值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(obj)   <span class="comment">// 返回布尔值</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，对象是可扩展的：即可以为他们添加新的属性。以及它们的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>__proto__</code></a>Deprecated 属性可以被更改。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions"><code>Object.preventExtensions</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal"><code>Object.seal</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze</code></a> 方法都可以标记一个对象为不可扩展（non-extensible）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 新对象默认是可扩展的。</span><br><span class="line"><span class="keyword">var</span> empty = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(empty); <span class="comment">// === true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...可以变的不可扩展。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(empty);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(empty); <span class="comment">// === false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密封对象是不可扩展的。</span></span><br><span class="line"><span class="keyword">var</span> sealed = <span class="title class_">Object</span>.<span class="title function_">seal</span>(&#123;&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(sealed); <span class="comment">// === false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冻结对象也是不可扩展。</span></span><br><span class="line"><span class="keyword">var</span> frozen = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(frozen); <span class="comment">// === false</span></span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="1枚举方法-objectentries-es8-ampamp-objectkeys-es5-ampamp-objectvalues-es8"><a href="#（1）枚举方法：-Object-entries-【ES8】-amp-amp-Object-keys-【ES5】-amp-amp-Object-values-【ES8】" class="headerlink" title="（1）枚举方法： Object.entries()   【ES8】  &amp;&amp;  Object.keys()   【ES5】  &amp;&amp; Object.values()   【ES8】"></a>（1）枚举方法： Object.entries()   【ES8】  &amp;&amp;  Object.keys()   【ES5】  &amp;&amp; Object.values()   【ES8】</h4><blockquote>
<p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）</p>
<p><code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。</p>
<p><code>Object.values()</code>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a>循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )</p>
<p>返回值都是数组</p>
</blockquote>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.entries()</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys()</span></span><br><span class="line"><span class="keyword">var</span> anObj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(anObj)); <span class="comment">// console: [&#x27;2&#x27;, &#x27;7&#x27;, &#x27;100&#x27;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.values()</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)); <span class="comment">// [&#x27;bar&#x27;, 42]</span></span><br></pre></td></tr></table></figure>

<h4 id="2合并对象objectassign-es6"><a href="#（2）合并对象：Object-assign-【ES6】" class="headerlink" title="（2）合并对象：Object.assign()   【ES6】"></a>（2）合并对象：Object.assign()   【ES6】</h4><blockquote>
<p><code>Object.assign()</code> 方法将所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>（<code>Object.propertyIsEnumerable()</code> 返回 true）和自有（<code>Object.hasOwnProperty()</code> 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象</p>
</blockquote>
<p><strong>语法如下</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources);</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><p>target：目标对象，接收源对象属性的对象，也是修改后的返回值</p>
</li>
<li><p>sources：源对象，包含将被合并的属性</p>
</li>
</ul>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> p2 = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="title class_">Object</span>.<span class="title function_">assign</span>(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);   <span class="comment">// &#123;name: &#x27;Katrina&#x27;, age: 18&#125;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);   <span class="comment">// &#123;name: &#x27;Katrina&#x27;, age: 18&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Object.assign()会改变目标对象</p>
</li>
<li><p>Object.assign()只复制属性值，是一种浅拷贝</p>
</li>
<li><p>Object.assign()会覆盖从后向前覆盖相同属性</p>
</li>
</ul>
<h4 id="3比较方法-objectis-es6"><a href="#（3）比较方法：-Object-is-【ES6】" class="headerlink" title="（3）比较方法： Object.is()    【ES6】"></a>（3）比较方法： Object.is()    【ES6】</h4><blockquote>
<p><code>Object.is(value1, value2)</code>判断两个值是否为同一个值</p>
</blockquote>
<p>相较于<code>===</code>（严格相等），Object.is对两种情况做了改变：</p>
<ol>
<li><code>Object.is(NaN, NaN) ;   // true</code></li>
<li><code>Object.is(-0, +0);   // true</code></li>
</ol>
<p>其余和<code>===</code>一样</p>
<p>补充：<a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.is/">手写Object.is</a></p>
<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B/">对象 | 对象属性的类型</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.is/">手写Object.is</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/05/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">深浅拷贝</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.create/">手写原理| Object.create</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/05/JavaScript/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5_for-in&&for-of%E7%9A%84%E5%8C%BA%E5%88%AB/">循环语句 | for-in&amp;&amp;for-of的区别</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://segmentfault.com/a/1190000010753942">JavaScript 对象所有API解析</a></p>
<p><a href="jianshu.com/p/b3eb24570c74">Object.preventExtensions()、Object.seal()、Object.freeze() 的区别</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">MDN Object</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起做总结</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起做总结</tag>
        <tag>ES6</tag>
        <tag>JavaScript对象</tag>
      </tags>
  </entry>
  <entry>
    <title>对象 | 创建对象（含手写）</title>
    <url>/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = name;</span><br><span class="line">    obj.<span class="property">age</span> = age;</span><br><span class="line">    obj.<span class="property">job</span> = job;</span><br><span class="line">    obj.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);      <span class="comment">// 考考你：this指向哪里？</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);   <span class="comment">// &#123;name: &#x27;Katrina&#x27;, age: 18, job: &#x27;student&#x27;, sayName: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>可以解决创建多个类似对象的问题</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>没有解决对象标识问题（即新创建的对象是什么类型）<ul>
<li>通俗来说，工厂模式中我们直接用<code>new Object</code>来创建，所以实例的原型链上只有<code>Object.prototype</code>对象</li>
</ul>
</li>
</ul>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;student&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Person()</code>构造函数代替了<code>createPerson()</code>工厂函数，实际上，<code>Person()</code>内部代码跟<code>createPerson()</code>基本一样，有如下区别：</p>
<ul>
<li>没有显示地创建对象</li>
<li>属性和方法直接付给了this</li>
<li>没有return</li>
</ul>
<p>这就需要我们明白new操作符的机制了：<a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_new/">手写原理 | new操作符</a></p>
<p><strong>优点</strong></p>
<ul>
<li>定义自定义构造函数可以确保实例被标识为特定类型   <a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_instanceof/">手写原理 | instanceof</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong></p>
<ul>
<li>定义的每个方法会在每个实例上都创建一遍</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Kate&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;doctor&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">sayName</span> === p2.<span class="property">sayName</span>)    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Person.prototype.sayHello = function() &#123;</span></span><br><span class="line"><span class="comment">		console.log(this.name);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	console.log(p1.sayHello === p2.sayHello)    // true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在上面这个例子中，<code>p1</code>和<code>p2</code>都有<code>sayName</code>方法，但这两个方法不是同一个<code>sayName</code>实例</p>
<p>在<code>ECMAScript</code>中的函数是对象，因此每次定义函数时，都会初始化一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	每个Person实例都会有自己的Function实例用于显示name属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); )   <span class="comment">// 逻辑等价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为都是做同样一件事，所以定义两个Function实例是没必要的，要解决这个问题，可以把函数定义转移到函数外部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = sayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Kate&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;doctor&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，<code>sayName()</code>被定义在了构造函数外部，在构造函数内部，<code>sayName</code> 属性等于全局<code>sayName()</code>函数</p>
<p>因为这一次<code>sayName</code> 属性中包含的只是一个指向外部函数的指针，所以<code>person1 </code>和<code>person2</code>共享了定义在全局作用域上的<code>sayName()</code>函数</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>每个函数都会创建一个<code>prototype</code>属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法<br>补课：<a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE_%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B/">理解原型</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Katrina&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Student&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Katrina&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Katrina&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>原型上定义的属性和方法可以被对象实例共享</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>更改一个子类的引用，其他子类也会受到影响</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="property">colors</span>[<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;yellow&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;yellow&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子类在实例化的时候不能向父类传参</li>
</ul>
<h3 id="构造函数模式原型模式"><a href="#构造函数模式-原型模式" class="headerlink" title="构造函数模式+原型模式"></a>构造函数模式+原型模式</h3><p>属性写在构造函数模型中，方法写在原型模型中</p>
<p>这样的话，每个实例都有自己实例属性的副本，但同时又共享着对方法的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Kate&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;doctor&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">sayName</span> == p2.<span class="property">sayName</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">colors</span>[<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;yellow&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;black&#x27;, &#x27;yellow&#x27;]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>和我一起做总结</tag>
        <tag>和我一起读红宝书</tag>
        <tag>JavaScript对象</tag>
      </tags>
  </entry>
  <entry>
    <title>对象 | 对象属性的类型</title>
    <url>/2022/07/06/JavaScript/%E5%AF%B9%E8%B1%A1_%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为JavaScript 实现引擎的规范定义的。因此，开发者不能在JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。</p>
<p>属性分为两种：<strong>数据属性</strong>和<strong>访问属性</strong></p>
</blockquote>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><h4 id="1configurable"><a href="#（1）-Configurable" class="headerlink" title="（1）[[Configurable]]"></a>（1）[[Configurable]]</h4><blockquote>
<p>表示属性<strong>是否可以通过delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性</strong></p>
<p>默认情况下，所有直接定义在对象上的属性的这个特性都是true</p>
</blockquote>
<p>注意：一个属性被定义为不可配置（即）<code>configurable=false</code>后，就不能再变回之前的可配置了<code>configurable=true</code></p>
<h4 id="2enumerable"><a href="#（2）-Enumerable" class="headerlink" title="（2）[[Enumerable]]"></a>（2）[[Enumerable]]</h4><blockquote>
<p>表示属性<strong>是否可以通过for-in 循环返回</strong>（心里默念：for…in用于遍历对象上可枚举属性，包括原型上的可枚举属性，巴拉巴拉~）</p>
<p>默认情况下，所有直接定义在对象上的属性的这个特性都是true</p>
</blockquote>
<h4 id="3writable"><a href="#（3）-Writable" class="headerlink" title="（3）[[Writable]]"></a>（3）[[Writable]]</h4><blockquote>
<p>表示属性的<strong>值是否可以被修改</strong></p>
<p>默认情况下，所有直接定义在对象上的属性的这个特性都是true</p>
</blockquote>
<h4 id="4value"><a href="#（4）-Value" class="headerlink" title="（4）[[Value]]"></a>（4）[[Value]]</h4><blockquote>
<p>包含属性实际的值</p>
<p>这个特性的默认值为undefined</p>
</blockquote>
<h4 id="数据属性总结与应用"><a href="#数据属性总结与应用" class="headerlink" title="数据属性总结与应用"></a>数据属性总结与应用</h4><ol>
<li><p>将属性显式添加到对象之后，<code>[[Configurable]]</code>、<code>[[Enumerable]]</code>和<code>[[Writable]]</code>都会被设置为<code>true</code>，而<code>[[Value]]</code>特性会被设置为指定的值</p>
</li>
<li><p>用<code>Object.defineProperty()</code>修改属性的默认特性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor);</span><br><span class="line"></span><br><span class="line">- <span class="attr">obj</span>: 要定义属性的对象</span><br><span class="line">- <span class="attr">prop</span>: 要定义或修改的属性的名称或<span class="title class_">Symbol</span></span><br><span class="line">- <span class="attr">descriptor</span>: 要定义或修改的属性描述符</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);   <span class="comment">// Katrina</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);   <span class="comment">// Katrina</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	因为设置了writable: false,说明name属性的值不可以被修改</span></span><br><span class="line"><span class="comment">	非严格模式，忽略</span></span><br><span class="line"><span class="comment">	严格模式，抛出错误</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个属性被定义为不可配置（即）<code>configurable=false</code>后，就不能再变回之前的可配置了<code>configurable=true</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在调用<code>Object.defineProperty()</code>时，configurable、enumerable 和writable 的值如果不指定，则都默认为false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);   <span class="comment">// Katrina</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);   <span class="comment">// Katrina   说明writable: false</span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);   <span class="comment">// Katrina   说明configurable: false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k)           <span class="comment">// 啥也没有  说明enumerable: false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><blockquote>
<p>访问器属性包含一个获取（getter）函数和一个设置（setter）函数</p>
<ol>
<li>在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值</li>
<li>在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改</li>
</ol>
<p>访问器属性是不能直接定义的，必须使用<code>Object.defineProperty()</code></p>
</blockquote>
<h4 id="configurable"><a href="#Configurable" class="headerlink" title="[[Configurable]]"></a>[[Configurable]]</h4><blockquote>
<p>表示属性是否可以通过delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性</p>
<p>默认情况下，所有直接定义在对象上的属性的这个特性都是true</p>
</blockquote>
<h4 id="enumerable"><a href="#Enumerable" class="headerlink" title="[[Enumerable]]"></a>[[Enumerable]]</h4><blockquote>
<p>表示属性是否可以通过for-in 循环返回</p>
<p>默认情况下，所有直接定义在对象上的属性的这个特性都是true</p>
</blockquote>
<h4 id="get"><a href="#Get" class="headerlink" title="[[Get]]"></a>[[Get]]</h4><blockquote>
<p>获取函数，在读取属性时调用</p>
<p>默认值为undefined。</p>
</blockquote>
<h4 id="set"><a href="#Set" class="headerlink" title="[[Set]]"></a>[[Set]]</h4><blockquote>
<p>设置函数，在写入属性时调用</p>
<p>默认值为undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    <span class="attr">year_</span>: <span class="number">2017</span>,</span><br><span class="line">    <span class="attr">edition</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&#x27;year&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>;  </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">year_</span> = newValue;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2018</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.<span class="property">year_</span> = <span class="number">2018</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">edition</span>);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p><strong>属性访问器的典型使用场景：设置一个属性值会导致一些其他变化发生</strong></p>
<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/05/JavaScript/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5_for-in&&for-of%E7%9A%84%E5%8C%BA%E5%88%AB/">循环语句 | for-in&amp;&amp;for-of的区别</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起读红宝书</tag>
        <tag>JavaScript对象</tag>
      </tags>
  </entry>
  <entry>
    <title>对象 | 继承（含图解、手写）</title>
    <url>/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote>
<p>基本思想：通过原型链继承多个引用类型的属性和方法</p>
<p>我们知道，实例和原型是有直接联系的，实例可以通过<code>__proto__</code>访问原型，所以原型链继承即<strong>将父类的实例作为子类的原型</strong>，这样子类的原型就可以通过<code>__proto__</code>访问父类的原型了</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Father</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<img src="/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.png" class title="原型链继承">

<p><strong>优点</strong></p>
<ul>
<li>父类的方法子类能够被子类复用，因为子类可以访问父类原型，原型存在着父类实例可以共享的方法和属性</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>更改一个子类的引用，其他子类也会受到影响</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="property">colors</span>[<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;yellow&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;yellow&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子类在实例化的时候不能向父类传参</li>
</ul>
<h3 id="盗用构造函数继承"><a href="#盗用构造函数继承" class="headerlink" title="盗用构造函数继承"></a>盗用构造函数继承</h3><blockquote>
<p>基本思想：在子类构造函数中调用父类构造函数，可以使用call或者apply的方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 继承Father</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);   <span class="comment">// 通过此方法让子类继承父类中的方法和属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;black&#x27;, &#x27;yellow&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;black&#x27;, &#x27;yellow&#x27;]</span></span><br></pre></td></tr></table></figure>

<img src="/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF.png" class title="盗用构造函数继承">

<p><strong>优点</strong></p>
<ul>
<li>可以在子类构造函数中向父类构造函数传参</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 继承Father</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;Katrina&#x27;</span>);   <span class="comment">// 通过此方法让子类继承父类中的方法和属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>);   <span class="comment">// Katrina</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父类的引用属性不会被共享</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 继承Father</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);   <span class="comment">// 通过此方法让子类继承父类中的方法和属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="property">colors</span>[<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;yellow&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">colors</span>);    <span class="comment">// [&#x27;red&#x27;, &#x27;black&#x27;, &#x27;yellow&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong></p>
<ul>
<li>必须在构造函数中定义方法，函数不能复用，每次创建都会初始化</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> 	<span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> say hello!`</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次调用<code>new Father</code>，就会在实例内部定义一次这个<code>sayHello</code>方法，也就是<code>new Function(console.log($&#123;this.name&#125; say hello!))</code>，其实是更推荐把方法定义在<code>Father.prototype</code>上的，这样每个实例构造出来就自动继承这个方法，不需要在构造函数里面一次次地写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> 	<span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> say hello!`</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说在构造函数继承的时候也在一次次调用<code>sayHello</code>这个方法</p>
<ul>
<li>（上个问题的延申）子类不能访问父类原型上的方法【<code>instanceOf</code>会失效】，所有方法都只能定义在父类构造函数中</li>
</ul>
<h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><blockquote>
<p>基本思想：使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;Lucy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数继承</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);                 <span class="comment">// 调用两次</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();                     <span class="comment">// 调用一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;Kate&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">sayName</span>();   <span class="comment">// &#x27;Katrina&#x27;</span></span><br><span class="line">p2.<span class="title function_">sayName</span>();   <span class="comment">// &#x27;Kate&#x27;</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">friends</span>);    <span class="comment">// [&#x27;Jack&#x27;, &#x27;Jenny&#x27;, &#x27;Lucy&#x27;, &#x27;Bob&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">friends</span>);    <span class="comment">// [&#x27;Jack&#x27;, &#x27;Jenny&#x27;, &#x27;Lucy&#x27;]</span></span><br></pre></td></tr></table></figure>

<img src="/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF.png" class title="组合式继承">

<p><strong>优点</strong></p>
<ul>
<li>父类的方法子类能够被子类复用</li>
<li>父类的引用属性不会被共享</li>
<li>子类可以访问父类原型上的方法</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>效率问题：父类构造函数始终会被调用两次<ul>
<li>创建子类原型时调用</li>
<li>在子类构造函数中调用</li>
</ul>
</li>
</ul>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><blockquote>
<p>基本思想：把现有的对象指定为构造函数的原型对象，并返回以这个对象为原型的构造函数的实例</p>
<p>适用于：你有一个对象，你想在这个对象的基础上再创建一个对象 以及 不需要单独创建构造函数，但仍需要在对象间共享信息的场合</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;;     <span class="comment">// 临时构建构造函数</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;    <span class="comment">// 把传入的对象指定为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();     <span class="comment">// 返回临时类型的实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上，object是吧传入的o进行了一次浅复制</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;Lucy&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">object</span>(person);</span><br><span class="line">anotherPerson.<span class="property">name</span>;   <span class="comment">// &#x27;Katrina&#x27;;</span></span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;Kate&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="title function_">object</span>(person);</span><br><span class="line">yetAnotherPerson.<span class="property">name</span>;   <span class="comment">// &#x27;Katrina&#x27;;</span></span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>);   <span class="comment">// [&#x27;Jack&#x27;, &#x27;Jenny&#x27;, &#x27;Lucy&#x27;, &#x27;Kate&#x27;, &#x27;Bob&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>ES5中新增的<code>Object.create()</code>只传一个参数时就是运用的这种思想：<a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Object.create/">手写原理 | Object.create</a></p>
<img src="/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF.png" class title="原型式继承">

<p><strong>优点</strong></p>
<ul>
<li>父类方法可以复用</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>更改一个子类的引用，其他子类也会受到影响</li>
<li>子类在实例化的时候不能向父类传参</li>
</ul>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><blockquote>
<p>基本思想：创建一个实现继承的函数，以某种方式<strong>增强</strong>对象，然后返回这个对象</p>
<p>适用于：主要关注对象，而不在乎类型和构造函数的场景</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;;     <span class="comment">// 临时构建构造函数</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;    <span class="comment">// 把传入的对象指定为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();     <span class="comment">// 返回临时类型的实例</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnotherPerson</span>(<span class="params">original</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="title function_">object</span>(original);    <span class="comment">// 创建一个新对象，它的构造函数的原型是original</span></span><br><span class="line">    clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;      <span class="comment">// 给对象添加一个sayHi的方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;       <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;Lucy&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">createAnotherPerson</span>(person);</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>();        <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure>

<p><code>object()</code>函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用</p>
<img src="/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF.png" class title="寄生继承">

<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><blockquote>
<p>寄生式组合继承主要是为了解决组合继承的效率问题</p>
<p>基本思想：不通过调用父类构造函数给子类原型赋值，而是取得父类函数的一个副本，即使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;;     <span class="comment">// 临时构建构造函数</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;    <span class="comment">// 把传入的对象指定为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();     <span class="comment">// 返回临时类型的实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Son, Father</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = <span class="title function_">object</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);    <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = <span class="title class_">Son</span>;                 <span class="comment">// 增强对象</span></span><br><span class="line">    <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;                   <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;Lucy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数继承</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);                  <span class="comment">// 调用一次   </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Father</span>, <span class="title class_">Son</span>);</span><br></pre></td></tr></table></figure>

<p><code>instanceof </code>和<code> isPrototypeof</code>方法正常有效</p>
<img src="/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF.png" class title="寄生式组合继承">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2022/07/10/JavaScript/%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E5%88%86%E7%B1%BB.png" class title="继承分类">

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://segmentfault.com/q/1010000004846488">关于构造函数继承的缺点的一个疑问</a></p>
<p><a href="https://developer.aliyun.com/article/672933#slide-8">一篇文章理解JS继承——原型链&#x2F;构造函数&#x2F;组合&#x2F;原型式&#x2F;寄生式&#x2F;寄生组合&#x2F;Class extends</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>和我一起做总结</tag>
        <tag>和我一起读红宝书</tag>
        <tag>JavaScript对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>异步函数 | Promise值穿透</title>
    <url>/2022/07/13/JavaScript/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0_Promise%E5%80%BC%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>回顾一下红宝书第四版P330中的一句话：”传给then()的任何非函数类型的参数都会被静默忽略“，这个忽略是单纯的忽略吗？其实不然，应该考虑到值穿透的问题</p>
<blockquote>
<p><code>.then</code> 或者<code> .catch</code> 的参数期望是函数，传入非函数则会发生<strong>值穿透</strong></p>
</blockquote>
<p>举例1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="number">2</span>)         <span class="comment">// 注意这里</span></span><br><span class="line">	.<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">	.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果为1</span></span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>))  <span class="comment">// 注意这里</span></span><br><span class="line">	.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果为foo</span></span><br></pre></td></tr></table></figure>

<p>举例3： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="number">2</span>&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))   <span class="comment">// 注意这里</span></span><br><span class="line">	.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果为2</span></span><br></pre></td></tr></table></figure>

<p>举例4：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="number">2</span>&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>)&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个不是穿透的例子，主要是为了要理解：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透</span></span><br></pre></td></tr></table></figure>

<p><strong>拓展</strong>：catch的穿透</p>
<p>举例1：一个很容易理解的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>)           </span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;rejected&gt;:1&#125;</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value);    <span class="comment">// 这里不起作用因为这个是onResolved处理程序</span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failture&#x27;</span>, reason);   <span class="comment">// 打印结果为：filture 1</span></span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;resolved&gt;:undefined&#125; 因为没有显示的返回语句</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value);    <span class="comment">// 打印结果为：success </span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failture&#x27;</span>, reason);   <span class="comment">// 不起作用</span></span><br><span class="line">&#125;)                                     <span class="comment">// 返回的Promise实例： Promise &#123;&lt;resolved&gt;:undefined&#125; 因为没有显示的返回语句</span></span><br></pre></td></tr></table></figure>

<p>举例2：增加catch</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>)           </span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;rejected&gt;:1&#125;</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value);    <span class="comment">// 这里不起作用因为这个是onResolved处理程序</span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failture&#x27;</span>, reason);   <span class="comment">// 打印结果为：filture 1</span></span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;resolved&gt;:undefined&#125; 因为没有显示的返回语句</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value);    <span class="comment">// 打印结果为：success </span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failture&#x27;</span>, reason);   <span class="comment">// 不起作用</span></span><br><span class="line">&#125;)                                     <span class="comment">// 返回的Promise实例： Promise &#123;&lt;resolved&gt;:undefined&#125; 因为没有显示的返回语句</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failture&#x27;</span>, reason);   <span class="comment">// 不会走到这里的，因为Promise实例的状态为resolved</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>举例3：then里面没有onRejected处理程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;rejected&gt;:1&#125;</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value); <span class="comment">//没有指定失败的回调函数，不执行代码，去往下一级寻找失败状态回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value); <span class="comment">//没有指定失败的回调函数，不执行代码，去往下一级寻找失败状态回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failture&#x27;</span>, reason);        <span class="comment">// 打印结果为： failture 3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	当.then方法中没有指定失败的回调函数时</span></span><br><span class="line"><span class="comment">	使用.catch会默认为没有指定失败回调函数的.then指定失败的回调函数</span></span><br><span class="line"><span class="comment">	reason =&gt; &#123;</span></span><br><span class="line"><span class="comment">		throw reason    // 注意这里不是return reason 而是throw reason      throw保证了返回结果为失败</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>举例4：在举例3上拓展，注意看变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;rejected&gt;:1&#125;</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value); <span class="comment">//没有指定失败的回调函数，不执行代码，去往下一级寻找失败状态回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value); </span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;                      <span class="comment">// 指定了失败的回调函数，执行失败的回调函数，而不会执行catch</span></span><br><span class="line"> 	 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failture111&#x27;</span>, reason);  <span class="comment">// 打印结果为： failture111 3</span></span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;resolved&gt;:undefined&#125;</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failture&#x27;</span>, reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>举例5：<strong>当一个promise是reject状态，但是没有失败回调，也没有写catch捕获，那么系统会默认捕获</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;rejected&gt;:1&#125;</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value); <span class="comment">//没有指定失败的回调函数，不执行代码，去往下一级寻找失败状态回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value); <span class="comment">//没有指定失败的回调函数，不执行代码，去往下一级寻找失败状态回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	系统默认捕获的形式如下</span></span><br><span class="line"><span class="comment">	reason =&gt; &#123;</span></span><br><span class="line"><span class="comment">		throw reason    // 注意这里不是return reason 而是throw reason      throw保证了返回结果为失败</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>等价代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;)                                    <span class="comment">// 返回的Promise实例： Promise &#123;&lt;rejected&gt;:1&#125;</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value); <span class="comment">//没有指定失败的回调函数，不执行代码，去往下一级寻找失败状态回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, value); <span class="comment">//没有指定失败的回调函数，不执行代码，去往下一级寻找失败状态回调函数</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or 		by rejecting a promise which was not handled with .catch(). The promise rejected with the reason &quot;1&quot;.] &#123;</span></span><br><span class="line"><span class="comment">  	code: &#x27;ERR_UNHANDLED_REJECTION&#x27;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<blockquote>
<p>当使用<code>.catch</code>时，会默认为没有指定失败回调函数的<code>.then</code>添加一个失败回调函数【举例3，4】</p>
<p><code>.catch</code>所谓的值穿透并不是一个失败状态就触发<code>.catch</code>，而是一层层传递下来的【举例3，5】</p>
<p>异常穿透的前提是所有.then都没有执行失败状态的回调函数【举例3，5】</p>
<p>如果<code>.catch</code>前所有的<code>.then</code>都制定了失败状态的回调函数，<code>.catch</code>就失去了意义【举例2，4】</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u013448372/article/details/110863799">Promise 值穿透 特性</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>小众知识点</category>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
        <tag>异步编程</tag>
        <tag>小众知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>异步函数 | Promise基础和实例方法</title>
    <url>/2022/07/12/JavaScript/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0_Promise%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>ES6增加了对Promise&#x2F;A+规范的完善支持，即Promise实例</p>
</blockquote>
<h2 id="promise基础"><a href="#Promise基础" class="headerlink" title="Promise基础"></a>Promise基础</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br></pre></td></tr></table></figure>

<p>Promise可以通过new操作符来实例化，创建新Promise的时候需要传入执行器（executor）函数作为参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);   <span class="comment">// 这里使用一个空函数进行模拟</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)      <span class="comment">// Promise &lt;pending&gt; </span></span><br></pre></td></tr></table></figure>

<h3 id="promise状态"><a href="#Promise状态" class="headerlink" title="Promise状态"></a>Promise状态</h3><ul>
<li><p>Promise是一个有状态的对象，Promise可能处于如下状态</p>
<ul>
<li>待定（pending）</li>
<li>兑现（fulfilled或者rosolved）</li>
<li>拒绝（rejected）</li>
</ul>
</li>
<li><p>Promise的初始状态是Pending，在Pending状态下，Promise的状态可变为fulfilled或者rejected</p>
</li>
<li><p><strong>Promise的状态一经改变不可逆！！！</strong></p>
</li>
<li><p>Promise的状态是私有的，是不能直接通过JavaScript检测到的（这主要是为了避免根据读取到的Promise状态，以同步方式处理Promise对象）</p>
</li>
<li><p>Promise的也不能为外部JavaScript代码修改（Promise故意将异步行为封装起来，从而隔离外部的同步代码）</p>
</li>
</ul>
<h3 id="promise用途"><a href="#Promise用途" class="headerlink" title="Promise用途"></a>Promise用途</h3><h4 id="1改变状态"><a href="#（1）改变状态" class="headerlink" title="（1）改变状态"></a>（1）改变状态</h4><p>Promise可以用于抽象地表示一个异步操作，Promise的状态可以表示Promise是否完成，Promise的状态一经改变不可撤销和逆转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    <span class="title function_">rejece</span>();    <span class="comment">// 没有效果</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);  <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125; </span></span><br></pre></td></tr></table></figure>

<p>为了避免Promise卡在某个状态，可以添加一个定时器退出功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>();</span><br><span class="line">    &#125;, <span class="number">10000</span>);    <span class="comment">// 10秒后调用reject()</span></span><br><span class="line">    <span class="comment">// 执行函数的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p), <span class="number">0</span>);    <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p), <span class="number">11000</span>);  </span><br><span class="line"><span class="comment">// 10秒后输出 Uncaught (in promise) </span></span><br><span class="line"><span class="comment">// 11秒后输出 Promise &#123;&lt;rejected&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间</p>
<p>如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败（Nice！）</p>
<h4 id="2回调处理"><a href="#（2）回调处理" class="headerlink" title="（2）回调处理"></a>（2）回调处理</h4><p>Promise封装的异步操作会实际生成某个值，而程序期待Promise状态改变时可以访问这个值，相应地，如果Promise被拒绝，程序就会期待Promise状态改变时可以拿到拒绝的理由</p>
<blockquote>
<p>每个Promise只要状态改变为fulfilled，就会有一个私有的内部<strong>值</strong>（value）</p>
<p>每个Promise只要状态改变为rejected，就会有一个私有的内部<strong>理由</strong>（reason）</p>
</blockquote>
<p>无论是值还是理由，都是包含原始值或对象的不可修改的引用，二者都是可选的，而且默认值为<strong>undefined</strong></p>
<p>在Promise到达某个落定状态时执行的异步代码始终会收到这个值或理由</p>
<h3 id="通过执行函数控制promise状态"><a href="#通过执行函数控制Promise状态" class="headerlink" title="通过执行函数控制Promise状态"></a>通过执行函数控制Promise状态</h3><p>因为Promise的状态是私有的，所以只能在内部进行操作， 内部操作在Promise的执行器函数中完成</p>
<p>执行器函数主要有两大职责：</p>
<ul>
<li>初始化Promise的异步行为</li>
<li>控制状态的最终转换【<strong>调用resolve()和reject()实现</strong>】</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);     <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;   因为resolve并没有传入值，所以为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);     <span class="comment">// Promise &#123;&lt;rejected&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行器函数是同步执行的，因为执行器函数是Promise的初始化状态</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;executor&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise initialized&#x27;</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果Promise是同步执行的，打印结果为：</span></span><br><span class="line"><span class="comment">	executor</span></span><br><span class="line"><span class="comment">	promise initialized</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	如果Promise是异步执行的，打印结果为：</span></span><br><span class="line"><span class="comment">	promise initialized</span></span><br><span class="line"><span class="comment">	executor</span></span><br><span class="line"><span class="comment">*/</span>     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	实际打印结果为：</span></span><br><span class="line"><span class="comment">	executor</span></span><br><span class="line"><span class="comment">	promise initialized</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加setTimeout可以推迟切换状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<h3 id="promise静态方法"><a href="#Promise静态方法" class="headerlink" title="Promise静态方法"></a>Promise静态方法</h3><h4 id="1promiseresolve"><a href="#（1）Promise-resolve" class="headerlink" title="（1）Promise.resolve()"></a>（1）Promise.resolve()</h4><blockquote>
<p>Promise.resolve()可以实例化一个解决的Promise</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p1 和 p2 是等价的</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Promise.resolve()的参数对应着解决的Promise的值，Promise.resolve()可以把任何值都转换为一个Promise，传入的参数可能会有如下情况</p>
<ul>
<li><strong>定值 &#x3D;&gt; 解析或者包装后的Promise对象</strong></li>
<li><strong>Promise对象 &#x3D;&gt; Promise对象本身（相当于一个空包装）</strong>【幂等】</li>
<li><strong>thenable &#x3D;&gt; 返回的Promise会跟随着thenable对象，采用它的最终状态</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定值</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);         <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多余的参数会忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);         <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空包装</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3 === p2);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.resolve()可以包装任何非Promise的值，包括错误对象，并将其转换为解决的Promise</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可能会导致不符合预期的行为</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);   <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Error: foo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Promise.resolve()是一个幂等方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p === p2);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p === p3);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="2promisereject"><a href="#（2）Promise-reject" class="headerlink" title="（2）Promise.reject()"></a>（2）Promise.reject()</h4><blockquote>
<p>Promise.reject()可以实例化一个拒绝的Promise并抛出一个异步错误（这个错误不能通过try&#x2F;catch捕获，而只能通过拒绝处理程序捕获）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两个实例等价</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Promise.reject()的参数对应着拒绝的Promise的理由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">rereject</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);         <span class="comment">// Promise &#123;&lt;rejected&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.reject()不是一个幂等方法，如果给它传一个Promise，这个Promise会成为拒绝的理由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);   <span class="comment">// Uncaught (in promise) Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="promise同步-异步执行的二元性"><a href="#Promise同步、异步执行的二元性" class="headerlink" title="Promise同步、异步执行的二元性"></a>Promise同步、异步执行的二元性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);   <span class="comment">// Error:foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);     <span class="comment">// Uncaught (in promise) Error: bar</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个try&#x2F;catch没有捕获到错误是因为它没有通过<strong>异步模式</strong>捕获错误，这是什么意思呢？前面说过：<strong>Promise的状态是私有的，是不能直接通过JavaScript检测到的（这主要是为了避免根据读取到的Promise状态，以同步方式处理Promise对象）</strong>，拒绝Promise的错误并没有抛出到同步代码的线程里，所以try&#x2F;catch没有捕获到错误，准确地说，要捕获错误就需要用Promise的方法【下面就开始介绍Promise的方法】</p>
<h2 id="promise的实例方法"><a href="#Promise的实例方法" class="headerlink" title="Promise的实例方法"></a>Promise的实例方法</h2><h3 id="实现thenable接口"><a href="#实现Thenable接口" class="headerlink" title="实现Thenable接口"></a>实现Thenable接口</h3><blockquote>
<p>在ECMAScript 暴露的异步结构中，任何对象都有一个then()方法，这个方法被认为实现了Thenable 接口</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThenable</span> &#123;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="promiseprototypethen"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><blockquote>
<p>Promise.then()返回一个新的Promise实例</p>
<p>Promise.then()最多接收两个参数（可选）：<strong>onResloved处理程序</strong> 和 <strong>onRejected处理程序</strong>，分别在Promise进入“兑现”和“拒绝”状态时执行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onResolved</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onRejceted</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject&#x27;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="title function_">resolve</span>(), <span class="number">3000</span>))</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="title function_">reject</span>(), <span class="number">3000</span>))</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">onResolved</span>(<span class="string">&#x27;p1&#x27;</span>), </span><br><span class="line">       <span class="title function_">onRejceted</span>(<span class="string">&#x27;p1&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">onResolved</span>(<span class="string">&#x27;p2&#x27;</span>), </span><br><span class="line">       <span class="title function_">onRejceted</span>(<span class="string">&#x27;p2&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3秒后</span></span><br><span class="line"><span class="comment">// resolve p1</span></span><br><span class="line"><span class="comment">// reject p2</span></span><br></pre></td></tr></table></figure>

<p>因为Promise的状态不可撤销，所以这两个方法一定是<strong>互斥</strong>的</p>
<ul>
<li>传给then()的任何非函数类型的参数都会被忽略</li>
<li>如果只想提供onRejected参数，那么就要在onResolved的位置写上null或者undefined</li>
</ul>
<h4 id="1onresolve处理程序"><a href="#（1）onResolve处理程序" class="headerlink" title="（1）onResolve处理程序"></a>（1）onResolve处理程序</h4><ol>
<li><p>Promise.then()返回一个新的Promise实例，这个新Promise的实例是基于onResolved处理程序的返回值构建的，也就是说，该处理程序的返回值会通过Promise.resolve()去包装来生成新的Promise实例</p>
</li>
<li><p>那么onResolve()处理程序在不同情况下，Promise新实例的情况也不同，主要分为以下几种情况：</p>
<ul>
<li><p>没有提供onResolve处理程序 &#x3D;&gt; 会沿用上一个Promise</p>
</li>
<li><p>提供onResolved处理程序但是没有显式的返回语句 &#x3D;&gt; Promise.resolve()会包装默认返回值为undefined</p>
</li>
<li><p>提供onResolved处理程序且有有显式的返回语句 &#x3D;&gt; Promise.resolve()会包装这个<strong>值</strong>【根据不同值的情况，具体之前讲过了，可以看Promise.resolve()那块】</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);    <span class="comment">// 此时p1 为  Promise: &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有onResolved处理程序</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个打印p2，必须套上setTimeout，不知道为啥的请自觉补课Even loop</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br><span class="line">&#125;)    <span class="comment">// 会沿用上一个Promise p2 为  Promise: &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供onResolved处理程序但是没有显式的返回语句 ，Promise.resolve()会包装默认返回值为undefined</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 没有return</span></span><br><span class="line">&#125;, <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br><span class="line">&#125;)   <span class="comment">// 值为undefined  p3 为  Promise: &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供onResolved处理程序且有有显式的返回语句，  Promise.resolve()会包装这个值</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">4</span>, <span class="literal">null</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p4);</span><br><span class="line">&#125;) <span class="comment">// 值为4  p4 为  Promise: &#123;&lt;fulfilled&gt;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Promose</span>.<span class="title function_">resolve</span>(<span class="number">5</span>), <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p5);</span><br><span class="line">&#125;)<span class="comment">// 值为5  p5 为  Promise: &#123;&lt;fulfilled&gt;: 5&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><code>onResolved</code>处理程序遇到错误，分为两种情况</p>
<ul>
<li><p>抛出异常 &#x3D;&gt; 返回拒绝的<code>Promise</code></p>
</li>
<li><p>返回错误值 &#x3D;&gt; 不会拒绝而是会把错误值包装成一个解决的<code>Promise</code></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="number">2</span>)&#125;);   <span class="comment">// Uncaught (in promise) Error: 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="number">3</span>));      <span class="comment">// p3是一个新的Promise Promise &#123;&lt;fulfilled&gt;: new Error(3)&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2onreject处理程序"><a href="#（2）onReject处理程序" class="headerlink" title="（2）onReject处理程序"></a>（2）onReject处理程序</h4><ol>
<li><code>onRejected</code>处理程序返回的值也会被<code>Promise.resolve()</code>包装，在捕获错误后不抛出异常，而是返回一个解决的<code>Promise</code></li>
<li><code>onRejeced</code>处理程序在不同情况下，<code>Promise</code>新实例的情况也不同，主要分为以下几种情况：<ul>
<li>没有提供onRejected处理程序 &#x3D;&gt; 会沿用上一个Promise</li>
<li>提供onRejected处理程序但是没有显式的返回语句 &#x3D;&gt; Promise.resolve()会包装默认返回值为undefined</li>
<li>提供onRejected处理程序且有有显式的返回语句 &#x3D;&gt;Promise.resolve()会包装这个<strong>原因</strong></li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);    <span class="comment">// 此时p1 为  Promise: &#123;&lt;rejected&gt;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有onRejected处理程序</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br><span class="line">&#125;)    <span class="comment">// 会沿用上一个Promise p2 为  Promise: &#123;&lt;rejected&gt;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供onRejected处理程序但是没有显式的返回语句 ， Promise.resolve()会包装默认返回值为undefined</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 没有return</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br><span class="line">&#125;)   <span class="comment">// 原因为undefined  p3 为  Promise: &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供onRejected处理程序且有有显式的返回语句，  Promise.resolve()会包装这个原因</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="number">4</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p4);</span><br><span class="line">&#125;) <span class="comment">// 原因为4  p4 为  Promise: &#123;&lt;fulfilled&gt;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Error</span>(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p5);</span><br><span class="line">&#125;)<span class="comment">// 原因为5  p5 为  Promise: &#123;&lt;fulfilled&gt;: Error(5)&#125;</span></span><br></pre></td></tr></table></figure>

<p>补课：<a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.then/">手写原理 | Promise.then</a></p>
<h3 id="promiseprototypecatch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>Promise.prototype.catch()</code>方法用于给期约添加拒绝处理程序</p>
<p>这个方法只接收一个参数：<code>onRejected</code> 处理程序</p>
<p>事实上，这个方法就是一个语法糖，调用它就相当于调用<code>Promise.prototype.then(null, onRejected)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两者处理是一样的</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);   <span class="comment">// rejected</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">catch</span>(onRejected);        <span class="comment">// rejected</span></span><br></pre></td></tr></table></figure>

<p>Promise.catch()返回一个新的Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">catch</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p1)    <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p2)    <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 === p2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>在返回新期约实例方面，<code>Promise.prototype.catch()</code>的行为与<code>Promise.prototype.then()</code>的<code>onRejected</code> 处理程序是一样的</p>
<h3 id="promiseprototypefinally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><blockquote>
<p>Promise.prototype.finally()方法用于给期约添加onFinally 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行</p>
</blockquote>
<ol>
<li>onFinally 处理程序无法知道Promise的状态是fulfilled还是rejected，所以这个方法主要用于清理代码</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> onFinally = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finally&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">finally</span>(onFinally);   <span class="comment">// &#x27;Finally&#x27;</span></span><br><span class="line">p2.<span class="title function_">finally</span>(onFinally);   <span class="comment">// &#x27;Finally&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Promise.prototype.finally()返回一个新的Promise实例</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">finally</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 === p2);   <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>onFinally 处理程序和 onResolved和onRejected不同，因为onFinally被设计为一个<strong>状态无关</strong>的方法，所以在大多数情况下它将表现为父Promise的传递</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下的情况都会往后面传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">finally</span>();</span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line"><span class="keyword">let</span> p6 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> p8 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p2), <span class="number">0</span>);  <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p3), <span class="number">0</span>);  <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p4), <span class="number">0</span>);  <span class="comment">// Promise &lt;resolved&gt;: foo  </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p5), <span class="number">0</span>);  <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p6), <span class="number">0</span>);  <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p7), <span class="number">0</span>);  <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p8), <span class="number">0</span>);  <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p9), <span class="number">0</span>);  <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果返回的是一个待定的<code>Promise</code>，或者<code>onFinally</code>处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p10 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>());</span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p11 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br></pre></td></tr></table></figure>

<h3 id="非重入promise方法"><a href="#非重入Promise方法" class="headerlink" title="非重入Promise方法"></a>非重入Promise方法</h3><blockquote>
<p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行</p>
<p>跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行</p>
<p>即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的</p>
<p>这个特性由JavaScript 运行时保证，被称为“非重入”（non-reentrancy）特性</p>
</blockquote>
<p>感觉这部分只要搞清楚Even Loop就可以了，所以这里略过~</p>
<h3 id="邻近处理程序的执行顺序"><a href="#邻近处理程序的执行顺序" class="headerlink" title="邻近处理程序的执行顺序"></a>邻近处理程序的执行顺序</h3><blockquote>
<p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行</p>
<p>无论是then()、catch()还是finally()添加的处理程序都是如此</p>
</blockquote>
<p>这个执行顺序主要是遵循了队列的先进先出原则，掠过~</p>
<h3 id="传递解决值和拒绝理由"><a href="#传递解决值和拒绝理由" class="headerlink" title="传递解决值和拒绝理由"></a>传递解决值和拒绝理由</h3><blockquote>
<p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序</p>
<p>拿到返回值后，就可以进一步对这个值进行操作</p>
<p>在执行函数中，解决的值和拒绝的理由是分别作为resolve()和reject()的第一个参数往后传的，然后，这些值又会传给它们各自的处理程序，作为onResolved 或onRejected 处理程序的唯一参数</p>
</blockquote>
<img src="/2022/07/12/JavaScript/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0_Promise%E5%9F%BA%E7%A1%80/promises.png" class title="promises">

<p>把这张图理顺~问题不大</p>
<h3 id="拒绝promise和拒绝错误处理"><a href="#拒绝Promise和拒绝错误处理" class="headerlink" title="拒绝Promise和拒绝错误处理"></a>拒绝Promise和拒绝错误处理</h3><p>拒绝期约类似于<code>throw()</code>表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理</p>
<ol>
<li>在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>期约可以以任何理由拒绝，包括<code>undefined</code>，但最好统一使用错误对象，这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的</p>
</li>
<li><p>异步错误只能通过异步的onRejected处理程序进行处理【还记得之前说的：Promise的状态是私有的】</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>then()</code>和<code>catch()</code>的<code>onRejected </code>处理程序在语义上相当于<code>try/catch</code>，出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行，为此，onRejected 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;begin synchronous execution&#x27;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;continue synchronous execution&#x27;</span>);</span><br><span class="line"><span class="comment">// begin synchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: foo</span></span><br><span class="line"><span class="comment">// continue synchronous execution</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;begin asynchronous execution&#x27;</span>);</span><br><span class="line">	<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;continue asynchronous execution&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// begin asynchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: bar</span></span><br><span class="line"><span class="comment">// continue asynchronous execution</span></span><br></pre></td></tr></table></figure>

<p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.finally/">手写原理 | Promise.finally</a></p>
<h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise/">手写原理 | Promise</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.then/">手写原理 | Promise.then</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.finally/">手写原理 | Promise.finally</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://promisesaplus.com/">Promises&#x2F;A+</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>异步函数 | Promise连锁和合成</title>
    <url>/2022/07/12/JavaScript/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0_Promise%E8%BF%9E%E9%94%81%E4%B8%8E%E5%90%88%E6%88%90/</url>
    <content><![CDATA[<h3 id="期约连锁"><a href="#期约连锁" class="headerlink" title="期约连锁"></a>期约连锁</h3><p>因为每个<code>Promise</code>实例的方法（<code>then()</code> <code>catch()</code> <code>finally()</code>）都可以返回一个<code>Promise</code>实例，新的<code>Promise</code>实例又有自己的实例方法，这样连缀的方法调用就可以构成所谓的“期约连锁“，也就是平时说的链式调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1 executor&#x27;</span>);</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 executor&#x27;</span>);</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3 executor&#x27;</span>);</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p4 executor&#x27;</span>);</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure>

<p>把生成期约的代码提取到一个工厂函数中，就可以简洁代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delayedResolved</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">delayedResolve</span>(<span class="string">&#x27;p1 executor&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p2 executor&#x27;</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p3 executor&#x27;</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&#x27;p4 executor&#x27;</span>))</span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure>

<p>期约连锁很好地解决了回调地狱的问题</p>
<h3 id="promise图"><a href="#Promise图" class="headerlink" title="Promise图"></a>Promise图</h3><p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建<strong>有向非循环图</strong>的结构</p>
<p>这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点</p>
<p>因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// / \</span></span><br><span class="line"><span class="comment">// B C</span></span><br><span class="line"><span class="comment">// /\ /\</span></span><br><span class="line"><span class="comment">// D E F G</span></span><br><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	<span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> B = A.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> C = A.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;C&#x27;</span>));</span><br><span class="line"></span><br><span class="line">B.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;D&#x27;</span>));</span><br><span class="line">B.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;E&#x27;</span>));</span><br><span class="line">C.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">C.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;G&#x27;</span>));</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// E</span></span><br><span class="line"><span class="comment">// F</span></span><br><span class="line"><span class="comment">// G</span></span><br></pre></td></tr></table></figure>

<h3 id="重点promise合成"><a href="#（重点）Promise合成" class="headerlink" title="（重点）Promise合成"></a>（重点）Promise合成</h3><h4 id="1promiseall"><a href="#（1）Promise-all" class="headerlink" title="（1）Promise.all()"></a>（1）<code>Promise.all()</code></h4><p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.all/">手写原理 | Promise.all</a></p>
<blockquote>
<p><code>Promise.all()</code>静态方法创建的期约会在一组期约全部解决之后再解决</p>
</blockquote>
<ol>
<li><code>Promise.all()</code>法接收一个可迭代对象，返回一个新Promise</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">reslove</span>(),</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都是在手写的时候要注意的！！！！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于Promise.resolve()</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">all</span>();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Promise.all只会在每个包含Promise都解决之后才会解决</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;all() resolved!&#x27;</span>));</span><br><span class="line"><span class="comment">// all() resolved!（大约1 秒后）</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果至少一个包含的Promise待定，则合成的Promise也会待定</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果有一个包含的Promise拒绝，则最终合成的Promise也会拒绝</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次拒绝会导致最终期约拒绝</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">reject</span>(),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) undefined</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果所有的Promise都解决，则合成的Promise的解决值就是所有Promise解决值的数组，<strong>顺序按照迭代顺序</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">values</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, values)); <span class="comment">// [3, undefined, 4]</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由，之后再拒绝的期约不会影响最终期约的拒绝理由，不过，这并不影响所有包含期约正常的拒绝操作，合成的期约会静默处理所有包含期约的拒绝操作</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入</span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>),</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure>

<h4 id="2promiserace"><a href="#（2）Promise-race" class="headerlink" title="（2）Promise.race()"></a>（2）<code>Promise.race()</code></h4><blockquote>
<p><code>Promise.race()</code>静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像</p>
</blockquote>
<ol>
<li><code>Promise.race()</code>接收一个可迭代数组，返回一个新的Promise</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于new Promise(() =&gt; &#123;&#125;)</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">race</span>();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>Promise.race()</code>不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，<code>Promise.race()</code>就会包装其解决值或拒绝理由并返回新期约</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>),</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">4</span>),</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">5</span>),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由，之后再拒绝的期约不会影响最终期约的拒绝理由，不过，这并不影响所有包含期约正常的拒绝操作，与<code>Promise.all()</code>类似，合成的期约会静默处理所有包含期约的拒绝操作</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入</span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>),</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure>

<h3 id="串行promise合成"><a href="#串行Promise合成" class="headerlink" title="串行Promise合成"></a>串行Promise合成</h3><blockquote>
<p><code>Promise</code>的一个主要特性是：异步产生值并将其传给处理程序，基于后续期约使用之前期约的返回值来串联期约是期约的基本功能</p>
</blockquote>
<p>参考函数合成，我们也可以将<code>Promise</code>进行合成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x)</span><br><span class="line">		.<span class="title function_">then</span>(addTwo)</span><br><span class="line">		.<span class="title function_">then</span>(addThree)</span><br><span class="line">		.<span class="title function_">then</span>(addFive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">8</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>reduce</code>改进</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [addTwo, addThree, addFive].<span class="title function_">reduce</span>(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.<span class="title function_">then</span>(fn), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>提炼出通用函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.<span class="title function_">then</span>(fn), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addTen = <span class="title function_">compose</span>(addTwo, addThree, addFive);</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">8</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.all/">手写原理 | Promise.all</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.race/">手写原理 | Promise.race</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/10/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_Promise.allSelected/">手写原理 | Promise.allSelected</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://promisesaplus.com/">Promises&#x2F;A+</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>异步函数 | forEach遇上await</title>
    <url>/2022/07/22/JavaScript/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0_forEach%E9%81%87%E4%B8%8Aawait/</url>
    <content><![CDATA[<p>forEach和await我们都不陌生</p>
<p>其中，forEach是JS中Array的API，用于遍历数组中的元素，并且可以传入一个回调函数去修改数组中的每一项，特点是没有返回值【不能用return，也不能用break跳出循环】，且会修改原数组</p>
<p>await是异步函数async&#x2F;await发挥主要作用的标识符，用于阻塞代码的执行，实现异步效果</p>
<p>那么，forEach遇上await会擦出怎样的火花呢？</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>看下面的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNumber</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果为一个Promise实例</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Promise &#123;&lt;fulfilled&gt;: [1,2,3]&#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multi</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(num * num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;num not specified&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nums = <span class="keyword">await</span> <span class="title function_">getNumber</span>();  <span class="comment">// await解包：如果表达式是 promise 对象, await 返回的是 promise 成功的值</span></span><br><span class="line">    <span class="comment">// nums是一个数组[1,2,3]</span></span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="keyword">async</span> item =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">multi</span>(item);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<p>我们期望的打印结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1秒后</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1秒后</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1秒后</span></span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>实际的打印结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1秒后</span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>说明，forEach里面的回调函数并没有异步执行，而是同步执行的</p>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>在上面这个例子中，我们给forEach的回调函数套上了async&#x2F;await，使其具有异步函数的功能，我们期望其可以串行执行函数，但实际却是并行执行了</p>
<p><code>forEach</code> 的 polyfill 参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">MDN-Array.prototype.forEach()</a>，可以帮助我们理解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span> = <span class="keyword">function</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="comment">// this指代调用forEach的array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 回调函数的三个参数：index，item，array</span></span><br><span class="line">        <span class="title function_">cb</span>(index, <span class="variable language_">this</span>[index], <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以得知，forEach只是简单地执行了回调函数而已，而不会去处理异步的情况</p>
<p>test函数可以修改为等价的代码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nums = <span class="keyword">await</span> <span class="title function_">getNumber</span>();   <span class="comment">// nums为 [1,2,3]</span></span><br><span class="line"> 	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        (<span class="keyword">async</span> item =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">multi</span>(item);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">        &#125;)(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以得知：forEach中异步函数是并行执行，导致了一次性全部输出结果：1，4，9</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="方式一for循环"><a href="#方式一：for循环" class="headerlink" title="方式一：for循环"></a>方式一：for循环</h4><p>通过改造forEach，确保每一个异步的回调执行之后再去执行下一个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncForEach</span>(<span class="params">array, cb</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">cb</span>(array[i], i, array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nums = <span class="keyword">await</span> <span class="title function_">getNumber</span>();   <span class="comment">// nums为 [1,2,3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">asyncForEach</span>(nums, <span class="keyword">async</span> item =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">multi</span>(item);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式二forof"><a href="#方式二：for…of" class="headerlink" title="方式二：for…of"></a>方式二：for…of</h4><p>for…of用于遍历可迭代对象，先调用可迭代对象的迭代器方法<code>[Symbol.iterator]()</code>方法，该方法返回一个迭代器对象，对象内部包含next()方法，然后调用迭代器对象上的next方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nums = <span class="keyword">await</span> <span class="title function_">getNumber</span>();   <span class="comment">// nums为 [1,2,3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">multi</span>(num);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码等价于下列代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nums = <span class="keyword">await</span> <span class="title function_">getNumber</span>();   <span class="comment">// nums为 [1,2,3]</span></span><br><span class="line">    <span class="keyword">let</span> iterator = nums[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();   </span><br><span class="line">    <span class="keyword">let</span> objIterator = iterator.<span class="title function_">next</span>();   <span class="comment">// &#123;value: xxx, done: true || false&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!objIterator.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = objIterator.<span class="property">value</span>;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">multi</span>(num);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">        objIterator = iterator.<span class="title function_">next</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://objcer.com/2017/10/12/async-await-with-forEach/">当 async&#x2F;await 遇上 forEach</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">MDN-Array.prototype.forEach()</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>循环语句 | for-in&amp;&amp;for-of的区别</title>
    <url>/2022/07/05/JavaScript/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5_for-in&amp;&amp;for-of%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="forof"><a href="#for…of" class="headerlink" title="for…of.."></a>for…of..</h2><p>for…of用于遍历可迭代对象的元素，在可迭代对象上创建一个迭代循环，调用自定义迭代钩子的next()方法来遍历元素，是有序遍历</p>
<h2 id="forin"><a href="#for…in" class="headerlink" title="for…in.."></a>for…in..</h2><p>for…in用于枚举对象中的属性（包括原型链上的可枚举属性），是无序遍历</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);   <span class="comment">// name age gender</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据打印结果可以看到 for...in枚举原型链上的属性，那么如何改进呢？使用hasOwnProperty</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">gender</span> = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key)   <span class="comment">// name age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
        <category>常见方法对比</category>
      </categories>
      <tags>
        <tag>常见方法对比</tag>
        <tag>JavaScript</tag>
        <tag>JavaScript语句</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程 | async/await</title>
    <url>/2022/07/14/JavaScript/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B_async%20await/</url>
    <content><![CDATA[<blockquote>
<p>ES8提出的async&#x2F;await关键词旨在解决利用异步结构组织代码的问题</p>
</blockquote>
<h3 id="异步函数基础"><a href="#异步函数基础" class="headerlink" title="异步函数基础"></a>异步函数基础</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><blockquote>
<p>async关键字用于声明异步函数</p>
</blockquote>
<ol>
<li>async关键字可以在函数声明、函数表达式、箭头函数、函数方法上使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数方法</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用async关键字可以让函数具有<strong>异步特征</strong>，但总体上函数仍然是<strong>同步求值</strong>的，在参数或者闭包方面，异步函数仍然具有普通JavaScript函数的正常行为</p>
</li>
<li><p><strong>异步函数始终返回Promise对象</strong></p>
<ul>
<li>如果异步函数内部有显式的return语句并且返回值（没有return 值就是undefined），这个值会被Promise.resolve()包装成一个Promsie对象</li>
<li>如果异步函数直接return一个Promise对象，异步函数返回值就是那个Promise对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给返回的promise添加一个then方法的解决处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1   这个是foo()调用得到的</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3   这个是then()处理的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1   这个是foo()调用得到的</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3   这个是then()处理的结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>异步函数的返回值期待一个实现<code>thenable</code>接口的对象，但常规值也可以</p>
<ul>
<li>如果返回的是实现<code>thenable</code>接口的对象，则这个对象可以由提供给<code>then()</code>的处理程序“解包”</li>
<li>如果不是，则返回子和就被当作已解决的Promise</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value));    <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个没有实现thenable接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>().<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value));   <span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个实现thenabke接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">        <span class="title function_">then</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> thenable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">baz</span>().<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value));   <span class="comment">// &#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在异步函数中抛出错误会返回拒绝的Promise</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;                         <span class="comment">// foo为 Promise&#123;&lt;rejected&gt;:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1   foo()的结果</span></span><br><span class="line"><span class="comment">// 3   catch()的结果</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>拒绝Promise的错误不会被异步函数捕获</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): 3</span></span><br></pre></td></tr></table></figure>

<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><blockquote>
<p>await关键词可以暂停异步函数代码的执行，等待Promise的解决</p>
</blockquote>
<ol>
<li><p><code>await</code>可以单独使用也可以在表达式中使用</p>
</li>
<li><p><code>await</code> 关键字会暂停执行异步函数后面的代码，让出<code>JavaScript</code> 运行时的执行线程，这个行为与生成器函数中的<code>yield </code>关键字是一样的，<code>await </code>关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行</p>
</li>
<li><p><code>await</code>关键字期待（但实际上并不要求）一个实现thenable 接口的对象，但常规的值也可以，如果是实现thenable 接口的对象，则这个对象可以由await 来“解包”，如果不是，则这个值就被当作已经解决的Promise</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待一个没有实现thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> [<span class="string">&#x27;bar&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待一个实现了thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> thenable = &#123;</span><br><span class="line">		<span class="title function_">then</span>(<span class="params">callback</span>) &#123; <span class="title function_">callback</span>(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> thenable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">baz</span>();</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">qux</span>();</span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>await</code>会抛出错误的同步操作，会返回拒绝的Promise</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> (<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> <span class="number">3</span>&#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>对拒绝的<code>Promise</code>使用<code>await</code>则会释放（<code>unwrap</code>）错误值（将拒绝Promise返回）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);    <span class="comment">// 这行代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>await关键字有一定限制</p>
<ul>
<li>await关键字必须在异步函数中使用，不能在顶级上下文如<script>标签或模块中使用</li>
<li>异步函数的特质不会扩展到嵌套函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许：await 出现在了箭头函数中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">syncFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 不允许：await 出现在了同步函数声明中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">syncFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许：await 出现在了同步函数表达式中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> syncFn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许：IIFE 使用同步函数表达式或箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;</span><br><span class="line">	(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>)); &#125;)();</span><br><span class="line">	(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>)))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="停止与恢复执行"><a href="#停止与恢复执行" class="headerlink" title="停止与恢复执行"></a>停止与恢复执行</h3><blockquote>
<p>async/await中真正起作用的是await关键词</p>
</blockquote>
<p>红宝书第四版中是这么说的：JavaScript 运行时在碰到await 关键字时，会记录在哪里暂停执行，等到await 右边的值可用了，JavaScript 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行</p>
<p>我理解的层面是：async/await相当于promise + generator 的<em>语法糖</em>，所以我会把await关键词所在语句后面的语句全部认为是添加到.then语句中，比如说，下面的代码我可以进行改写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果为：</span></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不好理解，可以进行改写</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">null</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果为：</span></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>await在Even Loop相关的题中经常遇到，要孰能生巧啦~</p>
<h3 id="异步函数策略"><a href="#异步函数策略" class="headerlink" title="异步函数策略"></a>异步函数策略</h3><h4 id="（1）实现sleep"><a href="#（1）实现sleep" class="headerlink" title="（1）实现sleep()"></a>（1）实现sleep()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - t0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	改写：流程可以改写为这样</span></span><br><span class="line"><span class="comment">	function foo() &#123;</span></span><br><span class="line"><span class="comment">		const t0 = Date.now();</span></span><br><span class="line"><span class="comment">		sleep(1500).then(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">			console.log(Date.now() - t0);</span></span><br><span class="line"><span class="comment">		&#125;)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();   <span class="comment">// 1511</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）利用平行执行"><a href="#（2）利用平行执行" class="headerlink" title="（2）利用平行执行"></a>（2）利用平行执行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> is finished`</span>);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, delay))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - t0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	0 is finished</span></span><br><span class="line"><span class="comment">    1 is finished</span></span><br><span class="line"><span class="comment">    2 is finished</span></span><br><span class="line"><span class="comment">    3 is finished</span></span><br><span class="line"><span class="comment">    4 is finished</span></span><br><span class="line"><span class="comment">    2230</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>用for循环进行改进</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> is finished`</span>);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, delay))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">randomDelay</span>(i)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - t0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	0 is finished</span></span><br><span class="line"><span class="comment">	1 is finished</span></span><br><span class="line"><span class="comment">	2 is finished</span></span><br><span class="line"><span class="comment">	3 is finished</span></span><br><span class="line"><span class="comment">	4 is finished</span></span><br><span class="line"><span class="comment">	2078</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果顺序不需要保证，还可以先一次性初始化所有Promise，再分别等待结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line"><span class="comment">// 延迟0~1000 毫秒</span></span><br><span class="line">	<span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">		<span class="title function_">resolve</span>();</span><br><span class="line">	&#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	const p0 = randomDelay(0);</span></span><br><span class="line"><span class="comment">        const p1 = randomDelay(1);</span></span><br><span class="line"><span class="comment">        const p2 = randomDelay(2);</span></span><br><span class="line"><span class="comment">        const p3 = randomDelay(3);</span></span><br><span class="line"><span class="comment">        const p4 = randomDelay(4);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> promises = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="title function_">randomDelay</span>(i));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	await p0;</span></span><br><span class="line"><span class="comment">    	await p1;</span></span><br><span class="line"><span class="comment">    	await p2;</span></span><br><span class="line"><span class="comment">    	await p3;</span></span><br><span class="line"><span class="comment">    	await p4;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        <span class="keyword">await</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	4 finished</span></span><br><span class="line"><span class="comment">    3 finished</span></span><br><span class="line"><span class="comment">    2 finished</span></span><br><span class="line"><span class="comment">    1 finished</span></span><br><span class="line"><span class="comment">    0 finished</span></span><br><span class="line"><span class="comment">    851ms elapsed</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要注意的是：虽然Promise没有按照顺序执行，但是await是按顺序收到每一个Promise的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）串行执行Promise：用await改进Promise连锁"><a href="#（3）串行执行Promise：用await改进Promise连锁" class="headerlink" title="（3）串行执行Promise：用await改进Promise连锁"></a>（3）串行执行Promise：用await改进Promise连锁</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">        x = <span class="keyword">await</span> <span class="title function_">fn</span>(x);            <span class="comment">// 尽管fn(x)是一个Promise但是await会解包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">9</span>).<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(val));   <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<h4 id="（4）栈追踪与内存管理"><a href="#（4）栈追踪与内存管理" class="headerlink" title="（4）栈追踪与内存管理"></a>（4）栈追踪与内存管理</h4><blockquote>
<p>栈追踪信息应该相当直接地表现JavaScript 引擎当前栈内存中函数调用之间的嵌套关系</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br><span class="line"><span class="comment">// setTimeout (async)</span></span><br><span class="line"><span class="comment">// fooPromiseExecutor</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 引擎会在创建期约时尽可能保留完整的调用栈，在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中，这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本</p>
<p>如果在前面的例子中使用的是异步函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// async function (async)</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p><code>fooPromiseExecutor()</code>已经返回，所以它不在错误信息中，但<code>foo()</code>此时被挂起了，并没有退出，JavaScript 运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样，这个指针实际上存储在内存中，可用于在出错时生成栈追踪信息，这样就不会像之前的例子那样带来额外的消耗，因此在重视性能的应用中是可以优先考虑的</p>
</script></li></ul></li></ol>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起读红宝书</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作符 | 逗号操作符</title>
    <url>/2022/07/05/JavaScript/%E6%93%8D%E4%BD%9C%E7%AC%A6_%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p>逗号操作符常用场景：</p>
<h3 id="场景1在一条语句中执行多个操作"><a href="#场景1：在一条语句中执行多个操作" class="headerlink" title="场景1：在一条语句中执行多个操作"></a>场景1：在一条语句中执行多个操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="场景2-辅助赋值"><a href="#场景2：-辅助赋值" class="headerlink" title="场景2： 辅助赋值"></a>场景2： 辅助赋值</h3><blockquote>
<p>在赋值的时候使用逗号操作符分隔值，最终会返回表达式中<strong>最后一个值</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span>);   <span class="comment">// num的值为0</span></span><br></pre></td></tr></table></figure>

<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">10</span>, j &lt; <span class="number">6</span>; i++, j++) &#123;</span><br><span class="line">	<span class="keyword">let</span> k  = i + j;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i, j, k)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	i j k</span></span><br><span class="line"><span class="comment">	0 0 0</span></span><br><span class="line"><span class="comment">	1 1 2</span></span><br><span class="line"><span class="comment">	2 2 4</span></span><br><span class="line"><span class="comment">	3 3 6</span></span><br><span class="line"><span class="comment">	4 4 8</span></span><br><span class="line"><span class="comment">	5 5 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">6</span>, j &lt; <span class="number">10</span>; i++, j++) &#123;</span><br><span class="line">	<span class="keyword">let</span> k  = i + j;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i, j, k)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    i j k</span></span><br><span class="line"><span class="comment">    0 0 0</span></span><br><span class="line"><span class="comment">    1 1 2</span></span><br><span class="line"><span class="comment">    2 2 4</span></span><br><span class="line"><span class="comment">    3 3 6</span></span><br><span class="line"><span class="comment">    4 4 8</span></span><br><span class="line"><span class="comment">    5 5 10</span></span><br><span class="line"><span class="comment">    6 6 12</span></span><br><span class="line"><span class="comment">    7 7 14</span></span><br><span class="line"><span class="comment">    9 9 18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>为什么会出现这样的情况？</p>
<p>当有多个条件之间用；隔开时，会返回<strong>最右侧</strong>的条件</p>
<p>如果需要两个要求同时满足，应该把；改为&amp;&amp;</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>小众知识点</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小众知识点</tag>
        <tag>JavaScript操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型 | 原始值包装类型</title>
    <url>/2022/07/06/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>红宝书第四版P113：为了方便操作原始值，ECMAScript 提供了3 种特殊的引用类型：Boolean、Number 和String</p>
</blockquote>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><ul>
<li>装箱：将基本数据类型转换为对应的引用数据类型（分为隐式装箱和显式装箱）<ul>
<li>隐式装箱：当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象</li>
<li>显式装箱：通过 <code>new 包装类型</code>的方式进行转换</li>
</ul>
</li>
<li>拆箱：将引用数据类型转换为基本数据类型</li>
</ul>
<p>看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;someText&#x27;</span>;    <span class="comment">// 后台偷偷操作了，隐式！</span></span><br><span class="line"><span class="keyword">var</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p><code>s1</code>是一个保存字符串的变量，是一个原始值，在第二行调用了调用了<code>substring()</code>方法，并把结果保存在<code>s2 </code>中。原始值本身不是一个对象，照理说不应该有方法，但是事实确实调用方法成功了。实际上，当第二行访问<code>s1</code> 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3 步：</p>
<ul>
<li>创建一个String 类型的实例；</li>
<li>调用实例上的特定方法</li>
<li>销毁实例</li>
</ul>
<p>以上3步可抽象为下列代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;someText&#x27;</span>);    <span class="comment">// new 了， 显式！</span></span><br><span class="line"><span class="keyword">var</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;    <span class="comment">// 这一步不可忽略，实例必须销毁</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子我们不难看出：</p>
<blockquote>
<p>引用类型与原始值包装类型的主要区别在于<strong>对象的生命周期</strong></p>
<p>具体来说：在通过new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间，这意味着不能在运行时给原始值添加属性和方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">color</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>创建原始值包装类型【装箱】的方式有：</p>
<ul>
<li>显式地使用Boolean、Number 和String 构造函数创建原始值包装对象</li>
<li>Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：使用new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样（<strong>注意区分转型函数和构造函数</strong>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;25&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="title class_">Number</span>(value); <span class="comment">// 转型函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> number); <span class="comment">// &quot;number&quot;   转型函数的类型检测为原始值类型</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Number</span>(value); <span class="comment">// 构造函数   </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj); <span class="comment">// &quot;object&quot;      原始值包装类型检测为object</span></span><br></pre></td></tr></table></figure>

<h2 id="boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><blockquote>
<p>Boolean 是对应布尔值的引用类型</p>
</blockquote>
<h3 id="创建boolean对象"><a href="#创建Boolean对象" class="headerlink" title="创建Boolean对象"></a>创建Boolean对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="boolean实例的变化"><a href="#Boolean实例的变化" class="headerlink" title="Boolean实例的变化"></a>Boolean实例的变化</h3><blockquote>
<p>Boolean实例重写<code>valueOf()</code>方法，返回一个原始值<code>true</code>或者<code>false</code>，<code>toString()</code>方法被调用时也会被覆盖，返回字符串<code>&#39;&#39;true&#39;&#39;</code>或者<code>&#39;&#39;false&#39;&#39;</code></p>
</blockquote>
<p>看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);     <span class="comment">// 包装了一个值为false的Boolean对象</span></span><br><span class="line"><span class="keyword">let</span> res = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对于res的打印结果，可能会有点懵</span></span><br><span class="line"><span class="comment">	回顾下上面的内容，我们要知道typeof new Boolean(false) === &#x27;object&#x27;,在布尔表达式中，所有的对象都会转化为true</span></span><br><span class="line"><span class="comment">	这里注意区分，原始布尔表达式中 false &amp;&amp; true 等于 false，但本例子中 实际是 true &amp;&amp; true 自然为 true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="boolean对象与原始布尔值的区别"><a href="#Boolean对象与原始布尔值的区别" class="headerlink" title="Boolean对象与原始布尔值的区别"></a>Boolean对象与原始布尔值的区别</h3><ul>
<li>typeof返回不一样</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> falseObject;    <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> falseValue;     <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<ul>
<li>instanceof检测不一样</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> falseObject;    <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> falseValue;     <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line">falseObject <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>   <span class="comment">// true</span></span><br><span class="line">falseValue <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	因为Boolean对象是Boolean类型的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><blockquote>
<p>Number 是对应数值的引用类型</p>
</blockquote>
<h3 id="创建number对象"><a href="#创建Number对象" class="headerlink" title="创建Number对象"></a>创建Number对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="number实例的变化"><a href="#Number实例的变化" class="headerlink" title="Number实例的变化"></a>Number实例的变化</h3><blockquote>
<p>Number实例重写<code>valueOf()</code>方法，<code>toString()</code>方法和<code>toLocaleString()</code>方法</p>
<p><code>valueOf()</code>方法返回<code>Number </code>对象表示的原始数值，另外两个方法返回数值字符串</p>
<p><code>toString()</code>方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>()); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">8</span>)); <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">10</span>)); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="number类型新方法"><a href="#Number类型新方法" class="headerlink" title="Number类型新方法"></a>Number类型新方法</h3><h4 id="数值格式化为字符串"><a href="#数值格式化为字符串" class="headerlink" title="数值格式化为字符串"></a>数值格式化为字符串</h4><h5 id="tofix"><a href="#toFix" class="headerlink" title="toFix()"></a>toFix()</h5><blockquote>
<p><code>toFixed()</code>方法返回包含指定小数点位数的数值字符串，接受一个参数表示小数位数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// &quot;10.00&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="toexponential"><a href="#toExponential" class="headerlink" title="toExponential()"></a>toExponential()</h5><blockquote>
<p><code>toExponential()</code>，返回以科学记数法（也称为指数记数法）表示的数值字符串，接受一个参数表示小数位数</p>
</blockquote>
<h5 id="toprecision"><a href="#toPrecision" class="headerlink" title="toPrecision()"></a>toPrecision()</h5><blockquote>
<p><code>toPrecision()</code>方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式</p>
<p>这个方法接收一个参数，表示结果中数字的总位数（不包含指数）</p>
</blockquote>
<h4 id="isinteger"><a href="#isInteger" class="headerlink" title="isInteger()"></a>isInteger()</h4><blockquote>
<p><code>ES6</code> 新增了<code>Number.isInteger()</code>方法，用于辨别一个数值是否保存为整数</p>
</blockquote>
<h4 id="issafeinteger"><a href="#isSafeInteger" class="headerlink" title=".isSafeInteger()"></a>.isSafeInteger()</h4><blockquote>
<p>IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从Number.MIN_SAFE_INTEGER（-2^53 + 1）到Number.MAX_SAFE_INTEGER（2^53 - 1）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用Number.isSafeInteger()方法</p>
</blockquote>
<h3 id="number对象与原始数值的区别"><a href="#Number对象与原始数值的区别" class="headerlink" title="Number对象与原始数值的区别"></a>Number对象与原始数值的区别</h3><ul>
<li>typeof返回不一样</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> numberObject;    <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> numberValue;     <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<ul>
<li>instanceof检测不一样</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> numberObject;    <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> numberValue;     <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line">numberObject <span class="keyword">instanceof</span> <span class="title class_">Number</span>   <span class="comment">// true</span></span><br><span class="line">numberValue <span class="keyword">instanceof</span> <span class="title class_">Number</span>    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	因为Number对象是Number类型的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote>
<p>String 是对应字符串的引用类型</p>
</blockquote>
<h3 id="创建string对象"><a href="#创建String对象" class="headerlink" title="创建String对象"></a>创建String对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="string实例"><a href="#String实例" class="headerlink" title="String实例"></a>String实例</h3><ul>
<li><code>String</code> 对象的方法可以在所有字符串原始值上调用</li>
<li>3 个继承的方法<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>都返回对象的原始字符串值</li>
<li>每个<code>String</code>对象都有一个<code>length</code>属性，表示字符串中字符的数</li>
</ul>
<h3 id="string类型方法"><a href="#String类型方法" class="headerlink" title="String类型方法"></a>String类型方法</h3><h4 id="javascript字符"><a href="#JavaScript字符" class="headerlink" title="JavaScript字符"></a>JavaScript字符</h4><ul>
<li>length:表示字符串中字符的数量</li>
<li>charAt():返回给定索引位置的字符，由传给方法的整数参数指定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>charCodeAt():  可以查看指定码元的字符编码，这个方法返回指定索引位置的码元值，索引以整数指定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是U+0063</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">2</span>)); <span class="comment">// 99</span></span><br><span class="line"><span class="comment">// 十进制99 等于十六进制63</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">99</span> === <span class="number">0x63</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>fromCharCode(): 用于根据给定的UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode &quot;Latin small letter A&quot;的编码是U+0061</span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter B&quot;的编码是U+0062</span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是U+0063</span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter D&quot;的编码是U+0064</span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter E&quot;的编码是U+0065</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>)); <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"><span class="comment">// 0x0061 === 97</span></span><br><span class="line"><span class="comment">// 0x0062 === 98</span></span><br><span class="line"><span class="comment">// 0x0063 === 99</span></span><br><span class="line"><span class="comment">// 0x0064 === 100</span></span><br><span class="line"><span class="comment">// 0x0065 === 101</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// &quot;abcde&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>codePointAt():  codePointAt()接收16 位码元的索引并返回该索引位置上的码点（code point）。码点是Unicode 中一个字符的完整标识</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab☺de&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">codePointAt</span>(<span class="number">1</span>)); <span class="comment">// 98</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">codePointAt</span>(<span class="number">2</span>)); <span class="comment">// 128522</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">codePointAt</span>(<span class="number">3</span>)); <span class="comment">// 56842</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">codePointAt</span>(<span class="number">4</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<ul>
<li>fromCodePoint():  方法接收任意数量的码点，返回对应字符拼接起来的字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">55357</span>, <span class="number">56842</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab☺de</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">128522</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab☺de</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串规范化方法"><a href="#字符串规范化方法" class="headerlink" title="字符串规范化方法"></a>字符串规范化方法</h4><ul>
<li>normalize(): 通过比较字符串与其调用normalize()的返回值，就可以知道该字符串是否已经规范化</li>
</ul>
<h4 id="字符串拼接方法"><a href="#字符串拼接方法" class="headerlink" title="字符串拼接方法"></a>字符串拼接方法</h4><ul>
<li>concat(): 用于将一个或多个字符串拼接成一个新字符串，不改变原字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>加号操作符(+): 当加号操作符有一方为字符串时，则执行字符串拼接</li>
</ul>
<h4 id="字符串提取方法"><a href="#字符串提取方法" class="headerlink" title="字符串提取方法"></a>字符串提取方法</h4><ul>
<li>slice()</li>
<li>substr()</li>
<li>substring()</li>
</ul>
<p><a href="https://superkatrina123.github.io/2022/07/08/JavaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2_slice%20substr%20substring%E7%9A%84%E5%8C%BA%E5%88%AB/">字符串slice substr substring的区别</a></p>
<h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
</ul>
<p>这两个方法从字符串中搜索传入的字符串，并返回位置，如果没找到，则返回-1</p>
<p>两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而lastIndexOf()方法从字符串末尾开始查找子字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串包含方法"><a href="#字符串包含方法" class="headerlink" title="字符串包含方法"></a>字符串包含方法</h4><ul>
<li>startsWith()</li>
<li>endsWith()</li>
<li>includes()</li>
</ul>
<p>这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值</p>
<p>区别在于，<code>startsWith()</code>检查开始于索引0 的匹配项，<code>endsWith()</code>检查开始于索引<code>(string.length - substring.length)</code>的匹配项，而<code>includes()</code>检查整个字符串</p>
<p>startsWith()和includes()方法接收可选的第二个参数，表示开始搜索的位置，如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;qux&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串删除空格"><a href="#字符串删除空格" class="headerlink" title="字符串删除空格"></a>字符串删除空格</h4><ul>
<li>trim(): 这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果，不影响原字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot; hello world &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot; hello world &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStringValue); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>trimLeft()</li>
<li>trimRight()</li>
</ul>
<p>trimLeft()和trimRight()方法分别用于从字符串开始和末尾清理空格符</p>
<h4 id="字符串重复方法"><a href="#字符串重复方法" class="headerlink" title="字符串重复方法"></a>字符串重复方法</h4><ul>
<li>repeat(): 这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">repeat</span>(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>);</span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串填充方法"><a href="#字符串填充方法" class="headerlink" title="字符串填充方法"></a>字符串填充方法</h4><ul>
<li>padStart()</li>
<li>padEnd()</li>
</ul>
<p>这两个方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件</p>
<p>这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">6</span>)); <span class="comment">// &quot; foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;......foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">6</span>)); <span class="comment">// &quot;foo &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;foo......&quot;</span></span><br></pre></td></tr></table></figure>

<p>可选的第二个参数并不限于一个字符，如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度</p>
<p>此外，如果长度小于或等于字符串长度，则会返回原始字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;foobarba&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串迭代与解构"><a href="#字符串迭代与解构" class="headerlink" title="字符串迭代与解构"></a>字符串迭代与解构</h4><ul>
<li>@@iterator: 表示可以迭代字符串的每个字符</li>
<li>for-of: 在for-of 循环中可以通过这个迭代器按序访问每个字符</li>
<li>解构操作符: 字符串可以通过解构操作符来解构</li>
</ul>
<h4 id="字符串大小转换"><a href="#字符串大小转换" class="headerlink" title="字符串大小转换"></a>字符串大小转换</h4><ul>
<li>toUpperCase()</li>
<li>toLocaleLowerCase()</li>
<li>toLowerCase()</li>
<li>toLocaleUpperCase()</li>
</ul>
<h4 id="字符串模式匹配方法"><a href="#字符串模式匹配方法" class="headerlink" title="字符串模式匹配方法"></a>字符串模式匹配方法</h4><ul>
<li>match(): 接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="comment">// 等价于pattern.exec(text)</span></span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// &quot;cat&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>search(): 接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp 对象，返回模式第一个匹配的位置索引，如果没找到则返回1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pos = text.<span class="title function_">search</span>(<span class="regexp">/at/</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pos); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>replace(): 方法接收两个参数，第一个参数可以是一个RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = text.<span class="title function_">replace</span>(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;cond, bat, sat, fat&quot;</span></span><br><span class="line">result = text.<span class="title function_">replace</span>(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;cond, bond, sond, fond&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>htmlEscape(): 将一段HTML 中的4 个字符替换成对应的实体：小于号、大于号、和号，还有双引号（都必须经过转义)</li>
<li>split(): 会根据传入的分隔符将字符串拆分成数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colorText = <span class="string">&quot;red,blue,green,yellow&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> colors1 = colorText.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colorText.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colorText.<span class="title function_">split</span>(<span class="regexp">/[^,]+/</span>); <span class="comment">// [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串比较方法"><a href="#字符串比较方法" class="headerlink" title="字符串比较方法"></a>字符串比较方法</h4><ul>
<li>localeCompare(): 比较两个字符串，返回如下3 个值中的一个<ul>
<li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值，一般为-1</li>
<li>如果字符串与字符串参数相等，则返回0</li>
<li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值，一般为1</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;brick&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;zoo&quot;</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起读红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型 | 检验数据类型的方法（含手写）</title>
    <url>/2022/07/09/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%A3%80%E9%AA%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%90%AB%E6%89%8B%E5%86%99%EF%BC%89/</url>
    <content><![CDATA[<p>检验数据类型的方法有：</p>
<ul>
<li>typeof</li>
<li>instanceof</li>
<li>constructor</li>
<li>Object.prototype.toString.call()</li>
<li>手写</li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote>
<p>typeof 的原理：JavaScript最初版本以32为的单位存储，包括一个小型类型标记（1-3）位和值的实际数据</p>
<ul>
<li>000：object，表示这个数据是一个对象的引用</li>
<li>1：int，表示这个数据是一个31位的有符号整型</li>
<li>010：double，表示这个数据是一个双精度浮点数的引用</li>
<li>100：string，表示这个数据是一个字符串的引用</li>
<li>110：boolean，表示这个数据是一个布尔值</li>
</ul>
<p>因为Array和null前三位都是000，所以typeof检测为‘object’</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;hello&#x27;</span>);  <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">123</span>);   <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);  <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);   <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);   <span class="comment">// object (检测错误)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);   <span class="comment">// object (检测错误)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>&#125;);    <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);    <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>数组、对象、<code>null</code>都会被判断为<code>object</code>，因此<code>typeof</code>方法有其弊端</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote>
<p>instanceof原理：用于检测构造函数的原型是否存在于实例对象的原型链上</p>
<p>注意：instanceof只能用于检测引用数据类型，如果是检测基本数据类型，直接返回false</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_instanceof/">手写instanceof</a></p>
<h3 id="constructor"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><blockquote>
<p>constructor原理：实例对象通过constructor对象判断构造函数类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="property">constructor</span> === <span class="title class_">Array</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125;.<span class="property">constructor</span> === <span class="title class_">Array</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>注意：如果创建一个对象改变了原型，constructor就不能用来判断数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Fn</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Array</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="objectprototypetostringcall"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><blockquote>
<p>Object.prototype.toString原理：当toString被调用的时候会执行以下操作：</p>
<ol>
<li>获取this对象的[[Class]]属性的值（[[Class]]是一个内部属性，表明了对象的类型）</li>
<li>计算出三个字符串 “object” ， 第一步的属性值，以及 “]” 三部分连接的新字符串</li>
<li>返回第二步的结果</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">2</span>));   <span class="comment">// [object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>));   <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;str&#x27;</span>));  <span class="comment">// [object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]));  <span class="comment">// [object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));  <span class="comment">// [object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;));  <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>));  <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>));  <span class="comment">// [object Null]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>([]));   <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;));   <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>

<p>为什么<code>Object.prototype.toString()</code>和<code>Object.prototype.toString.call()</code>的检测结果不一样？因为<code>Object.prototype.toString()</code>是<code>Object</code>的原型方法，而<code>Array</code>，<code>Function</code>等类型作为<code>Object</code>的实例，都重写了<code>toString</code>方法，利用<code>call</code>是为了让<code>()</code>里面需要判断类型的数据类型来调用<code>Object.prototype.toString</code>方法</p>
<h3 id="手写类型检测方法"><a href="#手写类型检测方法" class="headerlink" title="手写类型检测方法"></a>手写类型检测方法</h3><p><strong>实现思路</strong></p>
<ol>
<li><p>null直接返回null</p>
</li>
<li><p>基本数据类型直接用typeof</p>
</li>
<li><p>引用数据类型用Object.prototype.toString</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testType</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&#x27;null&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> <span class="keyword">typeof</span> target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>).<span class="title function_">toLowerCase</span>();   <span class="comment">// [object XXX]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> target1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> target2 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">testType</span>(target1));  <span class="comment">// array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">testType</span>(target2));  <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型 | 深浅拷贝</title>
    <url>/2022/07/05/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><strong>基本数据类型</strong>：简单的数据，保存基本数据类型的变量是按<strong>值</strong>进行访问的，因此直接保存在栈内存中</li>
<li><strong>引用数据类型</strong>：保存在堆内存中，在栈内存中保存了一个堆内存中实际对象的引用，引用数据类型的变量是按照<strong>引用</strong>进行访问的</li>
</ul>
<h2 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h2><ul>
<li><strong>基本数据类型</strong>：在通过变量把一个基本数据赋值到另一个变量时，基本数据会被复制到新变量的位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br></pre></td></tr></table></figure>

<img src="/2022/07/05/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" class title="基本数据类型">

<p>从上图可知，num1和num2是独立使用的，互不干扰</p>
<ul>
<li><strong>引用数据类型</strong>：在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。<strong>区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象</strong>，操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来</li>
</ul>
<img src="/2022/07/05/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" class title="引用数据类型">

<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><blockquote>
<p>深浅拷贝都是针对于<strong>引用类型</strong>的，因为引用类型是存放在堆内存中的，在栈地址中有一个或者多个地址来指向堆内存的某一数据</p>
</blockquote>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象</p>
</blockquote>
<p>浅拷贝是指被复制对象的所有变量都与原来的对象含有相同的值，而所有的对其他对象的引用仍然指向原来的对象</p>
<p>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象，如果你修改了“副本”的值，那么原来的对象也会被修改</p>
<p>浅拷贝只拷贝一层，深层次的引用类型则共享内存地址</p>
<img src="/2022/07/05/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="浅拷贝示意图">

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote>
<p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p>
</blockquote>
<p>深拷贝是一个整个独立对象的拷贝，深拷贝会拷贝所有的属性，并且拷贝属性指向的动态分配的内存</p>
<p>深拷贝把要复制的对象所引用的对象都复制了一遍，如果你修改了“副本”的值，那么原来的对象不会被修改，两者是相互独立的</p>
<img src="/2022/07/05/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="深拷贝示意图">

<h2 id="实现浅拷贝的方式"><a href="#实现浅拷贝的方式" class="headerlink" title="实现浅拷贝的方式"></a>实现浅拷贝的方式</h2><ul>
<li><code>Object.assign</code></li>
<li><code>Array.protptype.slice</code></li>
<li><code>Array.protptype.concat</code></li>
<li>使用拓展运算符</li>
<li>手写浅拷贝</li>
</ul>
<h3 id="objectassign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>补课：<a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E5%AF%B9%E8%B1%A1_Object_API/#%EF%BC%882%EF%BC%89%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%EF%BC%9AObject-assign-%E3%80%90ES6%E3%80%91">Object.assign</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;swim&#x27;</span>, <span class="string">&#x27;play football&#x27;</span>],</span><br><span class="line">    <span class="attr">love</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;She is a cool girl！&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">person1.<span class="property">hobbies</span>[<span class="number">2</span>] = <span class="string">&#x27;play tennies&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">hobbies</span>);    <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play tennies&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">hobbies</span>);     <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play tennies&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="arrayprototypeslice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h3><p>补课：<a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%882%EF%BC%89%E6%88%AA%E5%8F%96%E6%95%B0%E7%BB%84%EF%BC%9Aslice-%E3%80%90ES5%E3%80%91">slice</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]];</span><br><span class="line"><span class="keyword">const</span> colors1 = colors.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">colors1[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);      <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors1);     <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br></pre></td></tr></table></figure>

<h3 id="arrayprototypeconcat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h3><p>补课：<a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%881%EF%BC%89%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84%EF%BC%9Aconcat-%E3%80%90ES5%E3%80%91">concat</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]];</span><br><span class="line"><span class="keyword">const</span> colors1 = colors.<span class="title function_">concat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">colors1[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);      <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors1);     <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br></pre></td></tr></table></figure>

<h3 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]];</span><br><span class="line"><span class="keyword">const</span> colors1 = [...colors];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">colors1[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);      <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors1);     <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br></pre></td></tr></table></figure>

<h3 id="手写浅拷贝"><a href="#手写浅拷贝" class="headerlink" title="手写浅拷贝"></a>手写浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res, targetType = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        res = &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target === <span class="string">&#x27;array&#x27;</span>) &#123;</span><br><span class="line">        res = [];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        res[key] = target[key];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1</span></span><br><span class="line"><span class="keyword">const</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]];</span><br><span class="line"><span class="keyword">const</span> colors1 = <span class="title function_">shallowClone</span>(colors);</span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">colors1[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);      <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors1);     <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;swim&#x27;</span>, <span class="string">&#x27;play football&#x27;</span>],</span><br><span class="line">    <span class="attr">love</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;She is a cool girl！&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">shallowClone</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">person1.<span class="property">hobbies</span>[<span class="number">2</span>] = <span class="string">&#x27;play tennies&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">hobbies</span>);    <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play tennies&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">hobbies</span>);     <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play tennies&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="实现深拷贝的方式"><a href="#实现深拷贝的方式" class="headerlink" title="实现深拷贝的方式"></a>实现深拷贝的方式</h2><ul>
<li><code>_.cloneDeep()</code></li>
<li><code>JQuery.extend()</code></li>
<li><code>JSON.stringify()</code></li>
<li>手写深拷贝</li>
</ul>
<h3 id="_clonedeep"><a href="#cloneDeep" class="headerlink" title="_.cloneDeep()"></a>_.cloneDeep()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;loash&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;swim&#x27;</span>, <span class="string">&#x27;play football&#x27;</span>],</span><br><span class="line">    <span class="attr">love</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;She is a cool girl！&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = _.<span class="title function_">cloneDeep</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">person1.<span class="property">hobbies</span>[<span class="number">2</span>] = <span class="string">&#x27;play tennies&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">hobbies</span>);    <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play tennies&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">hobbies</span>);     <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play football&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="jqueryextend"><a href="#JQuery-extend" class="headerlink" title="JQuery.extend()"></a>JQuery.extend()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;swim&#x27;</span>, <span class="string">&#x27;play football&#x27;</span>],</span><br><span class="line">    <span class="attr">love</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;She is a cool girl！&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = $.<span class="title function_">extend</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">person1.<span class="property">hobbies</span>[<span class="number">2</span>] = <span class="string">&#x27;play tennies&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">hobbies</span>);    <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play tennies&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">hobbies</span>);     <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play football&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="jsonstringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;swim&#x27;</span>, <span class="string">&#x27;play football&#x27;</span>],</span><br><span class="line">    <span class="attr">love</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;She is a cool girl！&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(person));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">person1.<span class="property">hobbies</span>[<span class="number">2</span>] = <span class="string">&#x27;play tennies&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">hobbies</span>);    <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play tennies&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">hobbies</span>);     <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play football&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印person1发现...</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下图，function不见了...这就是JSON.stringify()方法的弊端</span></span><br></pre></td></tr></table></figure>

<img src="/2022/07/05/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/JSON.stringify%E5%BC%8A%E7%AB%AF.png" class title="JSON.stringify弊端">

<p>这种方法会存在弊端：会忽略<code>undefined</code>，<code>function</code>，<code>symbol</code>的存在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;I am fine&#x27;</span>),</span><br><span class="line">    <span class="attr">d</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;and you?&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test1 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(test));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test1);    <span class="comment">// &#123;a: &#x27;hello&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res, targetType = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (targetType === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        res = &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType === <span class="string">&#x27;array&#x27;</span>) &#123;</span><br><span class="line">        res = [];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        res[key] = <span class="title function_">deepClone</span>(target[key]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1</span></span><br><span class="line"><span class="keyword">const</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]];</span><br><span class="line"><span class="keyword">const</span> colors1 = <span class="title function_">deepClone</span>(colors);</span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">colors1[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);      <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;black&#x27;]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors1);     <span class="comment">// [&#x27;red&#x27;, &#x27;yellow&#x27;, [&#x27;green&#x27;, &#x27;pink&#x27;]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;swim&#x27;</span>, <span class="string">&#x27;play football&#x27;</span>],</span><br><span class="line">    <span class="attr">love</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;She is a cool girl！&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">deepClone</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验深拷贝or浅拷贝</span></span><br><span class="line">person1.<span class="property">hobbies</span>[<span class="number">2</span>] = <span class="string">&#x27;play tennies&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">hobbies</span>);    <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play tennies&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">hobbies</span>);     <span class="comment">// [&#x27;run&#x27;, &#x27;swim&#x27;, &#x27;play football&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="拓展赋值和拷贝"><a href="#拓展：赋值和拷贝" class="headerlink" title="拓展：赋值和拷贝"></a>拓展：赋值和拷贝</h2><p>拷贝区别于赋值最重要的一点是：拷贝会在堆上创建一个新的对象</p>
<p>示意图如下图所示：</p>
<img src="/2022/07/05/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8B%B7%E8%B4%9D.png" class title="赋值和拷贝">

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">和原对象是否指向同一地址</th>
<th align="center">第一层数据为基本数据类型</th>
<th align="center">原数据中包含子对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>赋值</strong></td>
<td align="center">是</td>
<td align="center">改变会使原数据一同改变</td>
<td align="center">改变会使原数据一同改变</td>
</tr>
<tr>
<td align="center"><strong>浅拷贝</strong></td>
<td align="center">否</td>
<td align="center">改变不会使原数据一同改变</td>
<td align="center">改变会使原数据一同改变</td>
</tr>
<tr>
<td align="center"><strong>深拷贝</strong></td>
<td align="center">否</td>
<td align="center">改变不会使原数据一同改变</td>
<td align="center">改变不会使原数据一同改变</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000017773877">深入理解JS深浅拷贝</a></p>
<p><a href="https://juejin.cn/post/7035975489906802702">赋值和拷贝</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>JavaScript数据类型</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 | Array_API（含手写原理）</title>
    <url>/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/</url>
    <content><![CDATA[<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><h4 id="1new-array-es5"><a href="#（1）new-Array-【ES5】" class="headerlink" title="（1）new Array()        【ES5】"></a>（1）new Array()        【ES5】</h4><p>创建数组可以通过<code>Array</code>构造函数的方式构造数组 （new 操作符可以省略）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);  <span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>特殊：当传入一个数值的时候，会创建一个指定数组的数组，用逗号创建的数组空位，值为<code>undefined</code>（关于数组空位，发现一些好玩的，请看这篇<a href="https://superkatrina123.github.io/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D%E5%92%8Cundefined/">博文</a>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>(<span class="number">10</span>);  <span class="comment">// 这里省略了new操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">// [empty × 10]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="2arrayof-es6"><a href="#（2）Array-of-【ES6】" class="headerlink" title="（2）Array.of()       【ES6】"></a>（2）Array.of()       【ES6】</h4><blockquote>
<p><code>Array.of()</code>创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型</p>
<p><code>Array.of()</code>代替了之前用<code>Array.prototype.slice.call(arguments)</code>转数组的笨拙写法</p>
<p><code>Array.of()</code>和<code>Array</code>构造函数的区别在于处理单个数组的情况</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>(<span class="number">10</span>);   <span class="comment">// [empty × 10]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">10</span>);   <span class="comment">// [10]</span></span><br></pre></td></tr></table></figure>

<h4 id="3arrayfrom-es6"><a href="#（3）Array-from-【ES6】" class="headerlink" title="（3）Array.from()        【ES6】"></a>（3）Array.from()        【ES6】</h4><blockquote>
<p><code>Array.from()</code>创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型</p>
</blockquote>
<p><strong>语法</strong>（注意：容易被忽略）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, mapFn, thisArg);</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>arrayLike</code>：类数组或者可迭代对象（如Map，Set等）或者有一个<code>length</code>属性和可索引元素的结构</li>
<li><code>mapFn</code>（可选）：用于增强数组元素的回调函数</li>
<li><code>thisArg</code>（可选）:执行回调时的<code>this</code>对象</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个参数的妙用</span></span><br><span class="line"><span class="keyword">let</span> arrLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrLike, <span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [3,6,9,12]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.from()</code>对现有数组是浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1 === arr2);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h3><h4 id="1中括号索引法"><a href="#（1）中括号索引法" class="headerlink" title="（1）中括号索引法"></a>（1）中括号索引法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors[<span class="number">1</span>]);  <span class="comment">// green</span></span><br></pre></td></tr></table></figure>

<h4 id="2arraylength"><a href="#（2）Array-length" class="headerlink" title="（2）Array.length()"></a>（2）Array.length()</h4><blockquote>
<p><code>Array.length()</code>返回或设置一个数组中的元素个数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>注意：数组的<code>length</code>并不只是可读的，而是可以通过修改<code>length</code>属性，从数组的末尾删除或者添加元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line">colors.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line">colors.<span class="property">length</span> = <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用length属性可以方便为数组末尾添加元素</span></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line">colors[colors.<span class="property">length</span>] = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);     <span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><h4 id="1arrayisarray"><a href="#（1）Array-isArray" class="headerlink" title="（1）Array.isArray()"></a>（1）Array.isArray()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);   <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span>&#125;);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>思考：检测一个对象是否是数组的方法有？</strong></p>
<h3 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h3><h4 id="1arrayprototypevalues-es6"><a href="#（1）Array-prototype-values-【ES6】" class="headerlink" title="（1）Array.prototype.values()   【ES6】"></a>（1）Array.prototype.values()   【ES6】</h4><blockquote>
<p><code>values()</code> 方法返回一个新的 <strong><code>Array Iterator</code></strong> 对象，该对象包含数组每个索引的值</p>
</blockquote>
<h4 id="2arrayprototypekeys-es6"><a href="#（2）Array-prototype-keys-【ES6】" class="headerlink" title="（2）Array.prototype.keys()   【ES6】"></a>（2）Array.prototype.keys()   【ES6】</h4><blockquote>
<p><code>keys() </code>方法返回一个包含数组中每个索引键的<code>Array Iterator</code>对象</p>
</blockquote>
<h4 id="3arrayprototypeentries-es6"><a href="#（3）Array-prototype-entries-【ES6】" class="headerlink" title="（3）Array.prototype.entries()   【ES6】"></a>（3）Array.prototype.entries()   【ES6】</h4><blockquote>
<p><code>entries()</code> 方法返回一个新的<strong>Array Iterator</strong>对象，该对象包含数组中每个索引的键&#x2F;值对</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aValues = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">values</span>());</span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">keys</span>());</span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">entries</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues);   <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, &#x27;qux&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys);     <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aEntries);   <span class="comment">// [[0, &#x27;foo&#x27;], [1, &#x27;bar&#x27;], [2, &#x27;baz&#x27;], [3, &#x27;qux&#x27;]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用解构赋值可以很容易拆分键值对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> aEntries) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	0 &#x27;foo&#x27;</span></span><br><span class="line"><span class="comment">	1 &#x27;bar&#x27;</span></span><br><span class="line"><span class="comment">	2 &#x27;baz&#x27;</span></span><br><span class="line"><span class="comment">	3 &#x27;qux&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myEntries</span> = <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>([i, <span class="variable language_">this</span>[i]])</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> a = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">myEntries</span>()); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	[[0, &#x27;foo&#x27;], [1, &#x27;bar&#x27;], [2, &#x27;baz&#x27;], [3, &#x27;qux&#x27;]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="复制和填充"><a href="#复制和填充" class="headerlink" title="复制和填充"></a>复制和填充</h3><h4 id="1批量复制copywithin-es6"><a href="#（1）批量复制：copyWithin-【ES6】" class="headerlink" title="（1）批量复制：copyWithin()  【ES6】"></a>（1）批量复制：copyWithin()  【ES6】</h4><blockquote>
<p><code>copyWithin()</code> 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">copyWithin</span>(target, start, end)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>target</code>：从这个位置开始填充</li>
<li><code>start</code>（可选）：填充的内容从这个位置开始截取</li>
<li><code>end</code>（可选）：填充的内容到这个位置截取完毕（不包含end）</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>负索引会被计算成负索引+length</p>
</li>
<li><p><code>copyWithin()</code>静默忽略超出数组边界、零长度及方向相反的索引范围</p>
</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>);   <span class="comment">// [2,3,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要注意：</span></span><br><span class="line"><span class="comment">		1. copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围</span></span><br><span class="line"><span class="comment">		2. 不会改变原数组的长度</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCopyWithin</span> = <span class="keyword">function</span>(<span class="params">target, start, end</span>) &#123;</span><br><span class="line">    target &lt; <span class="number">0</span> ? target +length : target;</span><br><span class="line">    start &lt; <span class="number">0</span> ? start +length : start;</span><br><span class="line">    end &lt; <span class="number">0</span> ? end +length : end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        arr[target] = arr[i]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>);   <span class="comment">// [2,3,2,3,4,5] </span></span><br></pre></td></tr></table></figure>

<h4 id="2填充数组fill-es6"><a href="#（2）填充数组：fill-【ES6】" class="headerlink" title="（2）填充数组：fill()    【ES6】"></a>（2）填充数组：fill()    【ES6】</h4><blockquote>
<p><code>fill()</code> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素，不包括终止索引，会改变原数组</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">fill</span>(value, start, end)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>value</code>：用于填充数组的元素</li>
<li><code>start</code>：起始索引，默认为0</li>
<li><code>end</code>：终止索引，默认为<code>this.length</code></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>负索引会被计算成负索引+length</p>
</li>
<li><p><code>fill()</code>静默忽略超出数组边界、零长度及方向相反的索引范围</p>
</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引过低忽略</span></span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>, -<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引过高忽略</span></span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">24</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引反向忽略</span></span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [1,2,3,0,0,0,0]</span></span><br></pre></td></tr></table></figure>

<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要注意：</span></span><br><span class="line"><span class="comment">		1. fill()静默忽略超出数组边界、零长度及方向相反的索引范围</span></span><br><span class="line"><span class="comment">		2. 会改变原数组</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFill</span> = <span class="keyword">function</span>(<span class="params">value, start, end</span>) &#123;</span><br><span class="line">    start &lt; <span class="number">0</span> ? start + length : start;</span><br><span class="line">    end &lt; <span class="number">0</span> ? end + length : end;</span><br><span class="line">    end &gt; <span class="variable language_">this</span>.<span class="property">length</span> ? <span class="variable language_">this</span>.<span class="property">length</span> : end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[i] = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [1,2,3,0,0,0,0]</span></span><br></pre></td></tr></table></figure>

<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><h4 id="1tostring-ampamp-tolocalestring-ampamp-valueof"><a href="#（1）toString-amp-amp-toLocaleString-amp-amp-valueOf" class="headerlink" title="（1）toString()  &amp;&amp; toLocaleString()   &amp;&amp; valueOf()"></a>（1）toString()  &amp;&amp; toLocaleString()   &amp;&amp; valueOf()</h4><blockquote>
<p><code>valueOf()</code>返回数组本身</p>
<p><code>toString()</code>返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串</p>
<p><code>toLocaleString()</code>返回一个字符串表示数组中的元素。数组中的元素将使用各自的 <code>toLocaleString</code> 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line"></span><br><span class="line">colors.<span class="title function_">toString</span>();  <span class="comment">// &#x27;red,green,yellow&#x27;</span></span><br><span class="line">colors.<span class="title function_">valueOf</span>();   <span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">toString</span>())  <span class="comment">// &#x27;red,green,yellow&#x27;</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">valueOf</span>())  <span class="comment">// &#x27;red,green,yellow&#x27;</span></span><br><span class="line"><span class="title function_">alert</span>(colors)   <span class="comment">// &#x27;red,green,yellow&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这里被显式调用toString()方法和valueOf()方法，分别返回数组的字符串表示</span></span><br><span class="line"><span class="comment">	最后alert(colors)，因为alert期待字符串，所以调用了toString()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">    <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;Nikolaos&quot;</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123;</span><br><span class="line">    <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;Grigorios&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> people = [person1, person2];</span><br><span class="line"><span class="title function_">alert</span>(people); <span class="comment">// Nicholas,Greg   调用toString()</span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toString</span>()); <span class="comment">// Nicholas,Greg   调用toString()</span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toLocaleString</span>()); <span class="comment">// Nikolaos,Grigorios  调用toLocaleString()</span></span><br></pre></td></tr></table></figure>

<h4 id="2join"><a href="#（2）join" class="headerlink" title="（2）join()"></a>（2）join()</h4><blockquote>
<p><code>join()</code>返回以指定分隔符分隔数组元素的字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>));   <span class="comment">// &#x27;red-green-yellow&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：如果数组中某一项是<code>null</code>或者<code>undefined</code>，则返回值会以空字符串表示</p>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要注意：</span></span><br><span class="line"><span class="comment">		1. separator默认为逗号分隔</span></span><br><span class="line"><span class="comment">		2. 如果数组中某一项是``null``或者``undefined``，则返回值会以空字符串表示</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myJoin</span> = <span class="keyword">function</span>(<span class="params">separator = <span class="string">&#x27;,&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[i] = <span class="variable language_">this</span>[i] === <span class="literal">undefined</span> || <span class="variable language_">this</span>[i] === <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : <span class="variable language_">this</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            res += (<span class="variable language_">this</span>[i] + separator);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            res += <span class="variable language_">this</span>[i];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">undefined</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">myJoin</span>());   <span class="comment">// 1,,3,4,,6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">myJoin</span>(<span class="string">&#x27;-&#x27;</span>));  <span class="comment">// 1--3-4--6</span></span><br></pre></td></tr></table></figure>

<h3 id="栈和队列方法"><a href="#栈和队列方法" class="headerlink" title="栈和队列方法"></a>栈和队列方法</h3><h4 id="1push-es5"><a href="#（1）push-【ES5】" class="headerlink" title="（1）push()   【ES5】"></a>（1）push()   【ES5】</h4><blockquote>
<p>向数组末尾添加元素，返回修改后数组的长度</p>
</blockquote>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要注意：返回的是修改后数组的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myPush</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>].<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">myPush</span>(<span class="number">8</span>,<span class="number">9</span>));   <span class="comment">//7</span></span><br></pre></td></tr></table></figure>

<h4 id="2pop-es5"><a href="#（2）pop-【ES5】" class="headerlink" title="（2）pop()   【ES5】"></a>（2）pop()   【ES5】</h4><blockquote>
<p>删除数组的最后一项，同时减少数组的<code>length</code>值，返回被删除的元素</p>
</blockquote>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要注意：</span></span><br><span class="line"><span class="comment">		1. 要减少数组的length值</span></span><br><span class="line"><span class="comment">		2. 返回被删除的元素</span></span><br><span class="line"><span class="comment">		3. 数组长度为0时返回undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myPop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">myPop</span>());   <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">length</span>);    <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="3shift-es5"><a href="#（3）shift-【ES5】" class="headerlink" title="（3）shift() 【ES5】"></a>（3）shift() 【ES5】</h4><blockquote>
<p>删除数组的第一项，同时减少数组的<code>length</code>值，返回被删除的元素</p>
</blockquote>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要注意：</span></span><br><span class="line"><span class="comment">		1. 要减少数组的length值</span></span><br><span class="line"><span class="comment">		2. 返回被删除的元素</span></span><br><span class="line"><span class="comment">		3. 数组长度为0时返回undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myShift</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="variable language_">this</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[i-<span class="number">1</span>] = <span class="variable language_">this</span>[i];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">myShift</span>());   <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">// [2,4,5,6]</span></span><br></pre></td></tr></table></figure>

<h4 id="4unshift-es5"><a href="#（4）unshift-【ES5】" class="headerlink" title="（4）unshift() 【ES5】"></a>（4）unshift() 【ES5】</h4><blockquote>
<p>在数组开头添加元素，返回修改后数组的长度</p>
</blockquote>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要注意：返回的是修改后数组的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myUnshift</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="variable language_">arguments</span>, ...<span class="variable language_">this</span>].<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">myUnshift</span>(<span class="number">8</span>,<span class="number">9</span>));   <span class="comment">//7</span></span><br></pre></td></tr></table></figure>

<h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><p>补课啦：<a href="%E5%8D%A0%E4%BD%8D">常见的排序算法及JS实现</a></p>
<h4 id="1数组排序sort-es5"><a href="#（1）数组排序：sort-【ES5】" class="headerlink" title="（1）数组排序：sort()   【ES5】"></a>（1）数组排序：sort()   【ES5】</h4><blockquote>
<p><code>sort()</code> 方法用原地算法（即不创建额外的空间）对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(compareFunction)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>compareFunction</code>（可选）：用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的 Unicode 位点进行排序</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compareFunction</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;    <span class="comment">// 负值，value1排在value2前面</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">// 正值，value1排在value2后面</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2翻转数组reverse-es5"><a href="#（2）翻转数组：reverse-【ES5】" class="headerlink" title="（2）翻转数组：reverse()   【ES5】"></a>（2）翻转数组：reverse()   【ES5】</h4><blockquote>
<p><code>reverse()</code> 方法将数组中元素的位置颠倒，并返回该数组，该方法会改变原数组</p>
</blockquote>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	改变原数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReverse</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="variable language_">this</span>.<span class="property">length</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        [<span class="variable language_">this</span>[left], <span class="variable language_">this</span>[right]] = [<span class="variable language_">this</span>[right], <span class="variable language_">this</span>[left]];</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">myReverse</span>());   <span class="comment">// [&#x27;o&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;h&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="1合并数组concat-es5"><a href="#（1）合并数组：concat-【ES5】" class="headerlink" title="（1）合并数组：concat()   【ES5】"></a>（1）合并数组：concat()   【ES5】</h4><blockquote>
<p><code>concat()</code> 方法用于合并两个或多个数组，此方法会首先创建一个当前数组的副本，然后再把参数添加到副本末尾，所以不会更改现有数组，而是返回一个新数组</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = old_array.<span class="title function_">concat</span>(value1[, value2[, ...[, valueN]]])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>valueN</code>：可以是数组或者值</li>
</ul>
<p><strong>注意</strong></p>
<p>可以使用<code>Symbol.isConcatSpreadable</code>来控制传入的类数组对象是否强制打平，<code>true</code>为强制打平</p>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> a3 = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制打平</span></span><br><span class="line"><span class="keyword">let</span> a1_2 = a1.<span class="title function_">concat</span>(a2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1_2);     <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不强制打平</span></span><br><span class="line"><span class="keyword">let</span> a1_3 = a1.<span class="title function_">concat</span>(a3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1_3);     <span class="comment">// [1,2,3, &#123;[Symbol.isConcatSpreadable]:false,length: 2,0: 4,1: 5&#125;]</span></span><br></pre></td></tr></table></figure>

<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	注意：此方法会创建一个当前数组的副本，并不会修改原数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myConcat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="keyword">let</span> res = <span class="variable language_">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> args[i] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            res = [...res, ...args[i]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[res.<span class="property">length</span>] = args[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="title function_">myConcat</span>(<span class="number">4</span>, a2)); <span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<h4 id="2截取数组slice-es5"><a href="#（2）截取数组：slice-【ES5】" class="headerlink" title="（2）截取数组：slice()    【ES5】"></a>（2）截取数组：slice()    【ES5】</h4><blockquote>
<p><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）,原始数组不会被改变</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">slice</span>(start, end);</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>start</code>（可选）：起始索引，默认为0</li>
<li><code>end</code>（可选）：终止索引（不含），默认为<code>this.length</code></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>遇到负索引需要进行索引+length处理</li>
<li><code>start</code>超过原数组的索引范围返回空数组</li>
<li><code>end</code>大于原数组的长度，则截取到原数组的末尾</li>
</ul>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mySlice</span> = <span class="keyword">function</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">    start &gt; <span class="number">0</span> ? start : start +length;</span><br><span class="line">    end &gt; <span class="number">0</span> ? end : end +length;</span><br><span class="line">    end &gt; <span class="variable language_">this</span>.<span class="property">length</span> ? <span class="variable language_">this</span>.<span class="property">length</span> : end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">mySlice</span>(<span class="number">2</span>,<span class="number">4</span>));  <span class="comment">// [&#x27;l&#x27;, &#x27;l&#x27;];</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="3插入元素splice-es5"><a href="#（3）插入元素：splice-【ES5】" class="headerlink" title="（3）插入元素：splice()    【ES5】"></a>（3）插入元素：splice()    【ES5】</h4><blockquote>
<p><strong><code>splice()</code></strong> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容，此方法会改变原数组</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">splice</span>(start, deletcount, item1, item2,...)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>start</code>：起始位置</li>
<li><code>deletecount</code>（可选）:要移除数组元素的个数，0或者负数表示不移除</li>
<li><code>item1 item2</code>（可选）：要添加的元素</li>
</ul>
<p><strong>返回值</strong></p>
<p>由被删除的元素组成的一个数组</p>
<p>如果只删除了一个元素，则返回只包含一个元素的数组</p>
<p>如果没有删除元素，则返回空数组</p>
<p><strong>方法</strong></p>
<ul>
<li><strong>删除</strong>：传2个参数</li>
<li><strong>插入</strong>：传3个参数</li>
<li><strong>替换</strong>：传3个参数</li>
</ul>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	改变原数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mySlice</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="keyword">let</span> start = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(args);</span><br><span class="line">    <span class="keyword">let</span> deletecunt = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> left = <span class="variable language_">this</span>.<span class="title function_">slice</span>(<span class="number">0</span>, start);  <span class="comment">// 左边数组</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="variable language_">this</span>.<span class="title function_">slice</span>(start+deletecount, <span class="variable language_">this</span>.<span class="property">length</span>);  <span class="comment">// 右边数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = [...left, ...atgs, ... right];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改变原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[i] = res[i];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">slice</span>(start, start + deletcount);   <span class="comment">// 返回删除的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> myFish = [<span class="string">&#x27;angel&#x27;</span>, <span class="string">&#x27;clown&#x27;</span>, <span class="string">&#x27;drum&#x27;</span>, <span class="string">&#x27;mandarin&#x27;</span>, <span class="string">&#x27;sturgeon&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> removed = myFish.<span class="title function_">splice</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed);   <span class="comment">// [&#x27;mandarin&#x27;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFish = [<span class="string">&#x27;angel&#x27;</span>, <span class="string">&#x27;clown&#x27;</span>, <span class="string">&#x27;drum&#x27;</span>, <span class="string">&#x27;sturgeon&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> removed = myFish.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;trumpet&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed);   <span class="comment">// [&#x27;drum]</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h3><h4 id="1按严格相等搜索indexof-es5-ampamp-lastindexof-es5-ampamp-inclues-es6"><a href="#（1）按严格相等搜索：indexOf-【ES5】-amp-amp-lastIndexOf-【ES5】-amp-amp-inclues-【ES6】" class="headerlink" title="（1）按严格相等搜索：indexOf()  【ES5】 &amp;&amp;  lastIndexOf()  【ES5】 &amp;&amp; inclues()    【ES6】"></a>（1）按严格相等搜索：indexOf()  【ES5】 &amp;&amp;  lastIndexOf()  【ES5】 &amp;&amp; inclues()    【ES6】</h4><blockquote>
<p><code>indexOf()</code>方法返回在数组中可以找到一个给定元素的<strong>第一个</strong>索引，如果不存在，则返回-1</p>
<p><code>lastIndexOf()</code> 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1，从数组的后面向前查找，从 <code>fromIndex</code> 处开始</p>
<p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code></p>
</blockquote>
<p><strong>注意</strong></p>
<ul>
<li>三者都可以指定<code>fromIndex</code>，即从哪一项开始寻找</li>
<li>三者都采用严格相等搜索，即<code>===</code>比较</li>
<li>找到目标之后不会继续往下找</li>
</ul>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	严格相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// indexOf()</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myIndexOf</span> = <span class="keyword">function</span>(<span class="params">num, fromIndex = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = fromIndex; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>[i] === num) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">myIndexOf</span>(<span class="number">2</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">myIndexOf</span>(<span class="number">2</span>, <span class="number">4</span>))   <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// includes()</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myIncludes</span> = <span class="keyword">function</span>(<span class="params">num, fromIndex = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = fromIndex; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>[i] === num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">myIncludes</span>(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">myIncludes</span>(<span class="number">2</span>, <span class="number">4</span>))   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="2按断言函数搜索find-ampamp-findindex-es6-all"><a href="#（2）按断言函数搜索：find-amp-amp-findIndex-【ES6】-ALL" class="headerlink" title="（2）按断言函数搜索：find() &amp;&amp; findIndex()    【ES6】 ALL"></a>（2）按断言函数搜索：find() &amp;&amp; findIndex()    【ES6】 ALL</h4><blockquote>
<p><code>find()</code> 方法返回数组中满足提供的测试函数的<strong>第一个元素</strong>的值，否则返回undefined</p>
<p><code>findIndex()</code>方法返回数组中满足提供的测试函数的<strong>第一个元素的</strong>索引，若没有找到对应元素则返回-1</p>
</blockquote>
<p><strong>注意</strong></p>
<ul>
<li>两者都采用断言函数搜索，断言函数接收3个参数：元素 索引 数组本身</li>
<li>因此两个的参数都是一个回调函数</li>
<li>找到符合条件的元素后就不会再继续</li>
</ul>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFind</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">callback</span>(arr[i], i, arr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> res = arr.<span class="title function_">myFind</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> item &gt; <span class="number">4</span>);   </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res, arr);  <span class="comment">// 5   [1,2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFindIndex</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">callback</span>(arr[i], i, arr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="1every-es5"><a href="#（1）every-【ES5】" class="headerlink" title="（1）every()    【ES5】"></a>（1）every()    【ES5】</h4><blockquote>
<p><code>every()</code> 方法测试一个数组内的<strong>所有元素</strong>是否都能通过某个指定函数的测试，它返回一个布尔值</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);  <span class="comment">// true</span></span><br><span class="line">arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">4</span>);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	特点：必须每一项元素都满足条件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myEvery</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">callback</span>(<span class="variable language_">this</span>[i], i, <span class="variable language_">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">myEvery</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);  <span class="comment">// true</span></span><br><span class="line">arr.<span class="title function_">myEvery</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">4</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="2some-es5"><a href="#（2）some-【ES5】" class="headerlink" title="（2）some()   【ES5】"></a>（2）some()   【ES5】</h4><blockquote>
<p><code>some()</code> 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试，它返回一个布尔值</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);  <span class="comment">// true</span></span><br><span class="line">arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">4</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	特点：只要有一项元素满足即可</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mySome</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">callback</span>(<span class="variable language_">this</span>[i], i, <span class="variable language_">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">mySome</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">4</span>);  <span class="comment">// true</span></span><br><span class="line">arr.<span class="title function_">mySome</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">8</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="3filter-es5"><a href="#（3）filter-【ES5】" class="headerlink" title="（3）filter()   【ES5】"></a>（3）filter()   【ES5】</h4><blockquote>
<p><code>filter()</code> 方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">5</span>);  <span class="comment">// [ 6, 7]</span></span><br></pre></td></tr></table></figure>

<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFilter</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">callback</span>(<span class="variable language_">this</span>[i], i, <span class="variable language_">this</span>)) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">myFilter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">5</span>);  <span class="comment">// [ 6, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助reduce</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFilter</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">callback</span>(item, index, arr)) &#123;</span><br><span class="line">                prev.<span class="title function_">push</span>(item);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;, [])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback is not a fucntion&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">myFilter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">5</span>);  <span class="comment">// [ 6, 7]</span></span><br></pre></td></tr></table></figure>

<h4 id="4foreach-es5"><a href="#（4）forEach-【ES5】" class="headerlink" title="（4）forEach()     【ES5】"></a>（4）forEach()     【ES5】</h4><blockquote>
<p><code>forEach()</code> 方法对数组的每个元素执行一次给定的函数，没有返回值，改变原数组</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">// [6,8,10,12,14]</span></span><br></pre></td></tr></table></figure>

<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	注意： 改变原数组</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myForEach</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        callback.<span class="title function_">call</span>(thisArg, arr[i]);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">myForEach</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value + <span class="variable language_">this</span>.<span class="property">num</span>); <span class="comment">// 依次打印：11 12 13 14 15 16</span></span><br><span class="line">&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h4 id="5map-es5"><a href="#（5）map-【ES5】" class="headerlink" title="（5）map()  【ES5】"></a>（5）map()  【ES5】</h4><blockquote>
<p><code>map()</code> 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);  <span class="comment">// [6,8,10,12,14]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><code>map</code>仅对每一项已分配值得索引调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newA = a.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>); <span class="comment">// [2,4,,8]</span></span><br></pre></td></tr></table></figure>

<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMap</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="title function_">callback</span>(arr[i], i, arr);</span><br><span class="line">        res.<span class="title function_">push</span>(value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newA = a.<span class="title function_">myMap</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>); <span class="comment">// [2,4,8]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce改进 </span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMap</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">        prev.<span class="title function_">push</span>(<span class="title function_">callback</span>(curr, index, arr));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newA = a.<span class="title function_">myMap</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>); <span class="comment">// [2,4,8]</span></span><br></pre></td></tr></table></figure>

<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><h4 id="1reduce-es5"><a href="#（1）reduce-【ES5】" class="headerlink" title="（1）reduce()  【ES5】"></a>（1）reduce()  【ES5】</h4><blockquote>
<p><code>reduce()</code>接收两个参数：归并函数和归并起点的初始值</p>
<p>其中归并函数接收四个参数：上一个归并值、当前项、当前项的索引、数组本身。归并函数返回的任何值都会成为下一次调用同一个函数的第一个参数，即归并值，如果没有归并起点的初始值，则把第一个元素作为初始值，迭代从第二个元素开始</p>
</blockquote>
<p>reduce的应用详见：<a href="%E5%8D%A0%E4%BD%8D">强大的reduce</a></p>
<p><strong>手写实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReduce</span> = <span class="keyword">function</span>(<span class="params">callbackFn, initalValue</span>) &#123;</span><br><span class="line">    <span class="comment">// Step1：检验</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Array.prototype.reduce called on null or undefined&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callbackFn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> obj  = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">const</span> lenValue = obj.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> len = lenValue &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!len &amp;&amp; !initalValue) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The array contains no elements and initalValue is not provided&#x27;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step2: 确定accumulator初始值</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> accumulator;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (initalValue) &#123;</span><br><span class="line">        accumulator = initalValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> kPressent = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!kPressent &amp;&amp; k &lt; len) &#123;</span><br><span class="line">            <span class="keyword">const</span> pK = <span class="title class_">String</span>(k);</span><br><span class="line">            kPressent = obj.<span class="title function_">hasOwnProperty</span>(pK);   <span class="comment">// 是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (kPressent) &#123;</span><br><span class="line">                accumulator = obj[pK];</span><br><span class="line">            &#125;;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!kPressent) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The array contains error elements&#x27;</span>); 	</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step3:确定返回值</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            accumulator = <span class="title function_">callbackFn</span>(accumulator, obj[k], k, obj);</span><br><span class="line">        &#125;;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">myReduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev+curr, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum);   <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h4 id="2reduceright-es5"><a href="#（2）reduceRight-【ES5】" class="headerlink" title="（2）reduceRight()  【ES5】"></a>（2）reduceRight()  【ES5】</h4><blockquote>
<p><code>reduceRight()</code>与<code>reduce()</code>唯一不同的就是遍历方向是从最后一项到第一项，其余全部相同</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="1数组扁平化flat-es6"><a href="#（1）数组扁平化：flat-【ES6】" class="headerlink" title="（1）数组扁平化：flat()   【ES6】"></a>（1）数组扁平化：flat()   【ES6】</h4><blockquote>
<p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">flat</span>([depth])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>depth</code>（可选）：指定要提取嵌套数组的深度，默认为1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFlat</span>(<span class="params">arr, depth = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(curr) ? prev.<span class="title function_">concat</span>(<span class="title function_">myFlat</span>(curr, depth - <span class="number">1</span>)) : prev.<span class="title function_">concat</span>(curr);</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [[<span class="number">3</span>,<span class="number">4</span>]]]</span><br><span class="line"><span class="title function_">myFlat</span>(arr, <span class="number">1</span>)    <span class="comment">// [1, 2, [3,4]]</span></span><br><span class="line"><span class="title function_">myFlat</span>(arr, <span class="number">2</span>)    <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="1改变原数组方法"><a href="#（1）改变原数组方法" class="headerlink" title="（1）改变原数组方法"></a>（1）改变原数组方法</h4><p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%881%EF%BC%89push">push</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%884%EF%BC%89unshift">unshift</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%882%EF%BC%89pop">pop</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%883%EF%BC%89shift">shift</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%883%EF%BC%89shift">reverse</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%883%EF%BC%89shift">splice</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%9Asort">sort</a></p>
<h4 id="2es6新增方法"><a href="#（2）ES6新增方法" class="headerlink" title="（2）ES6新增方法"></a>（2）ES6新增方法</h4><p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%883%EF%BC%89Array-from-%E3%80%90ES6%E3%80%91">Array.from</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%882%EF%BC%89Array-of-%E3%80%90ES6%E3%80%91">Array.of</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%881%EF%BC%89%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6%EF%BC%9AcopyWithin">copyWithin()</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#2%E5%A1%AB%E5%85%85%E6%95%B0%E7%BB%84fill">fill()</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%882%EF%BC%89%E6%8C%89%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%90%9C%E7%B4%A2%EF%BC%9Afind-amp-amp-findIndex">find()</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%882%EF%BC%89%E6%8C%89%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%90%9C%E7%B4%A2%EF%BC%9Afind-amp-amp-findIndex">findIndex()</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%883%EF%BC%89Array-prototype-entries">entries()</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%882%EF%BC%89Array-prototype-keys">keys()</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%881%EF%BC%89Array-prototype-values">values()</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%881%EF%BC%89%E6%8C%89%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E6%90%9C%E7%B4%A2%EF%BC%9AindexOf-amp-amp-lastIndexOf-amp-amp-inclues">includes()</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/#%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%9Aflat">flat()</a></p>
<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D%E5%92%8Cundefined/">数组空位</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB/">map和forEach的区别</a></p>
<p><a href="%E5%8D%A0%E4%BD%8D">强大的reduce</a></p>
<p><a href="%E5%8D%A0%E4%BD%8D">深浅拷贝</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">MDN Array</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
        <category>和我一起做总结</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>和我一起做总结</tag>
        <tag>和我一起读红宝书</tag>
        <tag>ES6</tag>
        <tag>JavaScript数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 | map和forEach的区别</title>
    <url>/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="foreach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><blockquote>
<p><code>forEach</code>方法：针对每一个元素执行提供的函数，没有返回值，直接修改原数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote>
<p><code>map</code>方法：返回一个数组，其中数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果，并且仅对每一项已分配值得索引调用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item*<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);   <span class="comment">// [2,4,6]</span></span><br></pre></td></tr></table></figure>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li><code>map</code>方法适用于创建一个与原数组元素一一对应的数组，<code>map</code>方法还可以进一步结合<code>filter</code>，<code>reduce</code>等</li>
<li><code>forEach</code>方法适用于并不打算改变数据，而是想用数组的元素做一下操作的时候，比如打印，存入其他数组等</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>常见方法对比</category>
      </categories>
      <tags>
        <tag>常见方法对比</tag>
        <tag>JavaScript</tag>
        <tag>JavaScript数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 | 强大的reduce（含手写原理）</title>
    <url>/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_%E5%BC%BA%E5%A4%A7%E7%9A%84reduce/</url>
    <content><![CDATA[<h3 id="reduce相关语法"><a href="#reduce相关语法" class="headerlink" title="reduce相关语法"></a>reduce相关语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">reduce</span>(callbackFn, [initalValue]);</span><br></pre></td></tr></table></figure>

<p><strong>callbackFn</strong>：reducer函数</p>
<p>包含四个参数：</p>
<ul>
<li>previousValue：上一次调用callbackFn的返回值，在第一次调用的时候，如果指定了initalValue，则其值为initalValue，否则为数组索引为0的元素</li>
<li>currentValue：数组正在处理的元素，在第一次调用的时候，如果指定了initalValue，其值为数组索引为0的元素，否则为数组索引为1的元素</li>
<li>currentIndex：数组正在处理的元素的索引，如果指定了initalValue，起始索引为0，否则为1</li>
<li>array：用于遍历的数组</li>
</ul>
<p><strong>initalValue</strong>（可选）：</p>
<ul>
<li>第一次调用时作为previousValue的值，这是一个可选的参数</li>
</ul>
<p><strong>注意点</strong></p>
<ul>
<li>reducer不会改变原数组</li>
<li>reducer中的callbackFn需要返回值（因为需要作为下一次调用的previousValue）</li>
</ul>
<h3 id="reduce源码实现"><a href="#reduce源码实现" class="headerlink" title="reduce源码实现"></a>reduce源码实现</h3><p><strong>实现思路</strong></p>
<ul>
<li>类型检验：回调函数是否对函数，数组是否为空等</li>
<li>初始值提供检测，用于确定初始previousValue的值</li>
<li>返回累计值</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReduce</span> = <span class="keyword">function</span>(<span class="params">callbackFn, initalValue</span>) &#123;</span><br><span class="line">    <span class="comment">// Step1：类型检验</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Array.prototype.reduce called on null or undefined&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callbackFn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Callback must be a function&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> obj = <span class="title class_">Object</span>(<span class="variable language_">this</span>);    <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">const</span> lenValue = obj.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> len = lenValue &gt;&gt;&gt; <span class="number">0</span>;  <span class="comment">// #2</span></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span> &amp;&amp; !initalValue) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The array contains no elements and initalValue is not provided&#x27;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> accumulator;   <span class="comment">// 这里变量名为accumulator十分贴合reduce函数作为累加器使用的性质</span></span><br><span class="line">    <span class="comment">// Step2:初始accumulator的值确定</span></span><br><span class="line">    <span class="keyword">if</span> (initalValue) &#123;</span><br><span class="line">        <span class="comment">// 有initalValue，accumulator就为初始值</span></span><br><span class="line">        accumulator = initalValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有initalValue，就需要把数组的第一个值即arr[0]作为初始值</span></span><br><span class="line">        <span class="comment">// 这里别着急，我们还需要做进一步检测</span></span><br><span class="line">        <span class="keyword">let</span> kPressent = <span class="literal">false</span>;    <span class="comment">// #3</span></span><br><span class="line">        <span class="keyword">while</span> (!kPressent &amp;&amp; k &lt; len) &#123;</span><br><span class="line">            <span class="keyword">const</span> pK = <span class="title class_">String</span>(k);</span><br><span class="line">            kPressent = obj.<span class="title function_">hasOwnProperty</span>(pK);    <span class="comment">// 第一个检测到合法的元素作为</span></span><br><span class="line">            <span class="keyword">if</span> (kPressent) &#123;</span><br><span class="line">                accumulator = obj[pK];</span><br><span class="line">            &#125;;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!kPressent) &#123;      <span class="comment">// 数组没有合法元素，报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The array contains error elements&#x27;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到这里我们已经确定了accumulator的值</span></span><br><span class="line">    <span class="comment">// 注意：如果initalValue存在，k=0，如果不存在，则accumulator = 数组第一个合法元素，k因为之前也++了，k=k</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step3:确定callback的返回值</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> obj)&#123; <span class="comment">// # 4</span></span><br><span class="line">           	accumulator = <span class="title function_">callbackFn</span>(accumulator, obj[k], k, obj);</span><br><span class="line">        &#125;;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test:</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">myReduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev+curr, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum);   <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li><p>#1：<code>Object(this)</code></p>
<p><strong>Object构造函数作为一个工厂函数，能够根据传入的值的类型返回相应原始值包装类型的实例</strong></p>
<ul>
<li><code>null</code>或者<code>undefined</code>：将会创建并返回一个空对象</li>
<li>基本类型的值：构造其包装类型的对象</li>
<li>引用类型的值：仍然返回这个值，经他们复制的变量保有和源对象相同的引用地址</li>
</ul>
</li>
<li><p>#2：<code>len = lenValue &gt;&gt;&gt; 0</code></p>
</li>
</ul>
<p>​		<strong><code>&gt;&gt;&gt;</code>表示无符号右移，为了保证结果为非负整数</strong></p>
<ul>
<li><p>#3: 获取数组第一个有效元素</p>
<p>我觉得这里主要为了检测空值，虽然之前说了若是没有initalValue，previousValue就为array[0]，但是若出现数组前面有空值或者全部为<a href="https://superkatrina123.github.io/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D%E5%92%8Cundefined/">空值</a>的情况，previous的取值是需要慎重的，所以<strong>初始化previousValue准确地说应该是数组中合法的第一个元素</strong></p>
</li>
<li><p>#4：跳过空值（补课：<a href="https://superkatrina123.github.io/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D%E5%92%8Cundefined/">空值检测以及reduce对存在空值的数组处理</a>）</p>
</li>
</ul>
<h3 id="reduce应用场景"><a href="#reduce应用场景" class="headerlink" title="reduce应用场景"></a>reduce应用场景</h3><h4 id="累和ampamp累积"><a href="#累和-amp-amp-累积" class="headerlink" title="累和&amp;&amp;累积"></a>累和&amp;&amp;累积</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev+curr, <span class="number">0</span>);   <span class="comment">// 15</span></span><br><span class="line"><span class="keyword">let</span> mul = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev*curr, <span class="number">1</span>);   <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<h4 id="求最大值x2f最小值"><a href="#求最大值-x2F-最小值" class="headerlink" title="求最大值&#x2F;最小值"></a>求最大值&#x2F;最小值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maxValue = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(prev, curr));  <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> minValue = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(prev, curr));  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prev.<span class="title function_">indexOf</span>(curr) === -<span class="number">1</span>) &#123;</span><br><span class="line">        prev.<span class="title function_">push</span>(curr);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;, []);   <span class="comment">// [3, 7, 4, 2, 5, 8]</span></span><br></pre></td></tr></table></figure>

<h4 id="实现map函数"><a href="#实现map函数" class="headerlink" title="实现map函数"></a>实现map函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .map(callback)  callback = function(item, index, arr) &#123;...&#125;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMap</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">        	prev.<span class="title function_">push</span>(<span class="title function_">callback</span>(item, index, arr));</span><br><span class="line">        	<span class="keyword">return</span> prev;</span><br><span class="line">        &#125;, [])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback is not a fucntion&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">myMap</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>);   <span class="comment">// [2,4,6,8,10]</span></span><br></pre></td></tr></table></figure>

<h4 id="实现filter函数"><a href="#实现filter函数" class="headerlink" title="实现filter函数"></a>实现filter函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .filter(callback)  callback(item, index, arr) &#123;...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myFilter</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">callback</span>(item, index, arr)) &#123;</span><br><span class="line">                prev.<span class="title function_">push</span>(item);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;, [])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback is not a fucntion&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> filterArr = arr.<span class="title function_">myFilter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">3</span>);  <span class="comment">// [4,5]</span></span><br></pre></td></tr></table></figure>

<h4 id="实现compose函数"><a href="#实现compose函数" class="headerlink" title="实现compose函数"></a>实现compose函数</h4><blockquote>
<p>compose函数是指将函数按顺序执行，<strong>将若干个函数组合成一个函数来执行，并且每个函数执行的结果都能作为下一个函数的参数</strong></p>
</blockquote>
<p>假设有这样两个函数，一个求和函数，一个累积函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value += <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mul</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value *= <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般情况下，会这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">sum</span>(value);</span><br><span class="line">res = <span class="title function_">mul</span>(res);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);   <span class="comment">// 300</span></span><br></pre></td></tr></table></figure>

<p>若是有compose函数，将可以实现以下效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="title function_">compose</span>(sum, mul);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(value));  <span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> <span class="title function_">curr</span>(prev),x)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="按顺序执行promise"><a href="#按顺序执行Promise" class="headerlink" title="按顺序执行Promise"></a>按顺序执行Promise</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runPromiseInSequence</span>(<span class="params">arr, input</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">promiseChain, currentFunction</span>) =&gt;</span> promiseChain.<span class="title function_">then</span>(currentFunction),</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(input)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise function 1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p1</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(a * <span class="number">5</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise function 2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p2</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(a * <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 3  - will be wrapped in a resolved promise by .then()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params">a</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> a * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise function 4</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p4</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(a * <span class="number">4</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseArr = [p1, p2, f3, p4]</span><br><span class="line"><span class="title function_">runPromiseInSequence</span>(promiseArr, <span class="number">10</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)   <span class="comment">// 1200</span></span><br></pre></td></tr></table></figure>

<h4 id="实现数组扁平化"><a href="#实现数组扁平化" class="headerlink" title="实现数组扁平化"></a>实现数组扁平化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flat(depth) </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFlat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? prev.<span class="title function_">concat</span>(<span class="title function_">myFlat</span>(cur, depth-<span class="number">1</span>)) : prev.<span class="title function_">concat</span>(cur);</span><br><span class="line">        &#125;, [])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;this is not an array&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>,<span class="number">4</span>, [<span class="number">5</span>]], [<span class="number">6</span>, <span class="number">7</span>], [<span class="number">8</span>,[<span class="number">9</span>, [<span class="number">10</span>]]]]</span><br><span class="line"><span class="title function_">myFlat</span>(arr, <span class="number">2</span>)    <span class="comment">// [1, 2, 3,4, 5, 6, 7, 8,9, [10]]</span></span><br></pre></td></tr></table></figure>

<h4 id="统计数组元素出现次数"><a href="#统计数组元素出现次数" class="headerlink" title="统计数组元素出现次数"></a>统计数组元素出现次数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev.<span class="title function_">has</span>(curr)) &#123;</span><br><span class="line">            prev.<span class="title function_">set</span>(curr, prev.<span class="title function_">get</span>(curr)+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.<span class="title function_">set</span>(curr, <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, <span class="keyword">new</span> <span class="title class_">Map</span>())</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> m = <span class="title function_">count</span>(arr);   <span class="comment">// &#123;1=&gt;3, 2=&gt;3, 3=&gt;3, 4=&gt;1, 5=&gt;5, 6=&gt;2&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用函数组合实现管道"><a href="#使用函数组合实现管道" class="headerlink" title="使用函数组合实现管道"></a>使用函数组合实现管道</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params">input</span>) &#123; <span class="keyword">return</span> input + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decrement</span>(<span class="params">input</span>) &#123; <span class="keyword">return</span> input - <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">input</span>) &#123; <span class="keyword">return</span> input * <span class="number">2</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">halve</span>(<span class="params">input</span>) &#123; <span class="keyword">return</span> input / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pipeline = [increment, double, decrement];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = pipeline.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">total, func</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">func</span>(total);</span><br><span class="line">&#125;, <span class="number">8</span>);   <span class="comment">// 17</span></span><br></pre></td></tr></table></figure>



<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D%E5%92%8Cundefined/">空值检测</a></p>
<p><a href="%E5%8D%A0%E4%BD%8D">原始值包装类型</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">MDN reduce</a></p>
<p><a href="https://juejin.cn/post/6844903828538523656">你应该知道的JS: reduce的n种应用</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1885382">6个关于Reduce() 应用场景的用例</a></p>
<p><a href="https://segmentfault.com/a/1190000037682220">JavaScript之Array.reduce源码解读</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>和我一起做总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>和我一起做总结</tag>
        <tag>JavaScript数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 | 数组空位和undefined</title>
    <url>/2022/07/07/JavaScript/%E6%95%B0%E7%BB%84_%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D%E5%92%8Cundefined/</url>
    <content><![CDATA[<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p><strong>举例1</strong></p>
<p>之前在做算法题的时候遇到这样一个问题：我想创建一个n*m 的数组，于是我采用这样的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">10</span>, m = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> grid = <span class="title class_">Array</span>(n).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title class_">Array</span>(m))</span><br></pre></td></tr></table></figure>

<p>结果，<code>grid</code>打印的结果为<code>[empty × 10]</code>，这说明<code>map</code>根本没起作用，阅读红宝书的时候发现在第四版141页数组空位的地方有说明，原话是“<code>map()</code>会跳过空位置”，用专业术语说，**<code>map</code>仅对每一项已分配值的索引调用**，所以要是我想实现我想要的效果，我应该写如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">10</span>, m = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> grid = <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title class_">Array</span>(m))  </span><br><span class="line"><span class="comment">// [Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10), Array(10)]    length = 10</span></span><br></pre></td></tr></table></figure>

<p><strong>举例2</strong></p>
<p>我们已经直到，<code>map</code>方法会跳过空位置，并且红宝书第四版P140页提到”<code>ES6</code>中普遍将空位当作存在的元素，值为<code>undefined</code>“，下面的例子证实了这个说法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,,<span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">2</span>] === <span class="literal">undefined</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>再看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">undefined</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1_n = arr1.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;);   <span class="comment">// [2,2,,2]</span></span><br><span class="line"><span class="keyword">let</span> arr2_n = arr2.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;);    <span class="comment">// [2,2,2,2]</span></span><br></pre></td></tr></table></figure>

<p>咦？<code>undefined</code>的位置没有被跳过，而空值显然被跳过了</p>
<p>于是引发了两个问题：</p>
<ol>
<li>尽管空值位置的值是<code>undefined</code>，但是和<code>undefined</code>还是有本质的区别，究竟是怎么样的区别呢？</li>
<li><code>map</code>是怎么判断是空值还是<code>undefined</code>的呢？通过<code>arr[index] === undefined</code>显然是行不通的</li>
</ol>
<p>要解答这两个问题，就要回归到上面说的**<code>map</code>仅对每一项已分配值的索引调用**，<code>undefined</code>数据基本数据类型，当然属于值</p>
<h3 id="空位和undefined"><a href="#空位和undefined" class="headerlink" title="空位和undefined"></a>空位和undefined</h3><h4 id="产生空位的操作"><a href="#产生空位的操作" class="headerlink" title="产生空位的操作"></a>产生空位的操作</h4><p>以下操作均会产生空位</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array构造函数传一个数值表示数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>(<span class="number">5</span>);   <span class="comment">// [,,,,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面量创建</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [,,,,,];</span><br><span class="line"></span><br><span class="line"><span class="comment">// length属性</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [];</span><br><span class="line">arr3.<span class="property">length</span> = <span class="number">5</span>;   <span class="comment">// [,,,,,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引增加数组元素是超过数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line">arr4[<span class="number">10</span>] = <span class="number">5</span>;   <span class="comment">// [1,2,3,,,,,,,,,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数组元素产生空位</span></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> arr5[<span class="number">1</span>];   <span class="comment">// [1,,3]</span></span><br></pre></td></tr></table></figure>

<h4 id="用in操作符或者hasownproperty检测空值和undefined"><a href="#用in操作符或者hasOwnProperty-检测空值和undefined" class="headerlink" title="用in操作符或者hasOwnProperty()检测空值和undefined"></a>用in操作符或者hasOwnProperty()检测空值和undefined</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];   <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [,,,]   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> o = <span class="title class_">Object</span>(a);</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">hasOwnProperty</span>(<span class="number">2</span>);  <span class="comment">// false</span></span><br><span class="line">o.<span class="title function_">hasOwnProperty</span>(<span class="number">1</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>说明<code>[undefined, undefined, undefined]</code>在索引0处有值，<code>[,,,]</code>在索引0处没有值</p>
<h3 id="不同方法对空值的处理"><a href="#不同方法对空值的处理" class="headerlink" title="不同方法对空值的处理"></a>不同方法对空值的处理</h3><h4 id="忽略空值"><a href="#忽略空值" class="headerlink" title="忽略空值"></a>忽略空值</h4><blockquote>
<p><code>map()</code>：跳过空位，但会保留这个值</p>
<p><code>forEach()</code>, <code>filter()</code>, <code>every()</code>，<code>some()</code>，<code>reduce()</code>：跳过空位</p>
<p><code>join()</code>，<code>toString()</code>，<code>Array.from</code>，<code>展开运算符</code>：会将空位视为空字符串</p>
<p><code>fill()</code>：将空位视为正常值</p>
<p><code>copyWithin()</code>：连着空位一起拷贝</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>);  <span class="comment">// [2,,6];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,,,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &lt; <span class="number">4</span>);  <span class="comment">// [1,2,3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,,<span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>)  <span class="comment">// 1--3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fill</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>).<span class="title function_">fill</span>(<span class="number">0</span>);   <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// copyWithin()</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">copyWithin</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);   <span class="comment">// [1,4,,4,,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce()</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,,<span class="number">4</span>];</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev+cur);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/178302866">JS中的数组空位和undefined</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>常见方法对比</category>
        <category>小众知识点</category>
      </categories>
      <tags>
        <tag>常见方法对比</tag>
        <tag>JavaScript</tag>
        <tag>小众知识点</tag>
        <tag>JavaScript数组</tag>
      </tags>
  </entry>
  <entry>
    <title>标签 | script元素及加载方式</title>
    <url>/2022/07/15/JavaScript/%E6%A0%87%E7%AD%BE_script%E5%85%83%E7%B4%A0%E5%8F%8A%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="ltscriptgt元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a><code>&lt;script&gt;</code>元素</h3><blockquote>
<p>将JavaScript插入到HTML中主要依赖的是<code>&lt;script&gt;</code>元素</p>
</blockquote>
<h4 id="ltscriptgt特性"><a href="#lt-script-gt-特性" class="headerlink" title="&lt;script&gt;特性"></a><code>&lt;script&gt;</code>特性</h4><ul>
<li><code>async</code>（可选）：表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载【只对外部脚本文件有效】</li>
<li><code>charset</code>（可选）：使用<code>src</code>属性指定的代码字符集【这个属性很少使用，因为大多数浏览器不在乎它的值】</li>
<li><code>crossorigin</code>（可选）：配置相关请求的<code>CORS</code>（跨源资源共享）设置【默认不使用CORS】<ul>
<li><code>crossorigin=&quot;anonymous&quot;</code>配置文件请求不必设置凭据标志</li>
<li><code>crossorigin=&quot;use-credentials&quot;</code>设置凭据标志，意味着出站请求会包含凭据</li>
</ul>
</li>
<li><code>defer</code>（可选）：表示脚本立即下载，但是可以延迟到文档完全被解析和显示之后再执行【只对外部脚本文件有效】</li>
<li><code>integrity</code>（可选）：允许比对接收到的资源和指定的加密签名以验证子资源完整性（<code>SRI，Subresource Integrity</code>）<ul>
<li>如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行</li>
<li>这个属性可以用于确保内容分发网络（<code>CDN，Content Delivery Network</code>）不会提供恶意内容</li>
</ul>
</li>
<li><code>language</code>（废弃）：最初用于表示代码块中的脚本语言（如<code>&quot;JavaScript&quot;</code>、<code>&quot;JavaScript 1.2&quot;</code>或<code>&quot;VBScript&quot;</code>）【大多数浏览器都会忽略这个属性，不应该再使用它】</li>
<li><code>src</code>（可选）：表示包含要执行的代码的外部文件</li>
<li><code>type</code>（可选）：代替language，表示代码块中脚本语言的内容类型（也称MIME 类型）<ul>
<li>按照惯例，这个值始终都是<code>&quot;text/javascript&quot;</code>，尽管<code>&quot;text/javascript&quot;</code>和<code>&quot;text/ecmascript&quot;</code>都已经废弃了</li>
<li><code>JavaScript</code> 文件的<code>MIME</code> 类型通常是<code>&quot;application/x-javascript&quot;</code>，不过给<code>type</code> 属性这个值有可能导致脚本被忽略</li>
<li>在非<code>IE</code> 的浏览器中有效的其他值还有<code>&quot;application/javascript&quot;</code>和<code>&quot;application/ecmascript&quot;</code></li>
<li>如果这个值是<code>module</code>，则代码会被当成<code>ES6 </code>模块，而且只有这时候代码中才能出现<code>import</code> 和<code>export </code>关键字</li>
</ul>
</li>
</ul>
<h4 id="使用ltscriptgt的元素"><a href="#使用-lt-script-gt-的元素" class="headerlink" title="使用&lt;script&gt;的元素"></a>使用<code>&lt;script&gt;</code>的元素</h4><ol>
<li>在HTML中嵌入代码</li>
<li>通过<code>&lt;script&gt;</code>标签引入外部JavaScript代码</li>
</ol>
<blockquote>
<p>一般更加推荐把JavaScript代码放到外部文件中</p>
<p>理由如下：</p>
<ul>
<li><strong>可维护性</strong>：JavaScript 代码如果分散到很多HTML 页面，会导致维护困难，而用一个目录保存所有JavaScript 文件，则更容易维护，这样开发者就可以独立于使用它们的HTML 页面来编辑代码</li>
<li><strong>缓存</strong>：浏览器会根据特定的设置缓存所有外部链接的JavaScript 文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次，这最终意味着页面加载更快</li>
<li><strong>适应未来</strong>：通过把JavaScript 放到外部文件中，就不必考虑用<code>XHTML</code>或注释黑科技。包含外部JavaScript 文件的语法在<code>HTML</code>和<code>XHTML</code>中是一样的</li>
</ul>
</blockquote>
<p>注意：</p>
<ul>
<li><p>使用了<code>src</code> 属性的<code>&lt;script&gt;</code>元素不应该再在<code>&lt;script&gt;</code>和<code>&lt;script&gt;</code>签中再包含其他JavaScript 代码</p>
<ul>
<li>如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。</li>
</ul>
</li>
<li><p>【JSONP跨域原理】<code>&lt;script&gt;</code>元素一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的JavaScript，跟<code>&lt;img&gt;</code>元素很像，<code>&lt;script&gt;</code>元素的<code>src</code> 属性可以是一个完整的URL，而且这个URL 指向的资源可以跟包含它的HTML 页面不在同一个域中文件</p>
</li>
<li><p>【XSS攻击】来自外部域的代码会被当成加载它的页面的一部分来加载和解释。这个能力可以让我们通过不同的域分发JavaScript，不过，引用了放在别人服务器上的JavaScript 文件时要格外小心，因为恶意的程序员随时可能替换这个文件。在包含外部域的JavaScript 文件时，要确保该域是自己所有的，或者该域是一个可信的来源，<code>&lt;script&gt;</code>标签的integrity 属性是防范这种问题的一个武器，但这个属性也不是所有浏览器都支持</p>
</li>
<li><p>【顺序加载】在没有使用<code>defer</code>或者<code>async</code>的情况下，浏览器都会按照<code>&lt;script&gt;</code>在页面中出现的顺序依次解释它们</p>
</li>
</ul>
<h3 id="ltscriptgt元素位置及加载"><a href="#lt-script-gt-元素位置及加载" class="headerlink" title="&lt;script&gt;元素位置及加载"></a><code>&lt;script&gt;</code>元素位置及加载</h3><p>我们知道，浏览器解析HTML的时候是从上到下依次解析的，如果把<code>&lt;script&gt;</code>标签都放在<code>&lt;head&gt;</code>标签里面，那么这就意味着必须把所有JavaScript代码都下载、解析和解释完成后，才能开始渲染页面（因为页面在浏览器解析到<code>&lt;body&gt;</code>的起始标签时才开始渲染），这也就是【JavaScript会阻塞浏览器解析HTML文件】，这样导致的后果就是<strong>页面渲染会明显延迟，期间浏览器窗口完全空白，给用户带来不好的体验</strong></p>
<p>为了解决这个问题，可以采用如下方法：</p>
<h4 id="把script元素放在body底部"><a href="#把script元素放在body底部" class="headerlink" title="把script元素放在body底部"></a>把script元素放在body底部</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，页面会在处理JavaScript之前进行渲染</p>
<h4 id="延迟加载脚本"><a href="#延迟加载脚本" class="headerlink" title="延迟加载脚本"></a>延迟加载脚本</h4><blockquote>
<p>HTML4.01中引入defer属性，表示脚本可以立即下载但是延迟到文档完全被解析和显示之后再执行【对外部脚本文件才有效】</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="异步执行脚本"><a href="#异步执行脚本" class="headerlink" title="异步执行脚本"></a>异步执行脚本</h4><blockquote>
<p>HTML5中引入async属性，表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载【只对外部脚本文件有效】</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>defer和async的区别：</p>
<p>defer可以保证脚本顺序执行，但是async不能保证，因为<strong>给脚本添加async 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本</strong></p>
</blockquote>
<h4 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h4><blockquote>
<p>除了通过<code>&lt;script&gt;</code>元素加载脚本，还可以通过JavaScript使用DOM API的方式向DOM中动态添加script元素加载指定的脚本</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;gibberish.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>

<p>默认情况下，以这种方式创建的<code>&lt;script&gt;</code>元素是以异步方式加载的，相当于添加了<code>async</code>属性</p>
<p><strong>存在问题</strong>：</p>
<ol>
<li>并不是所有浏览器都支持<code>async</code>属性</li>
<li>以这种方式获取的资源对浏览器预加载器是不可见的，这会严重影响它们在资源获取队列中的优先级，进而影响性能</li>
</ol>
<p><strong>解决方式</strong>：</p>
<ol>
<li><p>如果要统一动态脚本的加载行为，可以明确将其设置为同步加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;gibberish.js&#x27;</span>;</span><br><span class="line">script.<span class="property">async</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>
</li>
<li><p>要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;gibberish.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="拓展ltnoscriptgt元素"><a href="#拓展：-lt-noscript-gt-元素" class="headerlink" title="拓展：&lt;noscript&gt;元素"></a>拓展：<code>&lt;noscript&gt;</code>元素</h3><blockquote>
<p><code>&lt;noscript&gt;</code>元素给不支持JavaScript的浏览器提供替代内容</p>
</blockquote>
<p><code>&lt;noscript&gt;</code>元素可以包含任何可以出现在<code>&lt;body&gt;</code>中的HTML 元素，<code>&lt;script&gt;</code>除外</p>
<p>在下列两种情况下，浏览器将显示包含在<noscript>中的内容：</noscript></p>
<ul>
<li>浏览器不支持脚本</li>
<li>浏览器对脚本的支持被关闭</li>
</ul>
<p>任何一个条件被满足，包含在<code>&lt;noscript&gt;</code>中的内容就会被渲染，否则，浏览器不会渲染<code>&lt;noscript&gt;</code>中的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This page requires a JavaScript-enabled browser.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子是在脚本不可用时让浏览器显示一段话，如果浏览器支持脚本，则用户永远不会看到它</p>
<p><noscript>元素可以包含任何可以出现在<body>中的HTML 元素，<script>除外。在下列两种<br>情况下，浏览器将显示包含在<noscript>中的内容：</p>
</script></body></noscript></p>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起读红宝书</tag>
      </tags>
  </entry>
  <entry>
    <title>类 | 类构造函数、实例、原型和类成员</title>
    <url>/2022/07/11/JavaScript/%E7%B1%BB_%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="定义类的方式"><a href="#定义类的方式" class="headerlink" title="定义类的方式"></a>定义类的方式</h3><ul>
<li>类声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类声明与函数声明不同之处在于：</p>
<ul>
<li><p>函数声明有声明提前，类声明没有</p>
</li>
<li><p>函数受函数作用域限制，而类受块作用域限制</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ClassFn</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn);   <span class="comment">// fn() &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassFn</span>);   <span class="comment">// Uncaught ReferenceError: ClassFn is not defined</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>类表达式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Animal</span> = <span class="keyword">class</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类表达式的名称是可选的</p>
<p>在把类表达式赋值给变量后，可以通过name 属性取得类表达式的名称字符串</p>
<p>但不能在类表达式作用域外部访问这个标识符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">PersonName</span> &#123;</span><br><span class="line">	<span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>, <span class="title class_">PersonName</span>.<span class="property">name</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">identify</span>(); <span class="comment">// PersonName PersonName</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>); <span class="comment">// PersonName</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PersonName</span>); <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h3><blockquote>
<p>类可以包含<strong>构造函数方法</strong>、<strong>实例方法</strong>、<strong>获取函数</strong>、<strong>设置函数</strong>、<strong>静态类方法</strong>，但都不是必须的，空的类定义照样有效</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空类定义，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 有构造函数的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有获取函数的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> &#123;</span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">myBaz</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有静态方法的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Qux</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="title function_">myQux</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><blockquote>
<p><code>constructor</code>关键词用于在类定义块内部创建类的构造函数（<code>constructor</code>会告诉解释器，在<code>new</code>操作符的时候应该调用这个函数创建新的实例）</p>
<p>构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数</p>
</blockquote>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><blockquote>
<p>使用new 操作符实例化Person 的操作等于使用new 调用其构造函数</p>
</blockquote>
<p>补课：<a href="https://superkatrina123.github.io/2022/07/06/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86/%E6%89%8B%E5%86%99%E5%8E%9F%E7%90%86_new/">new操作符会发生什么？包含手写</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person ctor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetable</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">// person ctor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vegetable</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v.<span class="property">color</span>);   <span class="comment">// orange</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类实例化时传入的参数会用作构造函数的参数（如果不需要参数，则类名后面的括号也是可选的）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">name</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jake&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3.<span class="property">name</span>); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>默认情况下，类构造函数会在执行之后返回this 对象</p>
<blockquote>
<p>构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的<code>this</code>对象，那么这个对象会被销毁</p>
<p>不过，如果返回的不是<code>this</code>对象，而是其他对象，那么这个对象不会通过<code>instanceof </code>操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">override</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (override) &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				<span class="attr">bar</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(),</span><br><span class="line">p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// Person&#123; foo: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// &#123; bar: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为p2返回的不是this对象，而是 &#123;bar: &#x27;bar&#x27;&#125;， 因此instance检测不出p2和Person类的关联</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类构造函数与构造函数的主要区别是：<strong>调用类构造函数必须使用new 操作符</strong></p>
<blockquote>
<p>普通构造函数如果不使用<code>new</code>调用，那么就会以全局的<code>this</code>（通常是<code>window</code>）作为内部对象</p>
<p>调用类构造函数时如果忘了使用<code>new</code>则会抛出错误</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把window 作为this 来构建实例</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Animal</span>();</span><br><span class="line"><span class="comment">// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实例化类构造函数后可以在实例上引用构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line"><span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对类构造函数的引用创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> p1.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure>

<h3 id="类是特殊的函数"><a href="#类是特殊的函数" class="headerlink" title="类是特殊的函数"></a>类是特殊的函数</h3><ul>
<li>typeof检测类为function</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Person</span>    <span class="comment">//  &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类有prototype属性，原型有constructor属性指向类自身</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);                         <span class="comment">// &#123;constructor: f()&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>instaceof操作符可以用于检查构造函数的原型是否存在于实例的原型链中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类本身在使用new操作符时会被当成构造函数，但是类的constructor方法不会被当作构造函数，因此instanceof操作符会返回false，但是创建实例时直接将类构造函数当作普通构造函数来使用，instanceof操作符返回true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()         <span class="comment">// 直接将类使用构造函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">constructor</span> === <span class="title class_">Person</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>);  <span class="comment">// false   类的constructor方法不会被当作构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>.<span class="title function_">constructor</span>(<span class="params"></span>);    <span class="comment">// 直接将类构造函数当作普通构造函数来使用，就满足普通构造函数的特点了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">constructor</span> === <span class="title class_">Person</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	通俗来说，谁调用new操作符生成实例的，那么谁就是实例的构造函数</span></span><br><span class="line"><span class="comment">	实例.constructor === 谁</span></span><br><span class="line"><span class="comment">	实例 instanceof 谁 === true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类可以作为参数传递</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类可以像函数一样在任何地方定义，比如在数组中</span></span><br><span class="line"><span class="keyword">let</span> classList = [</span><br><span class="line">	<span class="keyword">class</span> &#123;</span><br><span class="line">		<span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">id_</span> = id;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`instance <span class="subst">$&#123;<span class="variable language_">this</span>.id_&#125;</span>`</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">classDefinition, id</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">classDefinition</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="title function_">createInstance</span>(classList[<span class="number">0</span>], <span class="number">3141</span>); <span class="comment">// instance 3141</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与立即调用函数类似，类可以立即实例化</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; (<span class="string">&#x27;Katrina&#x27;</span>);    <span class="comment">// Katrina</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);   <span class="comment">// Person &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="实例-原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h2><h3 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h3><ul>
<li>每个实例都对应着一个<strong>唯一</strong>的成员对象，这意味着所有成员都不会在原型上共享</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Katrina&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;Kate&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">sayName</span>();  <span class="comment">// &#x27;Katrina&#x27;</span></span><br><span class="line">p2.<span class="title function_">sayName</span>();  <span class="comment">// &#x27;Katrina&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span> === p2.<span class="property">name</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">sayName</span> === p2.<span class="property">sayName</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">friends</span> === p2.<span class="property">friends</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = p1.<span class="property">friends</span>[<span class="number">0</span>];</span><br><span class="line">p2.<span class="property">name</span> = p2.<span class="property">friends</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">sayName</span>();  <span class="comment">// &#x27;Kate&#x27;</span></span><br><span class="line">p2.<span class="title function_">sayName</span>();  <span class="comment">// &#x27;Lisa&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="原型方法和访问器"><a href="#原型方法和访问器" class="headerlink" title="原型方法和访问器"></a>原型方法和访问器</h3><blockquote>
<p>为了在实例间共享方法，类定义语法把<strong>在类块中定义的方法</strong>作为<strong>原型方法</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Katrina&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">        <span class="comment">// 添加到this 的所有内容都会存在于不同的实例上</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&#x27;Kate&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">sayHello</span>();  <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">sayHello</span> === p2.<span class="property">sayHello</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Kate&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected identifier</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="title class_">Symbol</span>(<span class="string">&#x27;symbolKey&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="title function_">stringKey</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;invoked stringKey&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	[symbolKey]() &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;invoked symbolKey&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	[<span class="string">&#x27;computed&#x27;</span> + <span class="string">&#x27;Key&#x27;</span>]() &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;invoked computedKey&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">stringKey</span>(); <span class="comment">// invoked stringKey</span></span><br><span class="line">p[symbolKey](); <span class="comment">// invoked symbolKey</span></span><br><span class="line">p.<span class="title function_">computedKey</span>(); <span class="comment">// invoked computedKey</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类定义也支持获取和设置访问器。语法与行为跟普通对象一样</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name_</span> = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;Katrina&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);   <span class="comment">// &#x27;Katrina&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h3><blockquote>
<p>可以在类上定义静态方法</p>
<p>这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例</p>
<p>与原型成员类似，静态成员每个类上只能有<strong>一个</strong></p>
<p>静态类成员在类定义中使用<code>static</code>关键字作为前缀</p>
<p>在静态成员中，<code>this</code>引用类自身，而构造函数的<code>this</code>是指向实例的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 添加到this	的所有内容都会存在于不同的实例上</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line">	<span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prototype&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义在类本身上</span></span><br><span class="line">	<span class="keyword">static</span> <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// this指向Peron类本身</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;class&#x27;</span>, <span class="variable language_">this</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">locate</span>();    <span class="comment">// instance Perons&#123;&#125;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">protype</span>.<span class="title function_">locate</span>();  <span class="comment">// prototype &#123;constructor: ... &#125;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">locate</span>(); <span class="comment">// class, class Person &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>静态类方法适合作为实例工厂</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">age</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age_</span> = age;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="title function_">sayAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age_</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">static</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// 使用随机年龄创建并返回一个Person 实例</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">create</span>()); <span class="comment">// Person &#123; age_: ... &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h3><ul>
<li>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类上定义数据成员</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">greeting</span> = <span class="string">&#x27;My name is&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型上定义数据成员</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">sayName</span>(); <span class="comment">// My name is Jake</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h3><ul>
<li>类定义语法支持在<strong>原型</strong>和<strong>类本身上</strong>定义生成器方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 在原型上定义生成器方法</span></span><br><span class="line">	*<span class="title function_">createNicknameIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">&#x27;J-Dog&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 在类上定义生成器方法</span></span><br><span class="line">	<span class="keyword">static</span> *<span class="title function_">createJobIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">&#x27;Butcher&#x27;</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">&#x27;Baker&#x27;</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">&#x27;Candlestick maker&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jobIter = <span class="title class_">Person</span>.<span class="title function_">createJobIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Butcher</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Baker</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Candlestick maker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.<span class="title function_">createNicknameIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Jack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Jake</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">nicknames</span> = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	*[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">		<span class="keyword">yield</span> *<span class="variable language_">this</span>.<span class="property">nicknames</span>.<span class="title function_">entries</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(nickname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>或者可以只返回迭代器实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">nicknames</span> = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nicknames</span>.<span class="title function_">entries</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起读红宝书</tag>
        <tag>JavaScript类</tag>
      </tags>
  </entry>
  <entry>
    <title>类 | 深刻理解super</title>
    <url>/2022/07/14/JavaScript/%E7%B1%BB_%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3super/</url>
    <content><![CDATA[<blockquote>
<p>super这个关键词既可以当<strong>对象</strong>使用，也可以当<strong>函数</strong>使用</p>
</blockquote>
<h3 id="super作为函数使用"><a href="#super作为函数使用" class="headerlink" title="super作为函数使用"></a>super作为函数使用</h3><blockquote>
<p>super作为函数使用时，只能在子类的构造函数中【目的是为了调用父类的构造函数】 &#x3D;&gt; super表示父类构造函数，但是this指向当前子类的构造函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>.<span class="property">name</span>);  <span class="comment">// new.target 指向当前正在执行的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Father</span>();   <span class="comment">// Father</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Son</span>();   <span class="comment">// Son</span></span><br></pre></td></tr></table></figure>

<p>在子类的<code>constructor</code>中必须调用<code>super()</code>方法，因为子类没有自己的<code>this</code>对象，而是要继承父类的<code>this</code>对象，但是此时<code>this</code>指向的是子类的构造函数，此时<code>super</code>就表示了父类的构造函数，<code>super()</code>此时相当于<code>Father.prototype.constructor.call(this, props)</code></p>
<h3 id="super作为对象使用"><a href="#super作为对象使用" class="headerlink" title="super作为对象使用"></a>super作为对象使用</h3><h4 id="super作为普通方法使用"><a href="#super作为普通方法使用" class="headerlink" title="super作为普通方法使用"></a>super作为普通方法使用</h4><h5 id="1super指向的是父类的原型对象"><a href="#（1）super指向的是父类的原型对象" class="headerlink" title="（1）super指向的是父类的原型对象"></a>（1）super指向的是父类的原型对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">c</span>());   <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，子类中的<code>super.c()</code>，就是把<code>super</code>当作一个对象使用，对象里面有<code>c</code>方法，因此<code>super</code>在普通函数中指向，<code>Father.prototype</code>，也就是说<code>super.c()</code>相当于<code>Father.prototype.c()</code></p>
<h5 id="2通过super调用父类方法时super内部的this指向子类的实例"><a href="#（2）通过super调用父类方法时，super内部的this指向子类的实例" class="headerlink" title="（2）通过super调用父类方法时，super内部的this指向子类的实例"></a>（2）通过super调用父类方法时，super内部的this指向子类的实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    x = <span class="number">7</span>;</span><br><span class="line">    <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">77</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    x = <span class="number">777</span>;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">fun</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">777</span>;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">print</span>();   <span class="comment">// 777</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Son</span>().<span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果没有 this.x = 7777 则返回77</span></span><br><span class="line"><span class="comment">	如果没有 super.fun() 则返回 777</span></span><br><span class="line"><span class="comment">	如果没有 this.x = 777 则返回 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>此时的<code>super</code>可以替换<code>this</code>，与<code>this.print()</code>等价</p>
<h5 id="3当通过super为子类属性赋值时super就是this"><a href="#（3）当通过super为子类属性赋值时，super就是this" class="headerlink" title="（3）当通过super为子类属性赋值时，super就是this"></a>（3）当通过super为子类属性赋值时，super就是this</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">c</span> = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="property">c</span> = <span class="number">7</span>;     <span class="comment">// 为子类赋值的情况下，super为this</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">c</span>);   <span class="comment">// 7  super获取的是父类的原型</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">c</span>);   <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋值的情况下<code>super</code>就是<code>this</code></p>
<h4 id="super作为静态方法使用"><a href="#super作为静态方法使用" class="headerlink" title="super作为静态方法使用"></a>super作为静态方法使用</h4><h5 id="1super指向的是父类"><a href="#（1）super指向的是父类" class="headerlink" title="（1）super指向的是父类"></a>（1）super指向的是父类</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">c</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="property">c</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;      <span class="comment">// 为子类赋值的情况下super为this</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">c</span>());    <span class="comment">// 11    super为父类的prototype</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">c</span>());    <span class="comment">// 1      this指向子类构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Son</span>().<span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;           <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">c</span>(<span class="params"></span>) &#123;                  <span class="comment">// 原型对象中的方法</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">c</span>();          <span class="comment">// super指向父类 调用的是静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">s</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">c</span>();          <span class="comment">// super指向父类原型对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="title function_">son</span>();       <span class="comment">// 2    调用的是Son的静态方法，指向父类静态方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Son</span>().<span class="title function_">c</span>();   <span class="comment">// 22   调用的是Son的原型方法，指向父类原型方法</span></span><br></pre></td></tr></table></figure>

<h5 id="2在子类的静态方法中通过super调用父类方法是super内部的this指向子类"><a href="#（2）在子类的静态方法中通过super调用父类方法是，super内部的this指向子类" class="headerlink" title="（2）在子类的静态方法中通过super调用父类方法是，super内部的this指向子类"></a>（2）在子类的静态方法中通过super调用父类方法是，super内部的this指向子类</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();               <span class="comment">// 构造函数内调用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">4</span>;				<span class="comment">// this指向子类构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 如果没有this.x = 5,则 Son.x 打印为1</span></span><br><span class="line">        <span class="comment">// 如果既没有this.x = 5，也没有Bar.x = 1，则打印3</span></span><br><span class="line">        <span class="comment">// 如果既没有this.x = 5，也没有Bar.x = 1 和 x =3，则打印undefined，不会输出构造函数中的2</span></span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">print</span>();         <span class="comment">// super</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Son</span>.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>注意看注释~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    name = <span class="string">&#x27;Father&#x27;</span>;</span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();             <span class="comment">// 这里调用super()是为了调用父类的构造函数</span></span><br><span class="line">        <span class="comment">// console.log(this);    // this指向的是子类的构造函数  this 为 Son &#123;name:&#x27;Father&#x27;, age: 18&#125; </span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(this.getAge)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAge</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Son</span>().<span class="title function_">getName</span>());                   <span class="comment">// Father</span></span><br><span class="line"><span class="comment">// console.log(new Son().getAge());                 // 报错 因为 new Son().getAge()调用的是子类构造函数的getAge函数，它一直在调用自身</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Son</span>().<span class="property">getAge</span>.<span class="title function_">call</span>(&#123;<span class="attr">age</span>:<span class="number">2</span>&#125;));        <span class="comment">// 报错 这里this是&#123;age:2&#125;, 此时this.getAge为undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/6844903638674980872">理解 es6 class 中 constructor 方法 和 super 的作用</a></p>
<p><a href="https://www.xiaohongshu.com/discovery/item/62cee8070000000001029e53?share_from_user_hidden=true&xhsshare=WeixinSession&appuid=59d31f36de5fb428650bfe9f&apptime=1657770326">前端面试之关于super的全方位解读</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>继承</tag>
        <tag>JavaScript类</tag>
      </tags>
  </entry>
  <entry>
    <title>类 | 类继承</title>
    <url>/2022/07/11/JavaScript/%E7%B1%BB_%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h3><blockquote>
<p>使用<code>extends</code>关键字就可以继承任何拥有<code>[[Construct]]</code>和原型的对象</p>
</blockquote>
<ul>
<li>不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）【任何可以解析为一个类或者一个构造函数的表达式都是有效的】</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Women</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> w = <span class="keyword">new</span> <span class="title class_">Women</span>();    <span class="comment">// 新建实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(w <span class="keyword">instanceof</span> <span class="title class_">Women</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(w <span class="keyword">instanceof</span> <span class="title class_">Person</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承普通的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Men</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m <span class="keyword">instanceof</span> <span class="title class_">Men</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m <span class="keyword">instanceof</span> <span class="title class_">Person</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>派生类可以通过原型链访问到类上的方法和原型上定义的方法，this的值会反映调用相应方法的类或者实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">sayHelloPorototype</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> say hello, <span class="subst">$&#123;<span class="variable language_">this</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sayHelloClass</span>(<span class="params">name</span>) &#123;</span><br><span class="line">     	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> say hello, <span class="subst">$&#123;<span class="variable language_">this</span>&#125;</span>`</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Women</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> w1 = <span class="keyword">new</span> <span class="title class_">Women</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">sayHelloPorototype</span>(<span class="string">&#x27;Katrina&#x27;</span>);   <span class="comment">// Katrina say hello, Person&#123;&#125;</span></span><br><span class="line">w1.<span class="title function_">sayHelloPorototype</span>(<span class="string">&#x27;Jack&#x27;</span>);      <span class="comment">// Jack say hello, Women&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">sayHelloClass</span>(<span class="string">&#x27;Katrina1&#x27;</span>);   <span class="comment">// Katrina1 say hello, class Person &#123;&#125;</span></span><br><span class="line"><span class="title class_">Women</span>.<span class="title function_">sayHelloClass</span>(<span class="string">&#x27;Jack1&#x27;</span>);       <span class="comment">// Jack1 say hello, class Women extends Person&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>extends</code>也可以在类表达式中使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">sayHelloPorototype</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> say hello, <span class="subst">$&#123;<span class="variable language_">this</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sayHelloClass</span>(<span class="params">name</span>) &#123;</span><br><span class="line">     	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> say hello, <span class="subst">$&#123;<span class="variable language_">this</span>&#125;</span>`</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Women</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数-homeobject和super"><a href="#构造函数、HomeObject和super" class="headerlink" title="构造函数、HomeObject和super()"></a>构造函数、HomeObject和super()</h3><blockquote>
<p>派生类可以通过<code>super</code>关键字引用它们的原型</p>
</blockquote>
<ul>
<li><strong>构造函数：</strong>在类构造函数中使用<code>super</code>可以调用父类构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hasEngie</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();  <span class="comment">// 相当于super.constructor()</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：千万不要在调用super()之前引用this,否则会抛出ReferenceError</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>);   <span class="comment">// true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);   <span class="comment">// Bus &#123;hasEngie: true&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>静态方法：</strong>在静态方法中可以通过super 调用继承的类上定义的静态方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;vehicle&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">identify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bus</span>.<span class="title function_">identify</span>();   <span class="comment">// &#x27;vehicle&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用super时要注意的几个问题"><a href="#使用super时要注意的几个问题" class="headerlink" title="使用super时要注意的几个问题"></a>使用super时要注意的几个问题</h4><ul>
<li>super只能在派生类的构造函数和静态方法中使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">super</span>();</span><br><span class="line">		<span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能单独调用super关键词，要么用它调用构造函数，要么用它引用静态方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">		<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>);</span><br><span class="line">	<span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用super()会调用父类构造函数，并将返回的实例赋值给this（也就是this指向实例）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();    <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>);   <span class="comment">// true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);   <span class="comment">// Bus&#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>(<span class="number">1234</span>).<span class="property">id</span>);   <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有定义派生类构造函数，在实例化派生类时会调用super()，而且会传入所有传给派生类的参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>(<span class="number">1234</span>).<span class="property">id</span>);   <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在类构造函数中，不能在调用super()之前引用this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line"><span class="comment">// ReferenceError: Must call super constructor in derived class</span></span><br><span class="line"><span class="comment">// before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在派生类中显式定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Van</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeep</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Katrina&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Car</span>()); <span class="comment">// Car &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>()); <span class="comment">// Bus &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Van</span>()); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Jeep</span>());   <span class="comment">// Uncaught ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><blockquote>
<p>抽象基类：可以供其他类继承，但是本身不会实例化</p>
<p>可以通过判断new.target来阻止实例化</p>
<p>补课：<a href="https://superkatrina123.github.io/2022/07/09/JavaScript/%E5%87%BD%E6%95%B0_new.targer%E5%B1%9E%E6%80%A7/">new.target</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;   <span class="comment">// 就说明抽象基类被用new实例化了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span>&#123;&#125;   <span class="comment">// 抽象基类是可以被继承的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();         <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vehicle</span>();		<span class="comment">// class Vehicle &#123;&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// Uncaught Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;   <span class="comment">// 就说明抽象基类被用new实例化了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">foo</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Inheriting class must define foo()&#x27;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Van</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();	  <span class="comment">// success</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Van</span>();   <span class="comment">// Inheriting class must define foo()</span></span><br></pre></td></tr></table></figure>

<h3 id="基础内置类型"><a href="#基础内置类型" class="headerlink" title="基础内置类型"></a>基础内置类型</h3><blockquote>
<p>类继承内置引用类型方便扩展内置类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;   <span class="comment">// 注意：之前提到过extends不仅可以继承一个类，也可以继承普通的构造函数</span></span><br><span class="line">    <span class="title function_">shuffle</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 洗牌算法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i+<span class="number">1</span>));</span><br><span class="line">            [<span class="variable language_">this</span>[i], <span class="variable language_">this</span>[j]] = [<span class="variable language_">this</span>[j], <span class="variable language_">this</span>[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>);       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">a.<span class="title function_">shuffle</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">// [3, 1, 2, 5, 4]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>有些内置类型的方法会返回新实例，默认情况下，返回实例的类型与原始实例的类型是一致的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果想覆盖这个默认行为，则可以覆盖<code>Symbol.species</code>访问器，这个访问器决定在创建返回的实例时使用的类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Array</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="类混入"><a href="#类混入" class="headerlink" title="类混入"></a>类混入</h3><blockquote>
<p>类混入：把不同类的行为集中到一个类</p>
<p>混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类</p>
</blockquote>
<p>假设现在有一个需求：如果<code>Person</code>类需要组合<code>A</code>、<code>B</code>、<code>C</code>，则需要某种机制实现<code>B </code>继承<code>A</code>，<code>C </code>继承<code>B</code>，而<code>Person</code>再继承<code>C</code>，从而把<code>A</code>、<code>B</code>、&#96;C 组合到这个超类中</p>
<p>实现策略：定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类，这些组合函数可以连缀调用，最终组合成超类表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">	<span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">	<span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BazMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">	<span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FooMixin</span>(<span class="title class_">BarMixin</span>(<span class="title class_">BazMixin</span>(<span class="title class_">Vehicle</span>))) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line">b.<span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br><span class="line">b.<span class="title function_">bar</span>(); <span class="comment">// bar</span></span><br><span class="line">b.<span class="title function_">baz</span>(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<p>通过写一个辅助函数，可以把嵌套展开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">	<span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">	<span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BazMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line">	<span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mix</span>(<span class="params">BassClass, ...Minins</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Minins</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> <span class="title function_">curr</span>(prev), <span class="title class_">BassClass</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mix</span>(<span class="title class_">Vehicle</span>, <span class="title class_">FooMixin</span>, <span class="title class_">BarMixin</span>, <span class="title class_">BazMixin</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line">b.<span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br><span class="line">b.<span class="title function_">bar</span>(); <span class="comment">// bar</span></span><br><span class="line">b.<span class="title function_">baz</span>(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>和我一起读红宝书</tag>
        <tag>继承</tag>
        <tag>JavaScript类</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器和生成器 | 生成器（含手写生成器应用）</title>
    <url>/2022/07/12/JavaScript/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8_%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><blockquote>
<p>生成器是ES6新增的解构，拥有在一个函数块内<strong>暂停和恢复</strong>代码执行的能力</p>
</blockquote>
<h4 id="生成器基础"><a href="#生成器基础" class="headerlink" title="生成器基础"></a>生成器基础</h4><p>生成器的形式是一个函数，<strong>函数名称</strong>前面加一个星号（*）【星号不受两侧空格影响】表示它是一个生成器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	只要是可以定义函数的地方，就可以定义生成器</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="keyword">function</span> *() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    * <span class="title function_">generatorFnn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为类静态方法的生成器函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用生成器函数会生成一个<strong>生成器对象</strong></p>
<ul>
<li>生成器对象一开始处于<strong>暂停状态</strong>（<code>suspended</code>）</li>
</ul>
</li>
<li><p>生成器方法也实现了<strong>Iterator接口</strong>，因此也可以调用<code>next()</code>方法，一旦调用这个方法，就会让生成器开始或者恢复执行（相当于激活了~）</p>
<ul>
<li><p><code>next()</code>方法返回值类似于迭代器，有一个<code>done</code>属性和一个<code>value</code>属性</p>
</li>
<li><p>函数体为空的生成器中间不会停留，调用一次<code>next()</code>就会让生成器达到<code>done:true</code>状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;   <span class="comment">// 定义一个生成器对象，生成器对象是一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>();   <span class="comment">// 调用生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);         <span class="comment">//  generatorFn &#123;&lt;suspended&gt;&#125;   生成器对象处于暂停状态</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());  <span class="comment">//  &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>value</code>属性是生成器的返回值，默认为<code>undefined</code>，可以通过生成器函数的返回值指定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);         <span class="comment">//  generatorFn &#123;&lt;suspended&gt;&#125;   </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());   <span class="comment">// &#123;value: &#x27;foo&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>生成器函数只会在<strong>初次</strong>调用<code>next()</code>方法后开始执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>();    <span class="comment">// 并不会打印foo</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);         <span class="comment">//  generatorFn &#123;&lt;suspended&gt;&#125;   </span></span><br><span class="line">g.<span class="title function_">next</span>()   <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器对象实现了Iterator接口，它们默认的迭代器是自引用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorFn);   <span class="comment">// ƒ *generatorFn() &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]);  <span class="comment">// ƒ [Symbol.iterator]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>());  <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]());   <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g  = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g === g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="通过yield中断执行"><a href="#通过yield中断执行" class="headerlink" title="通过yield中断执行"></a>通过yield中断执行</h4><blockquote>
<p>yield关键字可以让生成器停止和开始执行</p>
<p>yield关键字只能在生成器函数内部使用</p>
<p>yield可以作为函数的中间返回语句使用，yield关键字可以作为函数的中间参数使用，yield关键字可以同时用于输入和输出</p>
</blockquote>
<ul>
<li>生成器函数在遇到<code>yield</code>关键字之前正常执行，遇到这个关键字之后，执行会停止，函数作用域的状态会被保留，停止执行的生成器函数只能通过在生成器对象上调用<code>next()</code>方法来恢复执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());   <span class="comment">// &#123;done: false, value: undefined&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());   <span class="comment">// &#123;done: false, value: undefined&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>yield关键字有点像函数中间的返回语句，它生成的值会出现在<code>next()</code>方法返回的对象里（不同的是：通过yield关键字退出的生成器函数会处在<code>done:false</code>状态；通过<code>retrun</code>关键字退出的生成器函数会处于<code>done:true</code>状态）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());    <span class="comment">// &#123;done: false, value: &#x27;foo&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());    <span class="comment">// &#123;done: false, value: &#x27;bar&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());    <span class="comment">// &#123;done: true, value: &#x27;baz&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成器函数内部的执行流程会针对每个生成器对象区分作用域，在一个生成器对象上调用next()不会影响其他生成器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g1 = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="keyword">let</span> g2 = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">next</span>());    <span class="comment">// &#123;done: false, value: &#x27;foo&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="title function_">next</span>());    <span class="comment">// &#123;done: false, value: &#x27;foo&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g1.<span class="title function_">next</span>());    <span class="comment">// &#123;done: false, value: &#x27;bar&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g2.<span class="title function_">next</span>());    <span class="comment">// &#123;done: false, value: &#x27;bar&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="1生成器对象作为可迭代对象"><a href="#（1）生成器对象作为可迭代对象" class="headerlink" title="（1）生成器对象作为可迭代对象"></a>（1）生成器对象作为可迭代对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong>我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">nTimes</span>(<span class="params">n</span>) &#123;   <span class="comment">// 这个函数可以控制迭代循环的次数</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;   <span class="comment">// 当n为0时，while判断返回为false，循环退出</span></span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<h5 id="2使用yield实现输入和输出"><a href="#（2）使用yield实现输入和输出" class="headerlink" title="（2）使用yield实现输入和输出"></a>（2）使用yield实现输入和输出</h5><blockquote>
<p>注意： 第一次调用next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// yield关键字可以作为函数的中间参数使用</span></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(initial);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>(<span class="string">&#x27;foo&#x27;</span>);     <span class="comment">// 这时候生成器处于暂停状态，是不会输出任何结果的，必须使用next激活</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="string">&#x27;bar&#x27;</span>)   <span class="comment">// foo    第一次调用next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="string">&#x27;baz&#x27;</span>)   <span class="comment">// baz</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="string">&#x27;qux&#x27;</span>)   <span class="comment">// qux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yield关键字可以同时用于输入和输出</span></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>();    <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;  </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());   <span class="comment">// 激活生成器函数   &#123;value: &#x27;foo&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;bar&#x27;</span>));  <span class="comment">// &#123;value: &#x27;bar&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到<code>yield</code>关键字时暂停执行并计算出要产生的值：<code>&quot;foo&quot;</code>，下一次调用<code>next()</code>传入了<code>&quot;bar&quot;</code>，作为交给同一个<code>yield</code>的值，然后这个值被确定为本次生成器函数要返回的值</p>
<h5 id="3yield关键字可以允许使用多次"><a href="#（3）yield关键字可以允许使用多次" class="headerlink" title="（3）yield关键字可以允许使用多次"></a>（3）yield关键字可以允许使用多次</h5><p><strong>应用场景1：</strong>定义一个生成器函数，它会根据配置的值迭代相应次数并产生迭代的索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现1</span></span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景2：</strong>使用生成器实现范围</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">range</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">        <span class="keyword">yield</span> start;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">4</span>,<span class="number">7</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景3：</strong>使用生成器实现填充数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">zeros</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">zeros</span>(<span class="number">8</span>)))   <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>

<h5 id="4产生可迭代对象"><a href="#（4）产生可迭代对象" class="headerlink" title="（4）产生可迭代对象"></a>（4）产生可迭代对象</h5><blockquote>
<p>可以使用星号（*）【星号两侧的空格不影响其行为】增强yield的值，让它能够迭代一个可迭代对象，从而一次产出一个值</p>
</blockquote>
<ul>
<li><code>yield*</code>实际上只是将一个可迭代对象序列化为一连串可以单独产出的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价的generatorFn</span></span><br><span class="line"><span class="comment">// function * generatorFn() &#123;</span></span><br><span class="line"><span class="comment">// 		for (const x of [1, 2, 3]) &#123;</span></span><br><span class="line"><span class="comment">// 			yeild x;	</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>().<span class="property">value</span>);   <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>().<span class="property">value</span>);   <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>().<span class="property">value</span>);   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者是</span></span><br><span class="line"><span class="keyword">let</span> g1 = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> g) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>yield*</code>的值是关联迭代器返回<code>done:true</code>时的<code>value</code>属性</p>
<ul>
<li>对于普通的迭代器来说，这个值是<code>undefined</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// iter value: undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">innerGeneratorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">outerGeneratorFn</span>(<span class="params">genObj</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span> * <span class="title function_">innerGeneratorFn</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">outerGeneratorFn</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value: foo</span></span><br><span class="line"><span class="comment">// iter value: bar</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5使用yield实现递归算法"><a href="#（5）使用yield-实现递归算法" class="headerlink" title="（5）使用yield*实现递归算法"></a>（5）使用yield*实现递归算法</h5><blockquote>
<p>实现递归操作是yield*最有用的地方</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> * <span class="title function_">nTimes</span>(n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">yield</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong>使用生成器测试一个随机的双向图是否联通</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建节点 节点的邻里关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">neighbors</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">connect</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node !== <span class="variable language_">this</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">neighbors</span>.<span class="title function_">add</span>(node);</span><br><span class="line">            node.<span class="property">neighbors</span>.<span class="title function_">add</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机连接节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomGraph</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">size</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nodes</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Node</span>(i))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 随机连接节点</span></span><br><span class="line">        <span class="keyword">const</span> threshold = <span class="number">1</span> / size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> y <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; threshold) &#123;</span><br><span class="line">                    x.<span class="title function_">connect</span>(y);   <span class="comment">// 连接成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 这个方法仅用于调试</span></span><br><span class="line">        <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> ids = [...node.<span class="property">neighbors</span>]</span><br><span class="line">                					.<span class="title function_">map</span>(<span class="function"><span class="params">n</span> =&gt;</span> n.<span class="property">id</span>)</span><br><span class="line">                					.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;node.id&#125;</span>:<span class="subst">$&#123;ids&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">RandomGraph</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0:1,3,4,5</span></span><br><span class="line"><span class="comment">// 1:0,3,4</span></span><br><span class="line"><span class="comment">// 2:4</span></span><br><span class="line"><span class="comment">// 3:1,0</span></span><br><span class="line"><span class="comment">// 4:2,0,1</span></span><br><span class="line"><span class="comment">// 5:0</span></span><br></pre></td></tr></table></figure>

<p>生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归，这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了；结果就得到了一个非常简洁的深度优先遍历：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建节点 节点的邻里关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">connect</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机连接节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomGraph</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">size</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 这个方法仅用于调试</span></span><br><span class="line">     <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">         ......</span><br><span class="line">     &#125;</span><br><span class="line">         </span><br><span class="line">      <span class="title function_">isConnected</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> visitedNodes = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">function</span> *<span class="title function_">traverse</span>(<span class="params">nodes</span>) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!visitedNodes.<span class="title function_">has</span>(node)) &#123;</span><br><span class="line">                      <span class="keyword">yield</span> node;</span><br><span class="line">                      <span class="keyword">yield</span> * <span class="title function_">traverse</span>(node.<span class="property">beighbors</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 取得集合中的第一个节点</span></span><br><span class="line">          <span class="keyword">const</span> firstNode = <span class="variable language_">this</span>.<span class="property">nides</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]().<span class="property">next</span>.<span class="title function_">value</span>();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 使用递归生成器迭代每一个节点</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="title function_">traverse</span>([firstNode])) &#123;</span><br><span class="line">              visitedNodes.<span class="title function_">add</span>(node);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> visitedNodes.<span class="property">size</span> === <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="property">size</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成器作为默认迭代器"><a href="#生成器作为默认迭代器" class="headerlink" title="生成器作为默认迭代器"></a>生成器作为默认迭代器</h4><p>因为生成器实现了Iterator接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器适合作为默认迭代器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">values</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> * <span class="variable language_">this</span>.<span class="property">values</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> f) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	for-of 循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象</span></span><br><span class="line"><span class="comment">	这个生成器对象是可迭代的，所以完全可以在迭代中使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h4><blockquote>
<p>return() 和 throw() 方法都可以用于强制生成器进入关闭状态</p>
</blockquote>
<h5 id="1return"><a href="#（1）return" class="headerlink" title="（1）return()"></a>（1）return()</h5><blockquote>
<p>return()方法会强制生成器进入关闭状态，提供给return的值就是终止迭代器对象的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);  <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">4</span>)); <span class="comment">// &#123;value: 4, done: true&#125;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);  <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>与迭代器不同，所有生成器对象都有return()方法，只要通过它进入关闭状态，就<strong>无法恢复</strong>了</p>
</li>
<li><p>后续调用next()会显示done: true 状态，而提供的任何返回值都不会被存储或传播</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);  <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">4</span>)); <span class="comment">// &#123;value: 4, done: true&#125;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());  <span class="comment">// &#123;value: undefined, done: true&#125;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());  <span class="comment">// &#123;value: undefined, done: true&#125;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());  <span class="comment">// &#123;value: undefined, done: true&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>for-of</code> 循环等内置语言结构会忽略状态为<code>done: true</code> 的<code>IteratorObject</code> 内部返回的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> g) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        g.<span class="keyword">return</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h5 id="2throw"><a href="#（2）throw" class="headerlink" title="（2）throw()"></a>（2）throw()</h5><blockquote>
<p>throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中，如果错误未被处理，生成器就会关闭</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);  <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    g.<span class="keyword">throw</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;   <span class="comment">// 错误会被catch捕获</span></span><br><span class="line">    cnosole.<span class="title function_">log</span>(e);   <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);  <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行，错误处理会跳过对应的<code>yield</code>，因此在这个例子中会跳过一个值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());   <span class="comment">// &#123;value: 1, done: true&#125;;</span></span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&#x27;foo&#x27;</span>);          <span class="comment">// foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());   <span class="comment">// &#123;value: 2, done: true&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	跳过了value2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，生成器在<code>try/catch</code>块中的<code>yield</code>关键字处暂停执行。在暂停期间，<code>throw()</code>方法向生成器对象内部注入了一个错误：字符串<code>&quot;foo&quot;</code>。这个错误会被<code>yield</code>关键字抛出。因为错误是在生成器的<code>try/catch</code>块中抛出的，所以仍然在生成器内部被捕获可是，由于<code>yield</code>抛出了那个错误，生成器就不会再产出值<code>2</code>。此时，生成器函数继续执行，在下一次迭代再次遇到<code>yield</code>关键字时产出了值<code>3</code></p>
<blockquote>
<p>注意：如果生成器对象还没有开始执行，那么调用<code>throw()</code>抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&#x27;foo&#x27;</span>);   <span class="comment">// Uncaught foo  相当于在外部抛出了错误</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>和我一起读红宝书</tag>
        <tag>迭代器和生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器和生成器 | 迭代器（含手写迭代器）</title>
    <url>/2022/07/12/JavaScript/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8_%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h3 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h3><blockquote>
<p>迭代：按照顺序返回多次执行一段程序，通常会有明确的终止条件</p>
</blockquote>
<p>迭代会在一个有序集合上进行，“有序”是指集合中所有的项都可以按照既定的顺序被遍历到，特别是开始项和结束项有明确的定义</p>
<p>循环迭代的弊端：</p>
<ul>
<li><strong>迭代之前需要事先知道如何使用数据结构：</strong>数组中的每一项都只能先通过引用取得数组对象，然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构</li>
<li>**遍历顺序并不是数据结构固有的:**通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构</li>
</ul>
<p>ES5新增了<code>Array.prototyoe.forEach</code>方法，但是仍然有弊端：这个方法解决了单独记录索引和通过数组对象取得值的问题，不过，没有办法标识迭代何时终止，因此这个方法只适用于数组，而且回调结构也比较笨拙</p>
<p>因此<strong>迭代器模式</strong>诞生</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><blockquote>
<p>迭代器模式描述了一个方案，即可以把有些结构称为“可迭代对象”（<code>iterable</code>）（比如：数组或者集合这样的集合类型对象，它们包含的元素都是有限的，并且具有无歧义的遍历顺序），因为它们实现了正式的<code>Iterable</code> 接口，而且可以通过迭代器<code>Iterator </code>消费</p>
</blockquote>
<ul>
<li><p>可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构，比如计数循环，该循环中生成的值是暂时性的，但循环本身是在执行迭代，计数循环和数组都具有可迭代对象的行为</p>
</li>
<li><p>任何实现<code>Iterable</code>接口的数据结构都可以被实现<code>Iterator</code>接口的结构“消费”<code>（consume）</code>，迭代器<code>（iterator）</code>是按需创建的<strong>一次性</strong>对象，每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的<code>API</code>，迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值，这种概念上的分离正是<code>Iterable </code>和<code>Iterator</code> 的强大之处</p>
</li>
</ul>
<h4 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h4><p>实现<code>Iterable</code>接口（可迭代协议）要求同时具备两种能力：</p>
<ul>
<li>支持迭代的自我识别能力</li>
<li>创建实现<code>Iterator</code>接口的对象的能力</li>
</ul>
<p>在<code>ECMAScript</code>中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的**<code>Symbol.iterator</code>** 作为键，这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器</p>


<ul>
<li>很多内置类型都实现了Iterable 接口<ul>
<li>String</li>
<li>Array</li>
<li>Map</li>
<li>arguments对象</li>
<li>NodeList等DOM集合类型</li>
</ul>
</li>
<li>检查是否存在默认迭代器可以暴露这个工厂函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种类型没有实现迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>).<span class="title function_">set</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> els = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些类型都实现了迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(els[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个工厂函数会生成一个迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// StringIterator &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// MapIterator &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// SetIterator &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(els[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器,实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性</p>
<ul>
<li>接收可迭代对象的原生语言特性包括:<ul>
<li>for of 循环</li>
<li>数组解构</li>
<li>扩展运算符</li>
<li><code>Array.from()</code></li>
<li>创建Set</li>
<li>创建Map</li>
<li><code>Promise.all()</code>接收由Promise组成的可迭代对象</li>
<li><code>Promise.race()</code>接收由Promise组成的可迭代对象</li>
<li><code>yield*</code>操作符，在生成器中的使用</li>
</ul>
</li>
</ul>
<p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// foo, bar, baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作符</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 构造函数</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// Set(3) &#123;&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 构造函数</span></span><br><span class="line"><span class="keyword">let</span> pairs = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">x, i</span>) =&gt;</span> [x, i]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pairs); <span class="comment">// [[&#x27;foo&#x27;, 0], [&#x27;bar&#x27;, 1], [&#x27;baz&#x27;, 2]]</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(pairs);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map(3) &#123; &#x27;foo&#x27;=&gt;0, &#x27;bar&#x27;=&gt;1, &#x27;baz&#x27;=&gt;2 &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果对象原型链上的父类实现了<code>Iterable</code>接口，那这个对象也就实现了这个接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fooArr = <span class="keyword">new</span> <span class="title class_">FooArray</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> fooArr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h4><p>迭代器<code>API</code>使用<code>next()</code>方法在可迭代对象中遍历数据，每次调用next()都会返回一个&#96;IteratorResult1对象，这个对象包含两个属性：</p>
<ul>
<li><p><code>done</code>：布尔值，表示是否还可以调用<code>next()</code>取得下一个值，注意：<code>done:true</code>表示耗尽</p>
</li>
<li><p><code>value</code>：包含可迭代对象的下一个值（<code>done:false</code>）或者是<code>undefined</code>（<code>done:true</code>）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]);   <span class="comment">// f values() &#123;[native code]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter);    <span class="comment">// ArrayIterator();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line">iter.<span class="title function_">next</span>();    <span class="comment">// &#123;done: false, value:&#x27;foo&#x27;&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>();    <span class="comment">// &#123;done: false, value: &#x27;bar&#x27;&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>();    <span class="comment">// &#123;done: true, value:undefined&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	迭代器并不知道怎么可以从可迭代对象取得下一个值，也不知道可迭代对象多大，只要迭代器到达done:true状态，后续调用next()就一直返回同样的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line">iter.<span class="title function_">next</span>();    <span class="comment">// &#123;done: false, value:&#x27;foo&#x27;&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>();    <span class="comment">// &#123;done: false, value: &#x27;bar&#x27;&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>();    <span class="comment">// &#123;done: true, value:undefined&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>();    <span class="comment">// &#123;done: true, value:undefined&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>();    <span class="comment">// &#123;done: true, value:undefined&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>每个迭代器都表示对可迭代对象的一次性有序遍历，不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">let</span> iter2 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">iter1.<span class="title function_">next</span>();    <span class="comment">// &#123;done: false, value:&#x27;foo&#x27;&#125;</span></span><br><span class="line">iter2.<span class="title function_">next</span>();    <span class="comment">// &#123;done: false, value:&#x27;foo&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">iter1.<span class="title function_">next</span>();    <span class="comment">// &#123;done: false, value: &#x27;bar&#x27;&#125;</span></span><br><span class="line">iter2.<span class="title function_">next</span>();    <span class="comment">// &#123;done: false, value: &#x27;bar&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程，如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;baz&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象</p>
</blockquote>
<ol start="3">
<li>显示迭代器和原生迭代器有差别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类实现了可迭代接口（Iterable）</span></span><br><span class="line"><span class="comment">// 调用默认的迭代器工厂函数会返回</span></span><br><span class="line"><span class="comment">// 一个实现迭代器接口（Iterator）的迭代器对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出实现了迭代器接口的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// &#123; next: f() &#123;&#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 类型实现了可迭代接口（Iterable）</span></span><br><span class="line"><span class="comment">// 调用Array 类型的默认迭代器工厂函数</span></span><br><span class="line"><span class="comment">// 会创建一个ArrayIterator 的实例</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出ArrayIterator 的实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// Array Iterator &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义迭代器手写"><a href="#自定义迭代器（手写）" class="headerlink" title="自定义迭代器（手写）"></a>自定义迭代器（手写）</h4><blockquote>
<p>任何实现Iterator接口的对象都可以作为迭代器使用</p>
</blockquote>
<ol>
<li><strong>初步实现Iterator接口</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初步实现Iterator接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &lt;= <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">count</span>++&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	let iter = counter[Symbol.iterator]();    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	console.log(iter);       // &#123;count: 1, limit: 3&#125;</span></span><br><span class="line"><span class="comment">	console.log(iter.next());   // &#123;done: false, value: 1&#125;;</span></span><br><span class="line"><span class="comment">	console.log(iter.next());   // &#123;done: false, value: 2&#125;;</span></span><br><span class="line"><span class="comment">	console.log(iter.next());   // &#123;done: false, value: 3&#125;;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);     <span class="comment">// &#123;count: 1, limit: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个迭代器仍有不足的地方，因为它的每个实例都只能迭代一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter)    <span class="comment">// &#123;count: 4, limit: 3&#125;</span></span><br><span class="line"><span class="comment">// 再次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;nothing logged&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>通过闭包改进</strong>：实现一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">		<span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">			limit = <span class="variable language_">this</span>.<span class="property">limit</span>;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">					<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h4><p>可选的<code>return()</code>方法用于指定在迭代器提前关闭时执行的逻辑，执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器</p>
<p>可能的情况有：</p>
<ul>
<li><code>for-of</code> 循环通过<code>break</code>、<code>continue</code>、<code>return</code> 或<code>throw</code> 提前退出</li>
<li>解构操作并未消费所有值</li>
</ul>
<p><code>return()</code>方法必须返回一个有效的<code>IteratorResult</code>对象，简单的情况下，可以只返回<code>&#123;done:true&#125;</code></p>
<ul>
<li>在内置结构中，还有值可以迭代，但是不会消费这些值的时候，会自动调用<code>return()</code>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">		<span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">			limit = <span class="variable language_">this</span>.<span class="property">limit</span>;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">					<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">            </span><br><span class="line">			<span class="keyword">return</span>() &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting early&#x27;</span>);</span><br><span class="line">				<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&#x27;err&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter3 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> [a, b] = counter3;</span><br><span class="line"><span class="comment">// Exiting early</span></span><br></pre></td></tr></table></figure>

<ol>
<li>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代（比如数组的迭代器就是不能关闭的）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>因为return()方法是可选的，所以并非所有的迭代器都是可关闭的，要检测某个迭代器是否可关闭，可以测试这个迭代器实例的return属性是不是函数对象，但是，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变可关闭的，这是因为调用return()方法不会强制迭代器进入关闭状态，即便如此，return()方法还是会被调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();   <span class="comment">// 我们知道数组的迭代器是不可关闭的</span></span><br><span class="line"></span><br><span class="line">iter.<span class="property">return</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;     <span class="comment">//  给数组的迭代器增加一个return方法</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting early&#x27;</span>);   </span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>      <span class="comment">// break满足迭代器调用return()的条件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// Exiting early   调用return了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

























]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>和我一起读红宝书</tag>
        <tag>迭代器和生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>源码 | axio源码</title>
    <url>/2022/07/06/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E6%BA%90%E7%A0%81_axios%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>和我一起读源码</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
        <tag>和我一起读源码</tag>
      </tags>
  </entry>
  <entry>
    <title>网络请求 | AJAX</title>
    <url>/2022/07/05/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_AJAX/</url>
    <content><![CDATA[<h2 id="ajax概述"><a href="#AJAX概述" class="headerlink" title="AJAX概述"></a>AJAX概述</h2><p>Ajax &#x3D; Asynchronous JavaScript + XML </p>
<p>Ajax主要依赖于XMLHttpRequest（<strong>XHR</strong>）对象，XHR为发送服务器请求和获取响应提供了合理的接口。这个接口可以实现异步从服务器获取额外数据，意味着用户点击不用页面刷新也可以获取数据。通过XHR对象获取数据后，可以使用DOM方法把数据插入网页。</p>
<h2 id="ajax优点"><a href="#AJAX优点" class="headerlink" title="AJAX优点"></a>AJAX优点</h2><p>W3school里面是这么说的</p>
<img src="/2022/07/05/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_AJAX/AJAX%E4%BC%98%E7%82%B9.png" class title="AJAX优点">

<p>言简意赅就是在说AJAX可以不刷新页面更新数据，AJAX可以实现与服务器的通信</p>
<h3 id="1-无刷新更新数据"><a href="#1-无刷新更新数据" class="headerlink" title="1. 无刷新更新数据"></a>1. 无刷新更新数据</h3><p>这是AJAX最大的优点：不用刷新整个页面的前提下与服务器通信维护数据，有利于Web应用程序更为迅速地响应用户交互，避免了在网络上发送没有改变的信息，减少用户等待时间，带来了较好的用户体验。</p>
<h3 id="2-异步与服务器通信"><a href="#2-异步与服务器通信" class="headerlink" title="2. 异步与服务器通信"></a>2. 异步与服务器通信</h3><p>AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间以及降低网络上的数据流量。</p>
<h3 id="3-前端和后端负载平衡"><a href="#3-前端和后端负载平衡" class="headerlink" title="3. 前端和后端负载平衡"></a>3. 前端和后端负载平衡</h3><p>AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。AJAX的原则是”按需获取数据“，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。</p>
<h3 id="4-基于标准化被广泛支持"><a href="#4-基于标准化被广泛支持" class="headerlink" title="4. 基于标准化被广泛支持"></a>4. 基于标准化被广泛支持</h3><p>AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许在JavaScript浏览器上执行，随着AJAX的成熟，一些简化AJAX的使用方法的程序库也相继问世。</p>
<h3 id="5-界面与页面分离"><a href="#5-界面与页面分离" class="headerlink" title="5. 界面与页面分离"></a>5. 界面与页面分离</h3><p>AJAX是的Web中的界面与应用分离，有利于分工合作、减少非技术任意对页面的修改造成的web应用程序错误、提高效率，更加适用于现在的发布系统。</p>
<h3 id="ajax缺点"><a href="#AJAX缺点" class="headerlink" title="AJAX缺点"></a>AJAX缺点</h3><h3 id="1-ajax破坏了浏览器机制"><a href="#1-AJAX破坏了浏览器机制" class="headerlink" title="1. AJAX破坏了浏览器机制"></a>1. AJAX破坏了浏览器机制</h3><p>因为AJAX是动态更新局部页面的，所以用户无法回到前一个页面状态，因为一般来说，浏览器可以通过back和history的功能回到历史记录中的静态页面，但是在AJAX中这是无法实现的。</p>
<h3 id="2-ajax的安全问题"><a href="#2-AJAX的安全问题" class="headerlink" title="2. AJAX的安全问题"></a>2. AJAX的安全问题</h3><p>AJAX暴露了浏览器与服务器交互的细节。</p>
<h3 id="3-ajax不能很好地兼容移动设备"><a href="#3-AJAX不能很好地兼容移动设备" class="headerlink" title="3. AJAX不能很好地兼容移动设备"></a>3. AJAX不能很好地兼容移动设备</h3><p>一些手持设备比如手机，PAD等，现在还不能很好地支持AJAX。</p>
<h2 id="ajax工作原理"><a href="#AJAX工作原理" class="headerlink" title="AJAX工作原理"></a>AJAX工作原理</h2><img src="/2022/07/05/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_AJAX/AJAX%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" class title="AJAX工作原理">

<p>基于AJAX的介绍和工作原理，AJAX请求可以分为以下几个步骤：</p>
<ol>
<li>新建XHR对象, <code>let xhr = new XMLHttpRequest()</code>；</li>
<li>打开链接 <code>open()</code>，传入三个参数：请求类型，Url，请求是否异步（布尔值）</li>
<li>发送 <code>send()</code>，接收一个参数，作为请求体发出的数据，如果不需要，则必须传<code>null</code></li>
<li>当XHR对象当完成第四步（<code>onreadystatechange</code>）数据接收完成，判断http响应状态（<code>status</code>）200-300之间或者304（缓存）执行回调函数</li>
</ol>
<h3 id="1-请求类型说明"><a href="#1-请求类型说明" class="headerlink" title="1. 请求类型说明"></a>1. 请求类型说明</h3><p><a href="https://superkatrina123.github.io/2022/07/07/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91_HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/">计网 | HTTP请求方法</a></p>
<h3 id="2-状态码说明"><a href="#2-状态码说明" class="headerlink" title="2. 状态码说明"></a>2. 状态码说明</h3><p><a href="https://superkatrina123.github.io/2022/07/07/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91_HTTP%E7%8A%B6%E6%80%81%E7%A0%81/">计网 | HTTP状态码</a></p>
<p>所以，一般来说，HTTP状态码为2xx表示成功，或者是HTTP状态码为304，表示资源未修改过，使用浏览器的缓存中拿取的，也意味着响应有效。</p>
<h3 id="3-readystate说明"><a href="#3-readyState说明" class="headerlink" title="3. readyState说明"></a>3. readyState说明</h3><ul>
<li><strong>0</strong>：未初始化（Uninitialized）。尚未调用open()方法。</li>
<li><strong>1</strong>：已发送（open）。已调用open()方法，但尚未调用send()方法。</li>
<li><strong>2</strong>：已发送（Sent）。已调用send()方法，尚未收到响应。</li>
<li><strong>3</strong>：接受中（Receiving）。已经收到部分响应。</li>
<li><strong>4</strong>：完成（Complete）。已经收到所有响应，可以使用了。</li>
</ul>
<blockquote>
<p>每次readyState的值发生改变的时候，都会触发readystatechange</p>
</blockquote>
<h3 id="4-xhr对象属性说明"><a href="#4-xhr对象属性说明" class="headerlink" title="4. xhr对象属性说明"></a>4. xhr对象属性说明</h3><blockquote>
<p>收到响应后，xhr对象的以下属性会被填充上数据</p>
</blockquote>
<ul>
<li><code>responseText</code>：作为响应体返回的文本</li>
<li><code>responseXML</code>：如果响应的内容类型是<code>text/xml</code> 或者 <code>application/xml</code>，那就是包含响应数据的XML DOM文件</li>
<li><code>status</code>：响应的HTTP状态</li>
<li><code>statusText</code>：响应的HTTP状态描述</li>
</ul>
<h2 id="ajax代码实现"><a href="#AJAX代码实现" class="headerlink" title="AJAX代码实现"></a>AJAX代码实现</h2><h3 id="1-ajax手写"><a href="#1-AJAX手写" class="headerlink" title="1. AJAX手写"></a>1. AJAX手写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step1: 新建XHR对象</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step4: 监听</span></span><br><span class="line">xhr.<span class="property">onreadstatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (readyState === <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;Request was unsucessful!&#x27;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step2: 建立连接</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step3: 发送</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-promise封装ajax"><a href="#2-Promise封装AJAX" class="headerlink" title="2. Promise封装AJAX"></a>2. Promise封装AJAX</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myAjax</span>(<span class="params">method=<span class="string">&#x27;GET&#x27;</span>, url, isAsync=<span class="literal">false</span>, data=<span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        xhr.<span class="property">onreadstatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);   <span class="comment">// 响应体返回的文本</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(xhr.<span class="property">statusText</span>);   <span class="comment">// 响应的HTTP状态描述</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url, isAsync);</span><br><span class="line">        xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3schools.com/xml/ajax_intro.asp">https://www.w3schools.com/xml/ajax_intro.asp</a></p>
<p><a href="https://juejin.cn/post/6844903713102888973">https://juejin.cn/post/6844903713102888973</a></p>
<p><a href="https://segmentfault.com/a/1190000039416782">https://segmentfault.com/a/1190000039416782</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>手写原理</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title>网络请求 | Fetch_API 基本用法</title>
    <url>/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_Fetch_API/</url>
    <content><![CDATA[<blockquote>
<p>Fetch API 是基于Promise的</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>使用Promise，不使用回调函数</li>
<li>采用模块化设计</li>
<li>通过数据流对象处理数据，可以提高网站性能</li>
</ul>
<blockquote>
<p>fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法，浏览器就会向给定的URL发送请求</p>
</blockquote>
<h4 id="1-分派请求"><a href="#1-分派请求" class="headerlink" title="1. 分派请求"></a>1. 分派请求</h4><p>fetch()只有一个必需的参数，多数情况下，这个参数是要获取资源的URL，并且返回一个Promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="title function_">fetch</span>(<span class="string">&#x27;/bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r);     <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure>

<p>请求完成、资源可用时，Promise会解决为一个Response对象，这个对象是API封装的，可以通过它获取相应的资源</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hotSongsRequest</span> = (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="variable constant_">BASE_URL</span> + <span class="string">&#x27;/artist/top/song?id=&#x27;</span> + id;</span><br><span class="line">    <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response)            <span class="comment">// 关注Response的打印结果</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BASE_URL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;</span><br><span class="line"><span class="title function_">hotSongsRequest</span>(<span class="number">6452</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<img src="/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_Fetch_API/Response%E5%AF%B9%E8%B1%A1.png" class title="Response对象">

<h4 id="2-读取响应"><a href="#2-读取响应" class="headerlink" title="2. 读取响应"></a>2. 读取响应</h4><blockquote>
<p>通过text()方法获取结果内容，这个方法返回一个Promise</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hotSongsRequest</span> = (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="variable constant_">BASE_URL</span> + <span class="string">&#x27;/artist/top/song?id=&#x27;</span> + id;</span><br><span class="line">    <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(value).<span class="property">songs</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BASE_URL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;</span><br><span class="line"><span class="title function_">hotSongsRequest</span>(<span class="number">6452</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<img src="/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_Fetch_API/text%E7%BB%93%E6%9E%9C.png" class title="text结果">

<p>内容的结构通常是打平的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hotSongsRequest</span> = (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> url = <span class="variable constant_">BASE_URL</span> + <span class="string">&#x27;/artist/top/song?id=&#x27;</span> + id;</span><br><span class="line">            <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">                .<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(value).<span class="property">songs</span>))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BASE_URL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;</span><br><span class="line"><span class="title function_">hotSongsRequest</span>(<span class="number">6452</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-处理状态码和请求失败"><a href="#3-处理状态码和请求失败" class="headerlink" title="3. 处理状态码和请求失败"></a>3. 处理状态码和请求失败</h4><p>从下图看，Response对象中含有status和statusText属性检查响应状态</p>
<img src="/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_Fetch_API/Response%E5%AF%B9%E8%B1%A1.png" class title="Response对象">

<p>补课：<a href="https://superkatrina123.github.io/2022/07/07/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_HTTP%E7%8A%B6%E6%80%81%E7%A0%81/">HTTP状态码</a></p>
<p><strong>注意：</strong></p>
<ul>
<li>可以显式地设置fetch()在遇到重定向时的行为，不过默认行为是跟随重定向并返回状态码不是300-399的响应，跟随重定向时，响应对象的redirected属性，会被设置为true，而状态码仍然是200</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/permanent-redirect&#x27;</span>)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 默认行为是跟随重定向直到最终URL</span></span><br><span class="line">    <span class="comment">// 这个例子会出现至少两轮网络请求</span></span><br><span class="line">    <span class="comment">// &lt;origin url&gt;/permanent-redirect -&gt; &lt;redirect url&gt;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 200</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>); <span class="comment">// OK</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">redirected</span>); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>只要服务器返回了响应，fetch()的Promise都会解决</li>
</ul>
<p>下面代码我故意写错端口号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hotSongsRequest</span> = (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> url = <span class="variable constant_">BASE_URL</span> + <span class="string">&#x27;/artist/top/song?id=&#x27;</span> + id;</span><br><span class="line">            <span class="keyword">let</span> r = <span class="title function_">fetch</span>(url);</span><br><span class="line">    		<span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BASE_URL</span> = <span class="string">&#x27;http://localhost:4000&#x27;</span>;</span><br><span class="line"><span class="title function_">hotSongsRequest</span>(<span class="number">6452</span>);</span><br></pre></td></tr></table></figure>

<img src="/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_Fetch_API/%E9%94%99%E8%AF%AF1.png" class title="错误1">

<p>由图可知，Promise的状态为fulfilled</p>
<blockquote>
<p>这个行为是合理的，系统级网络协议已经成功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。</p>
</blockquote>
<p>通常状态码为200 时就会被认为成功了，其他情况可以被认为未成功</p>
<p><strong>为区分这两种情况，可以在状态码非200~299 时检查Response 对象的ok 属性</strong></p>
<ul>
<li>以下情况会引起fetch()失败而导致Promise被拒绝<ul>
<li>服务器没有响应而导致浏览器超时</li>
<li>违反CORS、无网络连接、HTTPS 错配及其他浏览器&#x2F;网络策略问题都会导致期约被拒绝</li>
</ul>
</li>
</ul>
<h4 id="4-自定义选项"><a href="#4-自定义选项" class="headerlink" title="4. 自定义选项"></a>4. 自定义选项</h4><blockquote>
<p>只使用URL 时，fetch()会发送GET 请求，只包含最低限度的请求头</p>
<p>要进一步配置如何发送请求，需要传入可选的第二个参数init 对象</p>
<p>init对象可以按照键值对进行填充</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url, init)</span><br></pre></td></tr></table></figure>

<p>init配置请看链接：[fetch API](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">https://developer.mozilla.org/zh-CN/docs/Web/API/fetch</a> </p>
<p>比如我们要发送POST请求，就可以做如下配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title>网络请求 | ajax axio fetch区别</title>
    <url>/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_ajax%20axios%20fetch%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="ajax"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p><a href="https://superkatrina123.github.io/2022/07/05/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_AJAX/">网络请求 | AJAX</a></p>
<p>AJAX的全称是：Asynchronous JavaScript AND XML 也就是异步的JavaScript 和 XML</p>
<blockquote>
<p><strong>Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。</strong></p>
</blockquote>
<p><strong>特点：</strong></p>
<p>局部刷新，无需重载整个页面</p>
<p>简单来说，XMLHttpRequest是实现AJAX的一种方式</p>
<p>面试常手撕手写AJXA或者用Promise封装AJAX，秉着孰能生巧的想法，再写一遍~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myAJAX</span>(<span class="params">method = <span class="string">&#x27;GET&#x27;</span>, url, isAsync=<span class="literal">true</span>, data=<span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span> || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(xhr.<span class="property">status</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url, isAsync);</span><br><span class="line">        xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p><a href="https://superkatrina123.github.io/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_Fetch_API/">网络请求 | Fetch_API 基本用法</a></p>
<blockquote>
<p>Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象。它是 XMLHttpRequest 的替代品。</p>
</blockquote>
<p>fetch是一个API 它是真实存在的，它是基于promise的</p>
<p><strong>特点</strong>：</p>
<ul>
<li>使用promise，不用回调函数</li>
<li>采用模块化设计</li>
<li>通过数据流对数据进行处理，提高网站性能</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajaxFetch</span>(<span class="params">url, options = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(url, options).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>()</span><br><span class="line">       .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios是一个基于Promise封装的网络请求库，他是基于XHR进行的二次封装</p>
<p><strong>特点：</strong></p>
<ul>
<li>从浏览器创建XMLHttpRequest</li>
<li>从node.js创建http请求</li>
<li>支持Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防御XSRF</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：发送axios请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">xxx</span>:xxx,</span><br><span class="line">        <span class="attr">xxx</span>:xxx,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三者的关系如下图所示：</p>
<img src="/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_ajax%20axios%20fetch%E5%8C%BA%E5%88%AB/%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94.png" class title="三者对比">

<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Ajax</td>
<td>JS异步的术语，一种技术统称，主要利用XHR（早期api）实现网络请求</td>
</tr>
<tr>
<td>Fetch</td>
<td>ES6新增的用于网络请求的标准API，基于promise</td>
</tr>
<tr>
<td>Axios</td>
<td>一个封装库，基于XHR封装，较为推荐使用</td>
</tr>
</tbody></table>
<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p><a href="https://superkatrina123.github.io/2022/07/05/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_AJAX/">网络请求 | AJAX</a></p>
<p><a href="https://superkatrina123.github.io/2022/07/15/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_Fetch_API/">网络请求 | Fetch_API 基本用法</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">MDN Fetch API</a></p>
<p><a href="https://www.w3schools.com/xml/ajax_intro.asp">AJAX Introduction</a></p>
<p><a href="https://axios-http.com/docs/api_intro">axios API</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/497865043">Ajax、Fetch、Axios三者有什么区别？</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>常见方法对比</category>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>常见方法对比</tag>
        <tag>JavaScript</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title>网络请求 | 跨域（待补充）</title>
    <url>/2022/07/13/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p>跨域问题很常见，同时也是面试常问的题目之一，出现的机率super plus【自创词~就是超级多次啦】</p>
</blockquote>
<p>跨域问题主要是浏览器的同源策略造成的</p>
<p>因此，本文结构如下：</p>
<ol>
<li>什么是同源策略（别说你还不知道URL的组成！）</li>
<li>如何解决跨域问题？</li>
</ol>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p><code>url</code>主要由<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>三部分组成【端口一般是隐藏的~】</p>
<img src="/2022/07/13/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82_%E8%B7%A8%E5%9F%9F/url%E7%BB%84%E6%88%90.png" class title="url组成">

<blockquote>
<p>同源指的是：协议 域名 端口号 必须一致，其中任意一个不一致就会引起跨域</p>
</blockquote>
<p>同源策略限制了从一个源加载的文档或脚本如何与另一个文档进行交互</p>
<ul>
<li>当前域下的<code>js</code>脚本不能够访问其他域下的<code>cookie</code> <code>localStorage</code> <code>indexDB</code></li>
<li>当前域下的<code>js</code>脚本不能够操作访问其他域下的DOM</li>
<li>当前域下<code>ajax</code>无法发送跨域请求</li>
</ul>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 <code>img</code>、或者<code>script</code> 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作</p>
<h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><p>解决跨域问题主要有如下几种方式：</p>
<ul>
<li><p><code>JSONP</code>：通过动态创建<code>&lt;script&gt;</code>元素并为<code>src</code>属性执行跨域URL实现的【<code>&lt;script&gt;</code>与<code>&lt;img&gt;</code>类似，能够不受限制地从其他域加载资源】</p>
</li>
<li><p><code>CORS</code>：<code>Cross-Origin Resource Sharing</code>跨站资源共享，使用自定义的HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应<br>应该成功还是失败</p>
</li>
</ul>
<h4 id="1-jsonp"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h4><blockquote>
<p><code>jsonp</code>的<strong>原理</strong>就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签<code>src</code>属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据</p>
</blockquote>
<p><strong>JSONP介绍</strong></p>
<ul>
<li><p>JSONP</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">callback</span>(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Katrina&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSONP格式包含两部分：回调和数据</p>
<ul>
<li>回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的</li>
<li>而数据就是作为参数传给回调函数的JSON 数据</li>
</ul>
</li>
<li><p>典型的JSONP请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;http://freegeoip.net/json/?callback=handleResponse&#x27;</span>   <span class="comment">// handleResponse 回调函数的名称</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>JSONP实现</strong></p>
<ul>
<li><p>实现步骤</p>
<ul>
<li>准备一个回调函数，用于接收JSON数据</li>
<li>动态创建script标签</li>
<li>给创建的script添加src</li>
<li>把创建好的script添加到head中</li>
</ul>
</li>
<li><p>原生JS实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备一个回调函数，用于接收JSON数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态创建script标签</span></span><br><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"><span class="comment">// 给创建的script添加src</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://www.domain.com:8080/login?username=admin&amp;callback=handleResponse&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把创建好的script添加到head中</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>JSONP优缺点</strong></p>
<ul>
<li>优点：<ul>
<li>简单易用</li>
<li>使用JSONP可以直接访问响应，实现浏览器与服务器的双向通信</li>
</ul>
</li>
<li>缺点：<ul>
<li>不安全，JSONP 是从不同的域拉取可执行代码，如果这个域并不可信，则可能在响应中加入恶意内容【XSS攻击】</li>
<li>不好缺点JSONP请求是否失败</li>
<li>具有局限性， 仅支持get方法</li>
</ul>
</li>
</ul>
<h4 id="2-cors"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h4><p>跨站资源共享（Cross Origin Resource Sharing）使用额外的 HTTP 头来告诉浏览器 ：</p>
<ul>
<li>让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源</li>
<li>当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求</li>
</ul>
<p>因此，<code>CORS</code>需要浏览器和服务器同时支持，<strong>实现<code>CORS</code>的关键就是服务器，只要服务器实现了<code>CORS</code>请求，就可以跨源通信</strong></p>
<p><strong>请求头头部配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Origin</span>: url;   <span class="comment">// url:浏览器url</span></span><br></pre></td></tr></table></figure>

<p><strong>服务器配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: url;  <span class="comment">// 允许这个url跨域</span></span><br><span class="line"><span class="comment">// 如果资源公开：</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: *;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有这个头部或者有源但不匹配，则表明不会响应浏览器请求，否则，服务器就会处理这个请求</li>
</ul>
<blockquote>
<p>注意：无论请求还是响应都不会包含cookie信息</p>
<p>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p>
<ul>
<li>在请求中设置 <code>withCredentials</code></li>
</ul>
<p>默认情况下在跨域请求，浏览器是不带 cookie 的，但是我们可以通过设置<code>withCredentials</code>来进行传递 cookie.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Access-Control-Allow-Credentials 设置为 <code>true</code></li>
<li>Access-Control-Allow-Origin 设置为 <code>false</code></li>
</ul>
</blockquote>
<ul>
<li>跨域<code>XHR</code> 对象允许访问<code>status</code> 和<code>statusText </code>属性，也允许同步请求</li>
<li>出于安全考虑，跨域XHR对象也施加了一些额外限制<ul>
<li>不能使用<code>setRequestHeader()</code>设置自定义头部</li>
<li>不能发送和接收<code>cookie</code></li>
<li><code>getAllResponseHeaders()</code>方法始终返回空字符串</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://icode.best/i/56511245950109">URL的概念与组成</a></p>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端存储 | IndexedDB</title>
    <url>/2022/07/20/%E8%AE%A1%E7%BD%91&amp;&amp;%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8_IndexDB/</url>
    <content><![CDATA[<h3 id="什么是indexeddb"><a href="#什么是indexedDB" class="headerlink" title="什么是indexedDB"></a>什么是<code>indexedDB</code></h3><p><code>indexedDB</code>是浏览器结构化存储的一种方式，用于代替目前已经废弃的<code>Web SQL Database API</code></p>
<p><code>indexedDB</code>是类似于<code>MySQL</code>或者<code>Web SQL Database</code>的数据库，但是**<code>IndexDB</code>使用对象而不是表格保存数据<strong>，因此，可以说<code>indexedDB</code>是在一个公共空间下的一组对象存储</strong>，类似于NoSQL风格的实现</p>
<h3 id="如何使用indexdb数据库"><a href="#如何使用IndexDB数据库" class="headerlink" title="如何使用IndexDB数据库"></a>如何使用<code>IndexDB</code>数据库</h3><p>使用<code>indexedDB</code>数据库可通过如下步骤（基础）：</p>
<ul>
<li>Step1：调用<code>indexedDB.open()</code>方法</li>
<li>Step2：对象存储</li>
<li>Step3：调用事务进行增删改查</li>
</ul>
<h4 id="step1调用indexeddbopen方法"><a href="#Step1：调用indexedDB-open-方法" class="headerlink" title="Step1：调用indexedDB.open()方法"></a>Step1：调用<code>indexedDB.open()</code>方法</h4><p><code>indexedDB.open()</code>方法用于打开数据库（如果数据库不存在，则为创建）</p>
<p><strong>参数说明</strong></p>
<ul>
<li>要打开的数据库名称（必选）</li>
<li>指定版本号（可选）</li>
</ul>
<p><strong>返回值说明</strong></p>
<p>返回一个<code>IDBRequest</code>的实例，可以在这个实例上添加<code>onerror</code>和<code>onsuccess</code>事件处理程序，<strong>这两个事件处理程序的<code>event.target</code>都指向这个实例</strong></p>
<ul>
<li>如果打开的时候发生错误，就会在<code>event.target.errorCode</code>中存储错误码</li>
<li>如果打开成功，就可以通过<code>event.target.result</code>访问数据库</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> db,</span><br><span class="line">    request,</span><br><span class="line">    version = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">request = indexedDB.<span class="title function_">open</span>(<span class="string">&#x27;admin&#x27;</span>, version);   <span class="comment">// 打开admin这个数据库</span></span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Failed to open: <span class="subst">$&#123;event.target.errorCode&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="step2对象存储"><a href="#Step2：对象存储" class="headerlink" title="Step2：对象存储"></a>Step2：对象存储</h4><p>对象存储你需要准备：</p>
<ul>
<li>指定一个键，必须是全局唯一的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;007&#x27;</span>,</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Katrina&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Ying&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设要存储这样一个对象，很显然<code>username</code>可以用来做主键</p>
<ul>
<li>upgradeneeded事件用于监听更新数据库</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果已经存在则删除当前的objectStore</span></span><br><span class="line">    <span class="keyword">if</span> (db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">&#x27;users&#x27;</span>)) &#123;</span><br><span class="line">        db.<span class="title function_">deleteObjectStore</span>(<span class="string">&#x27;users&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;users&#x27;</span>, &#123;<span class="attr">keyPath</span>: <span class="string">&#x27;username&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="step3通过事务进行后序操作"><a href="#Step3：通过事务进行后序操作" class="headerlink" title="Step3：通过事务进行后序操作"></a>Step3：通过事务进行后序操作</h4><p>在对象存储之后，剩下的所有操作都是通过事务完成的</p>
<ul>
<li>插入对象：add put</li>
<li>删除对象：delete （键作为参数）</li>
<li>获取对象：get（键作为参数）</li>
<li>清空对象：clear</li>
</ul>
<h5 id="1-创建事务-dbtransaction"><a href="#1-创建事务-db-transaction" class="headerlink" title="1. 创建事务 db.transaction()"></a>1. 创建事务 <code>db.transaction()</code></h5><ul>
<li>没有指定名称——数据库中所有的对象都只有只读权限</li>
<li>访问一个或者多个数据库——传入数据库名称，单个直接传入，多个以数组的形式传入</li>
<li>传入第二个参数以修改访问模式——<code>readonly readwrite versionchange</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有指定名称，数据库中所有的对象都只有只读权限</span></span><br><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定名称</span></span><br><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&#x27;users&#x27;</span>);  </span><br><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&#x27;users&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>]);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定第二个参数</span></span><br><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&#x27;users&#x27;</span>, <span class="string">&#x27;readwrite&#x27;</span>);  </span><br></pre></td></tr></table></figure>

<h5 id="2-事务事件处理程序绑定"><a href="#2-事务事件处理程序绑定" class="headerlink" title="2. 事务事件处理程序绑定"></a>2. 事务事件处理程序绑定</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&#x27;users&#x27;</span>),</span><br><span class="line">      store = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;users&#x27;</span>),</span><br><span class="line">      request = store.<span class="title function_">get</span>(<span class="string">&#x27;007&#x27;</span>);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Did not get the object!&quot;</span>);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">result</span>.<span class="property">firstName</span>);</span><br></pre></td></tr></table></figure>

<p>因为一个事务可以完成任意多个请求，所以事务对象本身也有事件处理程序：<code>onerror</code> 和<code>oncomplete</code>，这两个事件可以用来获取事务级的状态信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">transaction.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 整个事务被取消</span></span><br><span class="line">&#125;;</span><br><span class="line">transaction.<span class="property">oncomplete</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 整个事务成功完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，不能通过<code>oncomplete</code>事件处理程序的<code>event</code>对象访问<code>get()</code>请求返回的任何数据，因此，仍然需要通过这些请求的<code>onsuccess</code>事件处理程序来获取数据</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据的方式有：</p>
<ul>
<li>add（增加新值）</li>
<li>put（修改，更新）</li>
</ul>
<p>这两个方法都接收一个参数：要存储的对象</p>
<p>两者的区别在于：传入对象存储已经包含同名键时，add会报错，而put是重写对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) &#123;</span><br><span class="line">    store.<span class="title function_">add</span>(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用<code>add()</code>或<code>put()</code>都会创建对象存储的新更新请求</p>
<p>如果想验证请求成功与否，可以把请求对象保存到一个变量，然后为它添加<code>onerror </code>和<code>onsuccess </code>事件处理程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> request,</span><br><span class="line">    requests = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) &#123;</span><br><span class="line">    request = store.<span class="title function_">add</span>(user);</span><br><span class="line">    </span><br><span class="line">    request.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理错误程序</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    request.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理成功</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    requests.<span class="title function_">push</span>(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过游标查询"><a href="#通过游标查询" class="headerlink" title="通过游标查询"></a>通过游标查询</h3><p>使用事务可以通过一个已知键取得一条记录，如果想取得多条数据，则需要在事务中创建一个<strong>游标</strong></p>
<p>游标是一个指向结果集的指针</p>
<p>与传统数据库查询不同，游标不会事先收集所有结果，相反，游标指向第一个结果，并在接到指令前不会主动查找下一条数据</p>
<h4 id="创建游标-opencursor"><a href="#创建游标-openCursor" class="headerlink" title="创建游标 openCursor()"></a>创建游标 openCursor()</h4><p>可以接收两个参数：（后面讲！！！）</p>
<ul>
<li>键范围</li>
<li>游标方向</li>
</ul>
<p>openCursor()也返回一个请求，所以必须为它添加onsuccess和onerror事件处理程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&#x27;users&#x27;</span>),</span><br><span class="line">      store = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;users&#x27;</span>),</span><br><span class="line">      request = store.<span class="title function_">openCursor</span>();</span><br><span class="line"></span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误程序</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理成功</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在调用<code>onsuccess</code>事件处理程序时，可以通过<code>event.target.result</code>访问对象存储中的下一条记录，这个属性中保存着<code>IDBCursor</code>的实例（有下一条记录时）或null（没有记录时）</p>
<p>实例有如下属性：</p>
<ul>
<li>direction：字符串常量，表示游标的前进方向以及是否应该遍历所有重复的值。<ul>
<li>可能的值包括：NEXT(“next”)、NEXTUNIQUE(“nextunique”)、PREV(“prev”)、PREVUNIQUE(“prevunique”)</li>
</ul>
</li>
<li>key：对象的键</li>
<li>value：实际的对象</li>
<li>primaryKey：游标使用的键，可能是对象键或索引键</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">    <span class="keyword">if</span> (cursor) &#123;  <span class="comment">// 永远要检查！</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key:<span class="subst">$&#123;cursor.key&#125;</span>,Value:<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(cursor.value)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>游标可用于更新个别记录——update()</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">	<span class="keyword">let</span> value,</span><br><span class="line">		updateRequest;</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123; <span class="comment">// 永远要检查</span></span><br><span class="line">		<span class="keyword">if</span> (cursor.<span class="property">key</span> == <span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">			value = cursor.<span class="property">value</span>; <span class="comment">// 取得当前对象</span></span><br><span class="line">			value.<span class="property">password</span> = <span class="string">&quot;magic!&quot;</span>; <span class="comment">// 更新密码</span></span><br><span class="line">			updateRequest = cursor.<span class="title function_">update</span>(value); <span class="comment">// 请求保存更新后的对象</span></span><br><span class="line">			updateRequest.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="comment">// 处理成功</span></span><br><span class="line">			&#125;;</span><br><span class="line">			updateRequest.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="comment">// 处理错误</span></span><br><span class="line">			&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可以删除游标位置的记录_delete()</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">	<span class="keyword">let</span> value,</span><br><span class="line">		deleteRequest;</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123; <span class="comment">// 永远要检查</span></span><br><span class="line">		<span class="keyword">if</span> (cursor.<span class="property">key</span> == <span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">			deleteRequest = cursor.<span class="title function_">delete</span>(); <span class="comment">// 请求删除对象</span></span><br><span class="line">			deleteRequest.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="comment">// 处理成功</span></span><br><span class="line">			&#125;;</span><br><span class="line">			deleteRequest.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="comment">// 处理错误</span></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：如果事务没有修改对象存储的权限，那么update和delete都会报错</p>
<h4 id="游标迭代"><a href="#游标迭代" class="headerlink" title="游标迭代"></a>游标迭代</h4><p>默认情况下，每个游标只会创建一个请求</p>
<p>要创建另一个请求，必须调用下列中的一个方法</p>
<ul>
<li>continue(key)：移动到结果集中的下一条记录，参数key 是可选的，如果没有指定key，游标就移动到下一条记录；如果指定了，则游标移动到指定的键</li>
<li>advance(count)：游标向前移动指定的count 条记录，这两个方法都会让游标重用相同的请求，因此也会重用onsuccess 和onerror 处理程序，直至不再需要</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123; <span class="comment">// 永远要检查</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">$&#123;cursor.key&#125;</span>, Value: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(cursor.value)&#125;</span>`</span>);</span><br><span class="line">		cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h4><p>可以使用键范围更容易地管理游标</p>
<p>键范围对应<code>IDBKeyRange</code>的实例</p>
<p>有四种方式指定键范围</p>
<ul>
<li>方式1：only</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> onlyRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">only</span>(<span class="string">&#x27;007&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这个范围保证只获取键为”007”的值</p>
<p>使用这个范围创建的游标类似于直接访问对象存储并调用get(“007”)</p>
<ul>
<li>方式2：lowerBound</li>
</ul>
<blockquote>
<p>定义结果集的下限，下限表示游标开始的位置</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lowerRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerRange</span>(<span class="string">&#x27;007&#x27;</span>);   <span class="comment">// 保证游标从&quot;007&quot;这个键开始</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方式3：upperBound</li>
</ul>
<blockquote>
<p>定义结果集的上限，通过调用upperBound()方法可以指定游标不会越过的记录，如果不想包含指定的键，可以在第二个参数传入true</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从头开始，到&quot;ace&quot;记录为止</span></span><br><span class="line"><span class="keyword">const</span> upperRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">upperBound</span>(<span class="string">&quot;ace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头开始，到&quot;ace&quot;的前一条记录为止</span></span><br><span class="line"><span class="keyword">const</span> upperRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">upperBound</span>(<span class="string">&quot;ace&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>方式4：bound</li>
</ul>
<blockquote>
<p>同时指定下限和上限，这个方法接收四个参数：下限的键、上限的键、可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从&quot;007&quot;记录开始，到&quot;ace&quot;记录停止</span></span><br><span class="line"><span class="keyword">const</span> boundRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>);</span><br><span class="line"><span class="comment">// 从&quot;007&quot;的下一条记录开始，到&quot;ace&quot;记录停止</span></span><br><span class="line"><span class="keyword">const</span> boundRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 从&quot;007&quot;的下一条记录开始，到&quot;ace&quot;的前一条记录停止</span></span><br><span class="line"><span class="keyword">const</span> boundRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 从&quot;007&quot;记录开始，到&quot;ace&quot;的前一条记录停止</span></span><br><span class="line"><span class="keyword">const</span> boundRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="游标范围设置传入opencursor"><a href="#游标范围设置——传入openCursor" class="headerlink" title="游标范围设置——传入openCursor"></a>游标范围设置——传入openCursor</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>).<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	range = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>);</span><br><span class="line"></span><br><span class="line">request = store.<span class="title function_">openCursor</span>(range);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">	<span class="keyword">if</span> (cursor) &#123; <span class="comment">// 永远要检查</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">$&#123;cursor.key&#125;</span>, Value: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(cursor.value)&#125;</span>`</span>);</span><br><span class="line">		cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="设置游标方向"><a href="#设置游标方向" class="headerlink" title="设置游标方向"></a>设置游标方向</h4><p>游标方向：</p>
<ul>
<li><code>next</code>（默认）：从第一条到最后一条，不跳过重复项</li>
<li><code>nextunique</code>：从第一条到最后一条，跳过重复项</li>
<li><code>prev</code>：从最后一条到第一条，不跳过重复项</li>
<li><code>prevunique</code>：从最后一条到第一条，跳过重复项</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="创建新索引-createindex"><a href="#创建新索引-createIndex" class="headerlink" title="创建新索引 createIndex()"></a>创建新索引 createIndex()</h4><p><strong>参数说明</strong></p>
<ul>
<li>索引名称</li>
<li>索引属性名称</li>
<li>包含键unique的options对象<ul>
<li>unique必须指定，表示这个键是否在所在记录里面唯一</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	index = store.<span class="title function_">createIndex</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;username&quot;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>返回值说明</strong></p>
<p>返回IDBIndex实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	index = store.<span class="title function_">index</span>(<span class="string">&quot;username&quot;</span>);  <span class="comment">// 使用索引</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>可以在索引上使用openCursor()方法创建新游标，这个游标与在对象存储上调用openCursor()创建的游标完全一样，只是其result.key 属性中保存的是索引键，而不是主键</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	index = store.<span class="title function_">index</span>(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">	request = index.<span class="title function_">openCursor</span>();</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 处理成功</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用openKeyCursor()方法也可以在索引上创建特殊游标，只返回每条记录的主键</p>
<p>这个方法接收的参数与openCursor()一样</p>
<p><strong>最大的不同在于，event.result.key 是索引键，且event.result.value是主键而不是整个记录</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	index = store.<span class="title function_">index</span>(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">	request = index.<span class="title function_">openKeyCursor</span>();</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 处理成功</span></span><br><span class="line">	<span class="comment">// event.result.key 是索引键，event.result.value 是主键</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想只取得给定索引键的主键，可以使用getKey()方法，这样也会创建一个新请求，但result.value 等于主键而不是整个记录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	index = store.<span class="title function_">index</span>(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">	request = index.<span class="title function_">getKey</span>(<span class="string">&quot;007&quot;</span>);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 处理成功</span></span><br><span class="line">	<span class="comment">// event.target.result.key 是索引键，event.target.result.value 是主键</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个onsuccess 事件处理程序中，event.target.result.value 中应该是用户ID</p>
<p>任何时候，都可以使用IDBIndex 对象的下列属性取得索引的相关信息</p>
<ul>
<li>name：索引的名称</li>
<li>keyPath：调用createIndex()时传入的属性路径</li>
<li>objectStore：索引对应的对象存储</li>
<li>unique：表示索引键是否唯一的布尔值</li>
</ul>
<p>对象存储自身也有一个indexNames 属性，保存着与之相关索引的名称</p>
<p>使用如下代码可以方便地了解对象存储上已存在哪些索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	indexNames = store.<span class="property">indexNames</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> indexName <span class="keyword">in</span> indexNames) &#123;</span><br><span class="line">	<span class="keyword">const</span> index = store.<span class="title function_">index</span>(indexName);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Index name: <span class="subst">$&#123;index.name&#125;</span></span></span><br><span class="line"><span class="string">		KeyPath: <span class="subst">$&#123;index.keyPath&#125;</span></span></span><br><span class="line"><span class="string">		Unique: <span class="subst">$&#123;index.unique&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在对象存储上调用deleteIndex()方法并传入索引的名称可以删除索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">	store.<span class="title function_">deleteIndex</span>(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为删除索引不会影响对象存储中的数据，所以这个操作没有回调</p>
</li>
</ol>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p><code>IndexedDB</code>虽然是网页中的异步<code>API</code>，但仍存在并发问题</p>
<p>如果两个不同的浏览器标签页同时打开了同一个网页，则有可能出现一个网页尝试升级数据库而另一个尚未就绪的情形</p>
<p>有问题的操作是设置数据库为新版本，而版本变化只能在浏览器只有一个标签页使用数据库时才能完成</p>
<p>第一次打开数据库时，添加onversionchange 事件处理程序非常重要，另一个同源标签页将数据库打开到新版本时，将执行此回调，对这个事件最好的回应是立即关闭数据库，以便完成版本升级</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> request, database;</span><br><span class="line">request = indexedDB.<span class="title function_">open</span>(<span class="string">&quot;admin&quot;</span>, <span class="number">1</span>);</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">	database = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">	database.<span class="property">onversionchange</span> = <span class="function">() =&gt;</span> database.<span class="title function_">close</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应该在每次成功打开数据库后都指定<code>onversionchange</code>事件处理程序</p>
<p>记住，<code>onversionchange</code>有可能会被其他标签页触发</p>
<p>通过始终都指定这些事件处理程序，可以保证<code>Web</code>应用程序能够更好地处理与<code>IndexedDB</code>相关的并发问题</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>IndexedDB 数据库是与页面源（协议、域和端口）绑定的，因此信息不能跨域共享。这意味着<a href="http://www.wrox.com/">www.wrox.com</a> 和p2p.wrox.com 会对应不同的数据存储</li>
<li>每个源都有可以存储的空间限制。当前Firefox 的限制是每个源50MB，而Chrome 是5MB，移动版Firefox 有5MB 限制，如果用度超出配额则会请求用户许可</li>
<li>Firefox 还有一个限制——本地文本不能访问IndexedDB 数据库，Chrome 没有这个限制。</li>
</ul>
]]></content>
      <categories>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>和我一起读红宝书</tag>
        <tag>客户端存储</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端存储 | cookie &amp;&amp; WebStorage</title>
    <url>/2022/07/21/%E8%AE%A1%E7%BD%91&amp;&amp;%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8_cookie/</url>
    <content><![CDATA[<h2 id="cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="cookie用于客户端存储会话信息"><a href="#cookie用于客户端存储会话信息" class="headerlink" title="cookie用于客户端存储会话信息"></a><strong>cookie用于客户端存储会话信息</strong></h3><p>服务器在响应HTTP请求时，通过发送<code>Set-Cookie</code> HTTP头部包含会话信息，<strong>value和name在发送时都会经过URL编码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">2.0</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">type</span>: text/html</span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: name=value</span><br><span class="line"><span class="title class_">Other</span>-<span class="attr">header</span>: other-hander-value</span><br></pre></td></tr></table></figure>

<p>浏览器会存储这些会话信息，并在之后每一个请求中都会在HTTP请求头中包含cookie，将cooike信息发回服务器，这些信息可以作为<strong>唯一标识发送请求</strong>的服务器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /index.<span class="property">js</span> <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Cookie</span>: name=value</span><br><span class="line"><span class="title class_">Other</span>-<span class="attr">header</span>: other-hander-value</span><br></pre></td></tr></table></figure>

<h3 id="cookie的构成"><a href="#cookie的构成" class="headerlink" title="cookie的构成"></a>cookie的构成</h3><img src="/2022/07/21/%E8%AE%A1%E7%BD%91&&%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8_cookie/cookie%E6%9E%84%E6%88%90.png" class title="cookie构成">

<ul>
<li><p><code>name</code>：唯一标识cookie 的名称，cookie 名不区分大小写，cookie 名必须经过URL 编码</p>
</li>
<li><p><code>value</code>：存储在cookie 里的字符串值，这个值必须经过URL 编码</p>
</li>
<li><p><code>domain</code>：cookie 有效的域，发送到这个域的所有请求都会包含对应的cookie，值默认包含子域</p>
</li>
<li><p><code>path</code>：请求URL 中包含这个路径才会把cookie 发送到服务器，默认包含子路径</p>
</li>
<li><p><code>expires/max-age</code>：表示何时删除cookie 的时间戳（即什么时间之后就不发送到服务器了），默认情况下，浏览器会话结束后会删除所有cookie，不过，也可以设置删除cookie 的时间。这个值是GMT 格式（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定删除cookie 的具体时间，这样即使关闭浏览器cookie 也会保留在用户机器上，把过期时间设置为过去的时间会立即删除cookie</p>
</li>
<li><p><code>size</code>：cookie大小</p>
</li>
<li><p><code>secure</code>：设置之后，只在使用SSL 安全连接的情况下才会把cookie 发送到服务器</p>
</li>
<li><p><code>HttpOnly</code>：HttpOnly值为 true 或 false，若设置为true，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie，可防止通过JavaScript访问cookie的值</p>
</li>
<li><p><code>SameSite</code>：用来限制第三方 Cookie，从而减少安全风险，它有3个属性，分别是：</p>
<ul>
<li><p>Strict：Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie</p>
</li>
<li><p>Lax：Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p>
</li>
<li><p>None：网站可以选择显式关闭SameSite属性，将其设为None，不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效</p>
</li>
</ul>
</li>
<li><p><code>Priority</code>：优先级，定义了三种优先级，Low&#x2F;Medium&#x2F;High，当cookie数量超出时，低优先级的cookie会被优先清除</p>
</li>
</ul>
<h2 id="web-storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>提出的目的是为了解决通过客户端存储<strong>不需要频繁发送回服务器</strong>的数据时使用cookie的问题</p>
<p>基于cookie，Web Storage提出了两个目标：</p>
<ul>
<li>提供在cookie之外的存储会话数据的目标</li>
<li>提供跨会话持久化存储大量数据的机制</li>
</ul>
<h3 id="storage类型"><a href="#Storage类型" class="headerlink" title="Storage类型"></a>Storage类型</h3><p>Storage类型用于保存名&#x2F;值对数据，直到存储空间上限（浏览器决定！）</p>
<p>Storage在对象的基础上，增加如下方法：</p>
<ul>
<li><code>clear()</code>：删除所有值；不在Firefox 中实现</li>
<li><code>getItem(name)</code>：取得给定name 的值</li>
<li><code>key(index)</code>：取得给定数值位置的名称</li>
<li><code>removeItem(name)</code>：删除给定name 的名&#x2F;值对</li>
<li><code>setItem(name, value)</code>：设置给定name 的值</li>
</ul>
<h3 id="sessionstorage对象跨会话存储"><a href="#sessionStorage对象（跨会话存储）" class="headerlink" title="sessionStorage对象（跨会话存储）"></a><code>sessionStorage</code>对象（跨会话存储）</h3><ul>
<li><p><code>sessionStorage</code>对象只存储<strong>会话数据</strong>，所以数据只会存储到<strong>浏览器关闭</strong></p>
</li>
<li><p>存储在<code>sessionStorage</code>中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复</p>
</li>
<li><p>因为<code>sessionStorage</code>对象与服务器会话紧密相关，所以在运行本地文件时不能使用</p>
</li>
<li><p>存储在<code>sessionStorage</code>对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限</p>
</li>
</ul>
<h3 id="localstorage对象永久存储"><a href="#localStorage对象（永久存储）" class="headerlink" title="localStorage对象（永久存储）"></a><code>localStorage</code>对象（永久存储）</h3><ul>
<li><code>localStorage</code>对象作为在客户端<strong>持久存储数据</strong>的机制</li>
<li>要访问同一个<code>localStorage</code>对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议</li>
</ul>
<h3 id="存储事件"><a href="#存储事件" class="headerlink" title="存储事件"></a>存储事件</h3><p>每当Storage 对象发生变化时，都会在文档上触发<code>storage</code>事件。使用属性或<code>setItem()</code>设置值、使用<code>delete</code>或<code>removeItem()</code>删除值，以及每次调用<code>clear()</code>时都会触发这个事件</p>
<p>这个事件的事件对象有如下4 个属性</p>
<ul>
<li><code>domain</code>：存储变化对应的域</li>
<li><code>key</code>：被设置或删除的键</li>
<li><code>newValue</code>：键被设置的新值，若键被删除则为null</li>
<li><code>oldValue</code>：键变化之前的值</li>
</ul>
<p>可以使用如下代码监听<code>storage</code>事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;storage&quot;</span>,</span><br><span class="line">	<span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;Storage changed for $&#123;event.domain&#125;&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>对于<code>sessionStorage</code>和<code>localStorage</code>上的任何更改都会触发<code>storage</code>事件，但<code>storage</code>件不会区分这两者</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul>
<li>cookie：可以通过设置<code>expires/max-age</code>来控制失效时间，没设置就默认关闭浏览器后失效</li>
<li>sessionStorage：仅在当前网页会话下有效，关闭页面或者浏览器会被清除</li>
<li>localStorage：永久保存，除非手动清除</li>
</ul>
<h4 id="存放数据大小"><a href="#存放数据大小" class="headerlink" title="存放数据大小"></a>存放数据大小</h4><ul>
<li>cookie：4kb左右</li>
<li>web Storage：5MB</li>
</ul>
<h4 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h4><ul>
<li>cookie：每次发送请求的时候都会携带在http头中，如果cookie保存过多数据会带来性能问题</li>
<li>web Storage：仅在客户端中保存，不参与和服务器的通信</li>
</ul>
<h4 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h4><ul>
<li>cookie：需要自己封装，包含get set等方法，详情见红宝书第四版P754页</li>
<li>web Storage：原生接口可以接受，也可以再次封装</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多</p>
<p>但是用来识别用户登录来说，cookie还是比stprage更好用的，其他情况下，可以使用storage，就用storage</p>
<p>storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了</p>
<p>localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息，localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数</p>
]]></content>
      <categories>
        <category>常见方法对比</category>
        <category>和我一起读红宝书</category>
      </categories>
      <tags>
        <tag>常见方法对比</tag>
        <tag>和我一起读红宝书</tag>
        <tag>客户端存储</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 | HTTP状态码</title>
    <url>/2022/07/07/%E8%AE%A1%E7%BD%91&amp;&amp;%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>HTTP状态码是非常重要的一个知识点，尤其是对于前端工作者来说，我们在发送网络请求获取资源的时候，经常返回不同的状态码，那么各种状态码都代表什么含义呢~让我们一探究竟吧！</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">含义</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1xx</td>
<td align="center">Informational (信息性状态码)</td>
<td align="center">接收的请求正在处理</td>
</tr>
<tr>
<td align="center">2xx</td>
<td align="center">Success（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3xx</td>
<td align="center">Redirection（重定向状态码）</td>
<td align="center">需要进行附加操作继而完成请求</td>
</tr>
<tr>
<td align="center">4xx</td>
<td align="center">Client Error（客户端错误状态码）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5xx</td>
<td align="center">Server Error（服务器错误状态码）</td>
<td align="center">服务器请求错误</td>
</tr>
</tbody></table>
<h2 id="2xxsucess成功状态码"><a href="#2XX（Sucess成功状态码）" class="headerlink" title="2XX（Sucess成功状态码）"></a>2XX（Sucess成功状态码）</h2><ul>
<li>200 OK：客户端发来的请求被服务端正常处理了</li>
<li>204 No Content：客户端发送的请求已经在服务端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分（一般在只需要从客户端往服务端发送信息，而服务器端不需要往客户端发送内容时使用）</li>
<li>206 Partial Conent：客户端进行了范围请求，而服务器端执行了这部分GET请求，响应报文中包含由Content-Range指定范围的实体内容</li>
</ul>
<h2 id="3xxredirection重定向状态码"><a href="#3XX（Redirection重定向状态码）" class="headerlink" title="3XX（Redirection重定向状态码）"></a>3XX（Redirection重定向状态码）</h2><p>3xx响应结果表明浏览器需要执行某些特殊的处理以正确处理请求</p>
<ul>
<li><p>301 Moved Permanently（永久重定向）：请求的资源已经被分配到新的URL，以后应使用资源指定的URL</p>
</li>
<li><p>302 Found（临时重定向）：请求的资源被分配到新的URL，希望用户（本次）能够使用新的URL访问资源</p>
<ul>
<li>登录首页自动重定向到活动页面</li>
<li>未登录用户访问用户中心重定向到登录页面</li>
<li>访问404后重定向到首页</li>
</ul>
</li>
<li><p>303 See Other：由于请求对应的资源存在着另一个URL，应使用GET方法重定向获取请求资源，和302类似，但是303状态码明确表示客户端应当采用GET获取资源（消息确认页面或者上传进度页面）</p>
</li>
<li><p>304 Not Modified（浏览器缓存相关）：客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，304状态码返回时，不包含任何响应的主体部分</p>
</li>
<li><p>307 Temporary Redirect（临时重定向）：和302类似</p>
</li>
</ul>
<h2 id="4xxclient-error客户端错误状态码"><a href="#4XX（Client-Error客户端错误状态码）" class="headerlink" title="4XX（Client Error客户端错误状态码）"></a>4XX（Client Error客户端错误状态码）</h2><p>4xx响应结果表示客户端是错误所在</p>
<ul>
<li>400 Bad Request：请求报文中存在语法错误，当错误发生时，需修改请求的内容后，再次发送请求</li>
<li>401 Unauthorized：发送的请求需要由通过HTTP认证的认证信息，若之前已进行过一次请求，则表示用户认证失败</li>
<li>403 Forbidden：请求资源的访问被服务器拒绝</li>
<li>404 Not Found：没有在服务器找到资源</li>
<li>405 Method Not Allowed：客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法</li>
</ul>
<h2 id="5xxserver-error服务器错误状态码"><a href="#5XX（Server-Error服务器错误状态码）" class="headerlink" title="5XX（Server Error服务器错误状态码）"></a>5XX（Server Error服务器错误状态码）</h2><ul>
<li>500 Internal Server Error：服务器端在执行请求时发生了错误</li>
<li>502 Bad Gateway：扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的</li>
<li>503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
<li>504 Gateway Timeout：网关或者代理的服务器无法在规定的时间内获得想要的响应</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 | HTTP请求方法</title>
    <url>/2022/07/07/%E8%AE%A1%E7%BD%91&amp;&amp;%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Method</th>
<th align="center">Mean</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET（获取资源）</td>
<td align="center">发送一个请求获取服务器上的某一资源，返回实体主体</td>
</tr>
<tr>
<td align="center">POST（传输实体主体）</td>
<td align="center">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）<br>数据被包含在请求体中，POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改</td>
</tr>
<tr>
<td align="center">PUT（传输文件）</td>
<td align="center">从客户端向服务器传送的数据取代指定文档的内容</td>
</tr>
<tr>
<td align="center">DELETE （删除文件）</td>
<td align="center">请求服务器删除指定页面</td>
</tr>
<tr>
<td align="center">OPTIONS （询问支持的方法）</td>
<td align="center">查询针对请求URI指定的资源支持的方法</td>
</tr>
<tr>
<td align="center">CONNECT（连接方式）</td>
<td align="center">HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td align="center">TRACE（测试诊断）</td>
<td align="center">回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td align="center">PATCH（局部更新）</td>
<td align="center">对已知资源的局部更新</td>
</tr>
</tbody></table>
<h4 id="get-和-post-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h4><ul>
<li><strong>请求参数</strong>：GET请求参数是通过URL传递的，多个参数以&amp;连接，POST请求放在request body中</li>
<li><strong>请求缓存</strong>：GET请求会被缓存，而POST请求不会，除非手动设置</li>
<li><strong>收藏为书签</strong>：GET请求支持，POST请求不支持</li>
<li><strong>安全性</strong>：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求</li>
<li><strong>历史记录</strong>：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留</li>
<li><strong>编码方式</strong>：GET请求只能进行url编码，而POST支持多种编码方式</li>
<li><strong>对参数的数据类型</strong>：GET只接受ASCII字符，而POST没有限制</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP请求</tag>
      </tags>
  </entry>
  <entry>
    <title>登录功能 | node+express+mysql实现用户注册以及token校验</title>
    <url>/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h2><ul>
<li>登录</li>
<li>注册</li>
<li>权限校验</li>
</ul>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ul>
<li>客户端使用用户名和密码请求登录</li>
<li>服务端收到请求后验证是否登录成功<ul>
<li>成功：返回一个token给客户端</li>
<li>失败：提示失败信息</li>
</ul>
</li>
<li>客户端收到token后存储token（token采用jwt进行加密，而不是普通的base64）</li>
<li>每次发起请求时将token发给服务端</li>
<li>服务端接收到请求后，token的合法性<ul>
<li>成功：返回客户端所需数据</li>
<li>失败：返回验证失败的信息</li>
</ul>
</li>
</ul>
<h2 id="流程图解"><a href="#流程图解" class="headerlink" title="流程图解"></a>流程图解</h2><img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png" class title="登录注册流程">

<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/JWT.png" class title="JWT">

<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>node</li>
<li>express</li>
<li>mysql</li>
</ul>
<h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm init <span class="literal">-y</span></span><br></pre></td></tr></table></figure>

<h4 id="安装express"><a href="#安装express" class="headerlink" title="安装express"></a>安装express</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i express</span><br></pre></td></tr></table></figure>

<h4 id="启动node服务_新建appjs文件"><a href="#启动node服务-新建app-js文件" class="headerlink" title="启动node服务_新建app.js文件"></a>启动node服务_新建app.js文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    port: 4000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">4000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;serve is running on port: 4000&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.geeksforgeeks.org/express-js-app-listen-function/">app.listen参数</a></p>
<p>启动端口</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">node app.js </span><br></pre></td></tr></table></figure>

<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E5%90%AF%E5%8A%A8node.png" class title="启动node">

<h3 id="连接mysql"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><p>下面的过程都可以看文档：<a href="https://www.sequelize.com.cn/">sequelize文档</a></p>
<h4 id="安装sequelize和mysql"><a href="#安装Sequelize和MySql" class="headerlink" title="安装Sequelize和MySql"></a>安装Sequelize和MySql</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i sequelize <span class="comment"># 这将安装最新版本的 Sequelize</span></span><br><span class="line">npm i mysql2 <span class="comment"># MySQL</span></span><br></pre></td></tr></table></figure>

<h4 id="连接到数据库_databasex2finitjs"><a href="#连接到数据库-database-x2F-init-js" class="headerlink" title="连接到数据库_database&#x2F;init.js"></a>连接到数据库_database&#x2F;init.js</h4><p>要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// database/init.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Sequelize</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize= <span class="keyword">new</span> <span class="title class_">Sequelize</span>(<span class="string">&#x27;数据库名称&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;你的密码&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">    <span class="attr">dialect</span>: <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><p>引入到app.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./database/init&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>.authenticate()</code> 函数测试连接是否正常：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> sequelize.<span class="title function_">authenticate</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection has been established successfully.&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Unable to connect to the database:&#x27;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><p>默认情况下,<code>Sequelize</code> 将保持连接打开状态,并对所有查询使用相同的连接. 如果你需要关闭连接,请调用 <code>sequelize.close()</code>(这是异步的并返回一个 Promise).</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// database/init.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Sequelize</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize= <span class="keyword">new</span> <span class="title class_">Sequelize</span>(<span class="string">&#x27;test_login&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;yyy674531&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">    <span class="attr">dialect</span>: <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试连接</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sequelize.<span class="title function_">authenticate</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection has been established successfully.&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Unable to connect to the database:&#x27;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>  = &#123;<span class="title class_">Sequelize</span>, sequelize&#125;;  <span class="comment">// 这里导出，下面有用！</span></span><br></pre></td></tr></table></figure>

<h3 id="同步表模型"><a href="#同步表模型" class="headerlink" title="同步表模型"></a>同步表模型</h3><h4 id="创建模型实例_databasex2fmodelsx2fuserjs"><a href="#创建模型实例-database-x2F-models-x2F-User-js" class="headerlink" title="创建模型实例_database&#x2F;models&#x2F;User.js"></a>创建模型实例_database&#x2F;models&#x2F;User.js</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// database/models/User.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Op</span>, <span class="title class_">Model</span>, <span class="title class_">DataTypes</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Sequelize</span>, sequelize &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../init.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = sequelize.<span class="title function_">define</span>(<span class="string">&#x27;users_info&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 应用属性： 禁止null 唯一约束 验证器</span></span><br><span class="line">    <span class="attr">username</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,  </span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,   <span class="comment">// 1. 禁止 null 值</span></span><br><span class="line">        <span class="attr">unique</span>: <span class="literal">true</span>,   <span class="comment">// 2. 唯一约束</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">password</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// validate: &#123;    // 3. 验证器</span></span><br><span class="line">        <span class="comment">//    is: /^[0-9a-f]&#123;64&#125;$/i</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将模型与数据库同步</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意：如果表已经存在，使用&#123;force: true&#125;将该表删除 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">sync</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;user表模型已经同步&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="导出到appjs并启动"><a href="#导出到app-js并启动" class="headerlink" title="导出到app.js并启动"></a>导出到app.js并启动</h4><img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E6%96%B0%E5%BB%BAUser.png" class title="新建User">

<h3 id="实现路由部署准备"><a href="#实现路由部署（准备）" class="headerlink" title="实现路由部署（准备）"></a>实现路由部署（准备）</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/learn/Server-side/Express_Nodejs/routes">Express 教程 4：路由和控制器</a></p>
<h4 id="路由部署_expressrouter"><a href="#路由部署-express-Router" class="headerlink" title="路由部署_express.Router"></a>路由部署_express.Router</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// middleware that is specific to this router</span></span><br><span class="line"><span class="comment">// router.use(function timeLog(req, res, next) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;Time:&#x27;, Date.now());</span></span><br><span class="line"><span class="comment">//     next();</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;Welcome!&#x27;</span>&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<h4 id="引入使用"><a href="#引入使用" class="headerlink" title="引入使用"></a>引入使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./router/user&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;));</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/user&#x27;</span>, router);</span><br></pre></td></tr></table></figure>

<h4 id="postman测试"><a href="#postman测试" class="headerlink" title="postman测试"></a>postman测试</h4><img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E6%B5%8B%E8%AF%951.png" class title="测试1">

<h3 id="实现注册功能"><a href="#实现注册功能" class="headerlink" title="实现注册功能"></a>实现注册功能</h3><h4 id="路由部署"><a href="#路由部署" class="headerlink" title="路由部署"></a>路由部署</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/user.js</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;username, password&#125; = req.<span class="property">body</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(username);  <span class="comment">// postman测试能够拿到username信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E6%B5%8B%E8%AF%952.png" class title="测试2">

<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E6%B5%8B%E8%AF%952-1.png" class title="测试2-1">

<p>可以看到控制台已经打印了~说明能够获取到username的信息</p>
<blockquote>
<p>注册功能说明：</p>
<p>服务器获取到浏览器传过来的username</p>
<p>首先检验是否存在这个username，如果存在就返回“该用户已经存在，请直接登录”</p>
<p>如果不存在，再进行创建</p>
<ol>
<li>去哪里检验——MySQL数据库里面</li>
<li>怎么创建——利用MySQL的create</li>
</ol>
<p>接下来会详细说明</p>
</blockquote>
<h4 id="用户查询"><a href="#用户查询" class="headerlink" title="用户查询"></a>用户查询</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/user.js</span></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="keyword">const</span> bcryptjs = <span class="built_in">require</span>(<span class="string">&#x27;bcryptjs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;username, password&#125; = req.<span class="property">body</span>;</span><br><span class="line">    <span class="comment">// console.log(username);  // postman测试能够拿到username信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户查询</span></span><br><span class="line">    <span class="keyword">const</span> model = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;<span class="attr">where</span>: &#123;<span class="attr">username</span>: username&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;该用户已经存在，请直接登录！&#x27;</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">create</span>(&#123;username, <span class="attr">password</span>:bcryptjs.<span class="title function_">hashSync</span>(password, <span class="number">5</span>)&#125;); <span class="comment">// 加密</span></span><br><span class="line">        <span class="comment">// console.log(user.dataValues);</span></span><br><span class="line">        res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;注册成功！&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>postman测试：创建成功~</p>
<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E6%B5%8B%E8%AF%953.png" class title="测试3">

<p>查询数据库：创建成功~</p>
<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E6%B3%A8%E5%86%8C1.png" class title="注册1">

<p>当我再次用同样的username进行注册请求的时候，返回结果为：<strong>该用户已经存在，请直接登录！</strong></p>
<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E6%B5%8B%E8%AF%952-2.png" class title="测试2-2">

<p>注册功能验证成功~</p>
<h3 id="实现登录功能"><a href="#实现登录功能" class="headerlink" title="实现登录功能"></a>实现登录功能</h3><blockquote>
<p>登录功能说明：</p>
<p>通过发送username和password进行登录</p>
<ul>
<li><p>如果uername不存在，就返回“该用户不存在，请先注册”</p>
</li>
<li><p>如果username存在，要先进行密码校验</p>
<ul>
<li>密码校验不成功——返回“密码错误”</li>
<li>密码校验成功——返回token</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="登录功能部署"><a href="#登录功能部署" class="headerlink" title="登录功能部署"></a>登录功能部署</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/user.js</span></span><br><span class="line"><span class="comment">// 登录功能</span></span><br><span class="line"><span class="keyword">const</span> bcryptjs = <span class="built_in">require</span>(<span class="string">&#x27;bcryptjs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;username, password&#125; = req.<span class="property">body</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    <span class="keyword">const</span> model = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;<span class="attr">where</span>: &#123;<span class="attr">username</span>: username&#125;&#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!model) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;该用户不存在，请先注册！&#x27;</span>&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果存在username就要进行密码校验</span></span><br><span class="line">        <span class="keyword">const</span> passwordValid = bcryptjs.<span class="title function_">compareSync</span>(password, model.<span class="property">dataValues</span>.<span class="property">password</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!passwordValid) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;密码错误！&#x27;</span>&#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;登录成功！&#x27;</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>正确输入用户名和密码：</p>
<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E7%99%BB%E5%BD%951.png" class title="登录1">

<p>输入错误密码：</p>
<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E7%99%BB%E5%BD%952.png" class title="登录2">

<p>输入未注册用户名：</p>
<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E7%99%BB%E5%BD%953.png" class title="登录3">

<h4 id="token生成及返回_jsonwebtoken"><a href="#token生成及返回-jsonwebtoken" class="headerlink" title="token生成及返回_jsonwebtoken"></a>token生成及返回_jsonwebtoken</h4><p><a href="https://segmentfault.com/a/1190000009494020">jwt中文文档</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jwt.<span class="title function_">sign</span>(payload, secretOrPrivateKey, [options, callback]);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/user.js</span></span><br><span class="line"><span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(&#123;username&#125;, <span class="string">&#x27;ccken&#x27;</span>)</span><br><span class="line">res.<span class="title function_">send</span>(&#123;token&#125;)</span><br></pre></td></tr></table></figure>

<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/token.png" class title="token">

<h3 id="实现权限校验"><a href="#实现权限校验" class="headerlink" title="实现权限校验"></a>实现权限校验</h3><blockquote>
<p>权限校验说明：</p>
<ol>
<li>token包含在请求头里面，所以第一步我们要获取token<ul>
<li>如果没有token说明前面没有登录过或者是登录已经失效，返回“请登录”</li>
</ul>
</li>
<li>利用token 密钥 和 payload对token进行解析</li>
<li>对解析结果进行校验查询<ul>
<li>如果查询结果为空，返回’请注册‘</li>
<li>如果不为空，则说明“权限校验成功！”</li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/user.js</span></span><br><span class="line"><span class="comment">// 权限校验</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/auth&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取token，token是在请求头里面的</span></span><br><span class="line">    <span class="keyword">const</span> token =  <span class="title class_">String</span>(req.<span class="property">headers</span>.<span class="property">authorization</span>).<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">pop</span>();</span><br><span class="line">    <span class="comment">// 如果没有token说明前面没有登录过或者是登录已经失效</span></span><br><span class="line">    <span class="keyword">if</span> (!token) <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;请登录！&#x27;</span>&#125;)</span><br><span class="line">    <span class="comment">// 根据密钥和字段解析token</span></span><br><span class="line">    <span class="keyword">const</span> &#123;username&#125; = jwt.<span class="title function_">verify</span>(token, <span class="string">&#x27;ccken&#x27;</span>);   <span class="comment">// 之前使用username进行注册的</span></span><br><span class="line">    <span class="comment">// 对解析结果进行校验查询</span></span><br><span class="line">    <span class="keyword">const</span> model = <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;<span class="attr">where</span>: &#123;<span class="attr">username</span>: username&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!model) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;请注册！&#x27;</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.<span class="title function_">send</span>(&#123;<span class="attr">msg</span>: <span class="string">&#x27;权限校验成功！&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<img src="/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/%E6%A0%A1%E9%AA%8C1.png" class title="校验1">



<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以上过程的代码放在github了~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.geeksforgeeks.org/express-js-app-listen-function/">app.listen参数</a></p>
<p><a href="https://www.sequelize.com.cn/">sequelize文档</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/learn/Server-side/Express_Nodejs/routes">Express 教程 4：路由和控制器</a></p>
<p><a href="https://segmentfault.com/a/1190000009494020">jwt中文文档</a></p>
<p><a href="https://juejin.cn/post/6898630134530752520">cookie、session、token、jwt、单点登录</a></p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
        <tag>node</tag>
        <tag>mysql</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>登录功能 | 流程概述</title>
    <url>/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>实现一个登录功能页面</p>
<p>要求如下：</p>
<ol>
<li>能够正常登录登出</li>
<li>规定用户名和密码的格式</li>
</ol>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>react项目构建——不说了</li>
<li>封装后端接口，实现登录调用和身份验证</li>
<li>antd实现登录页面</li>
</ol>
<h3 id="封装后端接口"><a href="#封装后端接口" class="headerlink" title="封装后端接口"></a>封装后端接口</h3><p>看这篇：<a href="https://superkatrina123.github.io/2022/07/27/Demo/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD_node+express+mysql%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8Atoken%E6%A0%A1%E9%AA%8C/">登录功能_node+express+mysql实现用户注册以及token校验</a></p>
<h3 id="登录页面实现"><a href="#登录页面实现" class="headerlink" title="登录页面实现"></a>登录页面实现</h3><p>看这篇：<a href>react+antd实现登录页面</a></p>
]]></content>
      <categories>
        <category>React</category>
        <category>Demo</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>功能模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 | 常见的排序算法及其优化（含图示和JS实现）</title>
    <url>/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AJS%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是通过重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p>
<img src="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AJS%E5%AE%9E%E7%8E%B0/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" class title="冒泡排序">

<p><strong>算法思路</strong></p>
<p>（以升序为例）</p>
<ul>
<li>比较相邻元素，初始为索引为0和索引为1的元素，如果第一个比第二个大，就交换这两个元素</li>
<li>对每一对相邻元素重复同样的工作，直到最后一对，索引为<code>arr.length - 2</code> 和 <code>arr.length - 1</code>，这样 <code>arr.length - 1</code>索引处的元素将会是最大的</li>
<li>重复步骤1和2，得到索引为<code>arr.length - 2</code>为剩余元素中最大的</li>
<li>重复步骤1-3，直到排序完成</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span>; i &gt; <span class="number">0</span>; i--) &#123;    <span class="comment">// 用i来设置最后一组的边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;      <span class="comment">// 如果顺序不对就交换</span></span><br><span class="line">                [arr[j], arr[j-<span class="number">1</span>]] = [arr[j-<span class="number">1</span>], arr[j]];   <span class="comment">// 交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">bubbleSort</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复杂度分析：</span></span><br><span class="line"><span class="comment">		时间复杂度： O(n^2)</span></span><br><span class="line"><span class="comment">		空间复杂度： O(1)</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	稳定性分析：冒泡排序并不会破坏元素的相对位置</span></span><br><span class="line"><span class="comment">		稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>代码优化</strong></p>
<ul>
<li><p><strong>外层优化</strong>：在某一层循环的时候并没有发生交换，说明前面已经全部有序，不需要再执行下去了，直接退出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSortA</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span>;   <span class="comment">// flag用于标识此轮是否有交换行为</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j-<span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;   <span class="comment">// flag === true就表示有</span></span><br><span class="line">                [arr[j], arr[j-<span class="number">1</span>]] = [arr[j-<span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flag === <span class="literal">false</span>) &#123;   <span class="comment">// 这一轮没有交换行为 就表示全部都有序了 直接返回arr </span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复杂度分析：</span></span><br><span class="line"><span class="comment">		时间复杂度： 最好O(n),只需要循环一次，最坏O(n^2)</span></span><br><span class="line"><span class="comment">		空间复杂度： O(1)</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	稳定性分析：冒泡排序并不会破坏元素的相对位置</span></span><br><span class="line"><span class="comment">		稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">bubbleSortA</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内层优化</strong>：在每一层循环的时候，记住这一层循环最后一次交换的位置，这样就说明后面的是有序的不用重复比较交换了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSortB</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = arr.<span class="property">length</span>, pos;  <span class="comment">// 用pos记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span>;   <span class="comment">// flag用于标识此轮是否有交换行为</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j-<span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;   <span class="comment">// flag === true就表示有</span></span><br><span class="line">                pos = j;       <span class="comment">// 目前最后一次交换在j的位置</span></span><br><span class="line">                [arr[j], arr[j-<span class="number">1</span>]] = [arr[j-<span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        i = pos;    <span class="comment">// 边界用pos代替</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flag === <span class="literal">false</span>) &#123;   <span class="comment">// 说明此轮没有交换行为</span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">bubbleSortB</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复杂度分析：</span></span><br><span class="line"><span class="comment">		时间复杂度： O(n^2)</span></span><br><span class="line"><span class="comment">		空间复杂度： O(1)</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	稳定性分析：冒泡排序并不会破坏元素的相对位置</span></span><br><span class="line"><span class="comment">		稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><img src="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AJS%E5%AE%9E%E7%8E%B0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" class title="选择排序">

<p><strong>算法思路</strong></p>
<ul>
<li>首先在未排序的数组中找到最大（小）的元素，放在排序数组的起始位置</li>
<li>再从剩余的元素中找到最大（小）的元素，放在已经排序的末尾</li>
<li>重复步骤2，直至排序完成</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;   <span class="comment">// i表示排序数组的末尾索引</span></span><br><span class="line">        <span class="keyword">let</span> minValue = arr[i], minIndex = i;   <span class="comment">// 用于记录未排序数组的最小元素和对应的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; minValue) &#123;   <span class="comment">// 通过遍历的方式查找</span></span><br><span class="line">                minValue = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];   <span class="comment">// 找到后把排序数组的末尾索引元素和未排序数组中最小的元素进行交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">selectSort</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复杂度分析：</span></span><br><span class="line"><span class="comment">		时间复杂度： O(n^2)</span></span><br><span class="line"><span class="comment">		空间复杂度： O(1)</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	稳定性分析：选择排序在找到后把排序数组的末尾索引元素和未排序数组中最小的元素进行交换这个过程就破坏了元素的相对位置</span></span><br><span class="line"><span class="comment">		不稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>代码优化</strong></p>
<ul>
<li>优化：一次就选出最大最小的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSortA</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> left = <span class="number">0</span>, right = arr.<span class="property">length</span> - <span class="number">1</span>; left &lt; right; left++, right--) &#123;</span><br><span class="line">        <span class="comment">// 用于记录最大值和最小值的索引</span></span><br><span class="line">        <span class="keyword">let</span> minIndex = left, maxIndex = right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到每次遍历的最大值和最小值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = left; index &lt;= right; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &lt; arr[minIndex]) minIndex = index;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt; arr[maxIndex]) maxIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        [arr[left], arr[minIndex]] = [arr[minIndex], arr[left]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此处是先排最小值的位置，所以得考虑最大值（arr[maxIndex]）在最小位置（left）的情况</span></span><br><span class="line">        <span class="comment">// 如果不考虑这里的话，因为前面已经交换过了，所以会导致无效交换，反而把最大值的value交换回来了</span></span><br><span class="line">        <span class="keyword">if</span> (left === maxIndex) &#123;</span><br><span class="line">            maxIndex = minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        [arr[right], arr[maxIndex]] = [arr[maxIndex], arr[right]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">selectSortA</span>(arr));   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<img src="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AJS%E5%AE%9E%E7%8E%B0/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" class title="插入排序">

<p><strong>算法思路</strong></p>
<ul>
<li>初始化：将第一个元素看作是有序数组，将第一个元素之后的元素看作是未排序序列</li>
<li>遍历未排序序列，并依次插入到有序数组的合适位置（这里需要注意的是，插入到排序数组合适位置之后排序数组的其他元素的位置是如何处理的？）</li>
<li>返回排序数组</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = arr[i];   <span class="comment">// 记录未排序数组的第一个元素</span></span><br><span class="line">        <span class="keyword">let</span> position = i;     <span class="comment">// 记录此刻的位置</span></span><br><span class="line">        <span class="keyword">while</span> (position &gt;= <span class="number">0</span> &amp;&amp; arr[position - <span class="number">1</span>] &gt; value) &#123;   <span class="comment">// 把此刻的元素插入到排序数组的合适位置</span></span><br><span class="line">            [arr[position], arr[position - <span class="number">1</span>]] = [arr[position-<span class="number">1</span>], arr[position]];</span><br><span class="line">            position--;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">insertSort</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复杂度分析：</span></span><br><span class="line"><span class="comment">		时间复杂度： O(n^2)</span></span><br><span class="line"><span class="comment">		空间复杂度： O(1)</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	稳定性分析：插入排序并没有破坏相对位置</span></span><br><span class="line"><span class="comment">		稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>算法优化</strong></p>
<p>优化点：在找插入位置的时候可以采用<strong>二分查找</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSortA</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = arr[i];  <span class="comment">// 记录当前元素</span></span><br><span class="line">        <span class="keyword">let</span> position = i;   <span class="comment">// 记录当前位置</span></span><br><span class="line">        <span class="keyword">let</span> insertIndex = <span class="title function_">searchInsert</span>(arr.<span class="title function_">slice</span>(<span class="number">0</span>, i), value);   <span class="comment">// 利用二分查找找到要插入的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到位置后把后面的元素都往后面移动</span></span><br><span class="line">        <span class="keyword">while</span> (insertIndex !== position &amp;&amp; position &gt; insertIndex) &#123;</span><br><span class="line">            arr[position] = arr[position-<span class="number">1</span>];</span><br><span class="line">            position--;</span><br><span class="line">        &#125;;</span><br><span class="line">        arr[insertIndex] = value;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二分查找找到要插入的位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">searchInsert</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">insertSortA</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><img src="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AJS%E5%AE%9E%E7%8E%B0/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" class title="归并排序">

<p><strong>算法步骤</strong></p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设两个指针，最初位置为两个已经排好序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对较小的元素放入合并空间，并移动指针</li>
<li>重复步骤3直到指针到达末尾</li>
<li>将另一序列剩下的元素直接合并到序列尾部</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> arr;   <span class="comment">// 只有一个元素不用比较了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到中点分隔数组</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">let</span> right = arr.<span class="title function_">slice</span>(mid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="comment">// 给合并数组分配空间</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断指针指向元素的大小，把小的放入res数组中</span></span><br><span class="line">    <span class="keyword">while</span> (left.<span class="property">length</span> &amp;&amp; right.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(left.<span class="title function_">shift</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(right.<span class="title function_">shift</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有元素剩余</span></span><br><span class="line">    res = left.<span class="property">length</span> ? [...res, ...left] : [...res, ...right];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">mergeSort</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复杂度分析：</span></span><br><span class="line"><span class="comment">		时间复杂度： O(nlogn)</span></span><br><span class="line"><span class="comment">		空间复杂度： O(n)</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	稳定性分析：归并排序并没有破坏相对位置</span></span><br><span class="line"><span class="comment">		稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><img src="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AJS%E5%AE%9E%E7%8E%B0/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" class title="快速排序">

<p><strong>算法思路</strong></p>
<ul>
<li>找到一个元素，作为基准</li>
<li>剩余元素重新排序，比基准小的放在左边，比基准大的放在右边</li>
<li>递归左边和右边，得到结果</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置递归终止条件 arr只有一个元素或者没有元素 直接返回arr</span></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到基准点</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> pivot = arr[mid];</span><br><span class="line">    arr.<span class="title function_">splice</span>(mid, <span class="number">1</span>);  <span class="comment">// 从数组中删除基准</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配空间用于存放比基准大和小的元素</span></span><br><span class="line">    <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            left.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果为 左 + 基准 + 右</span></span><br><span class="line">    <span class="comment">// 左和右还要递归</span></span><br><span class="line">    <span class="keyword">return</span> [...<span class="title function_">quickSort</span>(left), pivot, ...<span class="title function_">quickSort</span>(right)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">mergeSort</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复杂度分析：</span></span><br><span class="line"><span class="comment">		时间复杂度： O(nlogn)</span></span><br><span class="line"><span class="comment">		空间复杂度： O(logn)</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	稳定性分析：快速排序一直在打乱相对位置</span></span><br><span class="line"><span class="comment">		不稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><img src="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AJS%E5%AE%9E%E7%8E%B0/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" class title="堆排序">

<p><strong>算法思路</strong></p>
<ul>
<li>构造大顶堆，把堆顶元素和最后一个元素交换（相当于把最大的元素放在最后面了），堆大小减去1</li>
<li>交换后，把剩余的元素继续构造大顶堆，即把剩余元素最大的元素选出来放在堆顶，重复步骤1</li>
<li>继续重复步骤1和2，直至堆大小为1</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现最大堆的构建</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	注意最大堆的特点：所有节点都大于其子节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> len;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">array</span>) &#123;</span><br><span class="line">     len = array.<span class="property">length</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         <span class="title function_">heapify</span>(array, i);</span><br><span class="line">     &#125;;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapify</span>(<span class="params">arr, i</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">2</span> * i + <span class="number">1</span>,    <span class="comment">// 如果存在，左子节点index为2 * i + 1</span></span><br><span class="line">        right = <span class="number">2</span> * i + <span class="number">2</span>,   <span class="comment">// 如果存在，右子节点index为2 * i + 2</span></span><br><span class="line">        largest = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">        [arr[i], arr[largest]] = [arr[largest], arr[i]];</span><br><span class="line">        <span class="title function_">heapify</span>(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="title function_">buildMaxHeap</span>(arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span>-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        [arr[<span class="number">0</span>], arr[i]] = [arr[i], arr[<span class="number">0</span>]];</span><br><span class="line">        len--;</span><br><span class="line">        <span class="title function_">heapify</span>(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">heapSort</span>(arr);   <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复杂度分析</span></span><br><span class="line"><span class="comment">	时间复杂度： O(nlogn)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 | 使用队列和双端队列解决问题</title>
    <url>/2022/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%92%8C%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>Queue类和Deque类请参考：<a href="https://superkatrina123.github.io/2022/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E7%BB%84/">Queue 和 Deque</a></p>
</blockquote>
<h3 id="循环队列击鼓传花游戏队列"><a href="#循环队列——击鼓传花游戏（队列）" class="headerlink" title="循环队列——击鼓传花游戏（队列）"></a>循环队列——击鼓传花游戏（队列）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">elementsList, num</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">    <span class="keyword">const</span> elimitatedList = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先把参与的elementsList加入到队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elementsList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        queue.<span class="title function_">enqueue</span>(elementsList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(queue)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始击鼓</span></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(queue.size())</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>());   <span class="comment">// 把对头元素加入到队尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        elimitatedList.<span class="title function_">push</span>(queue.<span class="title function_">dequeue</span>());  <span class="comment">// 一轮循环结束后，对头的被淘汰，循环继续</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">eliminated</span>: elimitatedList,</span><br><span class="line">        <span class="attr">winner</span>: queue.<span class="title function_">dequeue</span>()   <span class="comment">// 最后剩下的人为胜利者</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;Kate&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">hotPotato</span>(names, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">res.<span class="property">eliminated</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ele&#125;</span> 在击鼓传花游戏中被淘汰！`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`胜利者是<span class="subst">$&#123;res.winner&#125;</span>！`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Jenny 在击鼓传花游戏中被淘汰！</span></span><br><span class="line"><span class="comment">	Jack 在击鼓传花游戏中被淘汰！</span></span><br><span class="line"><span class="comment">	Tom 在击鼓传花游戏中被淘汰！</span></span><br><span class="line"><span class="comment">	Kate 在击鼓传花游戏中被淘汰！</span></span><br><span class="line"><span class="comment">	胜利者是John！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果要实现随机，可以在不同轮次传入不同的num！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="回文检查器双端队列"><a href="#回文检查器（双端队列）" class="headerlink" title="回文检查器（双端队列）"></a>回文检查器（双端队列）</h3><p>一般回文检查我们使用双指针的方式，但是使用双端队列也是一种好办法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">palindromeChecker</span>(<span class="params">aString</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aString === <span class="literal">undefined</span> || aString === <span class="literal">null</span> || !aString.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> deque = <span class="keyword">new</span> <span class="title class_">Deque</span>();</span><br><span class="line">   	<span class="keyword">const</span> lowerString = [...aString];   <span class="comment">// 解构赋值：字符串转数组</span></span><br><span class="line">    <span class="keyword">let</span> firstChar, lastChar;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把元素存入deque中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lowerString.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        deque.<span class="title function_">addBack</span>(lowerString[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断ing</span></span><br><span class="line">    <span class="keyword">while</span> (deque.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        firstChar = deque.<span class="title function_">removeFront</span>();</span><br><span class="line">        lastChar = deque.<span class="title function_">removeBack</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (firstChar !== lastChar) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> aString1 = <span class="string">&#x27;helloaolleh&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> aString2 = <span class="string">&#x27;helloworldolleh&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">palindromeChecker</span>(aString1));  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">palindromeChecker</span>(aString2));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
        <category>手写场景</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写场景</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 | 哈希表</title>
    <url>/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="哈希表基础知识"><a href="#哈希表基础知识" class="headerlink" title="哈希表基础知识"></a>哈希表基础知识</h3><p>哈希表，又叫散列表（HashTable或者HashMap），是根据键直接访问记录在存储位置的数据结构，通过哈希函数根据计算出在哈希表中的内存地址</p>
<p>作用是尽可能快地在数据结构中找到一个值</p>
<img src="/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%B8%8C%E8%A1%A8/%E5%93%88%E5%B8%8C%E8%A1%A8.png" class title="哈希表">

<h3 id="实现哈希表"><a href="#实现哈希表" class="headerlink" title="实现哈希表"></a>实现哈希表</h3><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><ul>
<li>get(val)</li>
<li>put(key, val)</li>
<li>remove(key)</li>
</ul>
<h4 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValuePair</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">key, val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;<span class="variable language_">this</span>.key&#125;</span>:<span class="subst">$&#123;<span class="variable language_">this</span>.val&#125;</span>]`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">toStrFn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">table</span> = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 创建哈希函数: 传入key -&gt; 获取内存地址</span></span><br><span class="line">    <span class="title function_">loseloseHashTable</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> tablekey = <span class="title class_">String</span>(key);</span><br><span class="line">        <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableKey.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            hash += tablekey.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash % <span class="number">37</span>;  <span class="comment">// 获取hash值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">hashCode</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">loseloseHashTable</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hashTable添加键值对</span></span><br><span class="line">    <span class="title function_">put</span>(<span class="params">key, val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="literal">null</span> &amp;&amp; val !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);   <span class="comment">// position是内存地址</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">table</span>[position] = <span class="keyword">new</span> <span class="title class_">ValuePair</span>(key, val);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hashTable中获取val</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="variable language_">this</span>.<span class="property">table</span>[<span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key)];</span><br><span class="line">        <span class="keyword">return</span> valuePair = valuePair ? valuePair.<span class="property">val</span> : <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hashTable删除值</span></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> hash = <span class="variable language_">this</span>.<span class="title function_">hashCode</span>(key);</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="variable language_">this</span>.<span class="property">table</span>[hash];</span><br><span class="line">        <span class="keyword">if</span> (valuePair) &#123;</span><br><span class="line">            <span class="comment">// 使用delete或者设置null或者undefined是一样的</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">table</span>[hash];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下子~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hash = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line"></span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Katrina&#x27;</span>, <span class="string">&#x27;111.com&#x27;</span>);</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;222.com&#x27;</span>);</span><br><span class="line">hash.<span class="title function_">puth</span>(<span class="string">&#x27;Kate&#x27;</span>, <span class="string">&#x27;333.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">hashCode</span>(<span class="string">&#x27;Katrina&#x27;</span>) + <span class="string">&#x27;-Katrina&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">hashCode</span>(<span class="string">&#x27;Jenny&#x27;</span>) + <span class="string">&#x27;-Jenny&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">hashCode</span>(<span class="string">&#x27;Kate&#x27;</span>) + <span class="string">&#x27;-Kate&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	11-Katrina</span></span><br><span class="line"><span class="comment">	35-Jenny</span></span><br><span class="line"><span class="comment">	19-Kate</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Katrina&#x27;</span>));   <span class="comment">// 111.com</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Lisa&#x27;</span>));    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">hash.<span class="title function_">remove</span>(<span class="string">&#x27;Kate&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Kate&#x27;</span>));   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="哈希表和哈希集合"><a href="#哈希表和哈希集合" class="headerlink" title="哈希表和哈希集合"></a>哈希表和哈希集合</h3><h4 id="处理哈希表中的冲突"><a href="#处理哈希表中的冲突" class="headerlink" title="处理哈希表中的冲突"></a>处理哈希表中的冲突</h4><p>一些键会有相同的hash值，比如<code>hash.hashCode(&#39;Jenny&#39;)</code>和<code>hash.hashCode(&#39;Jisoo&#39;)</code>都是35，一般来说，具有相同hash值的数据在hash表中值会被替换</p>
<p>看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hash = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line"></span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Jisoo&#x27;</span>, <span class="string">&#x27;111.com&#x27;</span>);</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Jenny&#x27;</span>, <span class="string">&#x27;222.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">hashCode</span>(<span class="string">&#x27;Jisoo&#x27;</span>) + <span class="string">&#x27;-Jisoo&#x27;</span>);   <span class="comment">// 35-Jisoo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">hashCode</span>(<span class="string">&#x27;Jenny&#x27;</span>) + <span class="string">&#x27;-Jenny&#x27;</span>);   <span class="comment">// 35-Jenny</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Jisoo&#x27;</span>));   <span class="comment">// 222.com  显然已经被替换</span></span><br></pre></td></tr></table></figure>

<p>处理冲突的方法有：分离链接、线性探查、双散列法</p>
<h5 id="1-分离链接"><a href="#1-分离链接" class="headerlink" title="1. 分离链接"></a>1. 分离链接</h5><p>分离链接指的是为哈希表的每一个位置创建一个链表并且要将元素存储在里面</p>
<img src="/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%B8%8C%E8%A1%A8/%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5.png" class title="分离链接">

<ul>
<li><p>重写put方法</p>
<p>重写思路：验证要加入的新元素的位置是否已经被占据，如果已经占据，会创建一个NodeList实例，将ValuePair加入到这个实例</p>
</li>
<li><p>重写get</p>
<p>重写思路：验证能否在特定位置找到该元素，定位后，通过遍历ListNode得到元素，没有找到就返回undefined</p>
</li>
<li><p>重写remove</p>
<p>重写思路：类似于定位后找到链表，然后去删除链表中的节点</p>
</li>
</ul>
<h5 id="2-线性探查"><a href="#2-线性探查" class="headerlink" title="2. 线性探查"></a>2. 线性探查</h5><p>将元素直接存到表中，而不是在单独的数据结构中</p>
<img src="/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%93%88%E5%B8%8C%E8%A1%A8/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%9F%A5.png" class title="线性探查">

<ul>
<li><p>重写put</p>
<p>重写思路：当向hash表存放元素的时候，若发现position已经被占据了，就存放在position+1中，如果position+1也被占据了，则存放在position+2中，以此类推…</p>
</li>
<li><p>重写get</p>
<p>重写思路：查找键，不存在一定是undefined，如果存在就要检查我们要找的值是不是在这个原始位置上，如果不是，就继续找，完整迭代后还是找不到返回undefined</p>
</li>
<li><p>重写remove</p>
</li>
</ul>
<p>​		重写思路和put基本相同，不再赘述</p>
<h5 id="3-双散列法"><a href="#3-双散列法" class="headerlink" title="3. 双散列法"></a>3. 双散列法</h5><p>创建更好地散列函数：1. 插入和检索元素的时间；2. 较低的冲突可能性</p>
<p>比lose lose哈希函数更好的函数是djb2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">djb2HashCode</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tableKey = <span class="title class_">String</span>(key);</span><br><span class="line">   	<span class="keyword">let</span> hash = <span class="number">5381</span>;  <span class="comment">// 初始化一个hash变量并且赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; table.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        hash = (hash * <span class="number">33</span>) + tableKey.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">1013</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录_哈希表</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 | 数组、栈、队列（含JS实现）</title>
    <url>/2022/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><p>数组是存放<strong>连续内存空间</strong>上的<strong>相同数据类型</strong>的集合</p>
<blockquote>
<p>在JavaScript中，可以在数组中保存不同数据类型的值，因此内存地址并不是连续的，而是采用hash映射的方式</p>
<p>但是现在的JavaScript引擎为了优化JavaScript，会分配一个连续的内存空间给相同数据类型的数组，以达到更好的遍历效果，所以，只要你数组里面存的是相同类型的值，在内存中的地址是连续的</p>
</blockquote>
<img src="/2022/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.png" class title="数组">

<p>需要注意：</p>
<ul>
<li>数组的下标都是从0开始的</li>
<li>数组内存空间的地址是<strong>连续</strong>的</li>
</ul>
<p>所以在删除或者增加元素的时候，就难免要移动其他元素的地址</p>
<img src="/2022/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%841.png" class title="数组1">

<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p><a href="https://superkatrina123.github.io/2022/07/06/JavaScript/%E6%95%B0%E7%BB%84_Array_API/">JavaScript数组API（含手写）</a></p>
<h3 id="栈含手写栈类"><a href="#栈（含手写栈类）" class="headerlink" title="栈（含手写栈类）"></a>栈（含手写栈类）</h3><blockquote>
<p>栈是一种遵循<strong>后进先出（LIFO）</strong>的有序集合</p>
</blockquote>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><ul>
<li>向栈顶添加元素——push</li>
<li>从栈顶删除元素——pop </li>
<li>查看栈顶元素——peek</li>
<li>检查栈是否为空——isEmpty</li>
<li>清空栈元素——clear</li>
</ul>
<h4 id="基于数组实现栈及其方法"><a href="#基于数组实现栈及其方法" class="headerlink" title="基于数组实现栈及其方法"></a>基于数组实现栈及其方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// length可以用size代替</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向栈顶添加元素——push</span></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从栈顶删除元素——pop </span></span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看栈顶元素——peek</span></span><br><span class="line">    <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查栈是否为空——isEmpty</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空栈元素——clear</span></span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用一下吧~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化stack</span></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	实现以下效果：</span></span><br><span class="line"><span class="comment">	[push(2), push(3), push(4), pop(), isEmpty(), peek(), pop(), pop(), isEmpty()]</span></span><br><span class="line"><span class="comment">	得到的结果是：</span></span><br><span class="line"><span class="comment">	[1,2,3,4,false,3,3,2,true]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>());   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>());   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">pop</span>();</span><br><span class="line">stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>());   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="基于对象实现栈及其方法"><a href="#基于对象实现栈及其方法" class="headerlink" title="基于对象实现栈及其方法"></a>基于对象实现栈及其方法</h4><blockquote>
<p>用数组实现Stack是非常方便的，但是如果要在数组中找一个元素，最坏的情况下需要迭代数组的所有位置，也就是时间复杂度是O(n)</p>
<p>另外，数组是一个有序集合，为了保证元素排列有序，它会占用更多的内存空间</p>
</blockquote>
<p>使用JavaScript对象存储所有栈元素的优势在于：</p>
<ul>
<li>直接获取元素，占用较少的内存空间</li>
<li>保证所有元素按照我们需要的排序</li>
</ul>
<p>注意：相对于数组版本，对象版本需要实现toString()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span> = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// length可以用size代替</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查栈是否为空——isEmpty</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向栈顶添加元素——push</span></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">count</span>] = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从栈顶删除元素——pop </span></span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">undefined</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> -<span class="number">1</span>];</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看栈顶元素——peek</span></span><br><span class="line">    <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">count</span> -<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// toString()  [对象特有]</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> objString = <span class="title class_">String</span>(<span class="variable language_">this</span>.<span class="property">stack</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">count</span>; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.stack[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用一下吧~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化stack</span></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	实现以下效果：</span></span><br><span class="line"><span class="comment">	[push(2), push(3), push(4), pop(), isEmpty(), peek(), pop(), pop(), isEmpty(), push(2), push(3), push(4), toString()]</span></span><br><span class="line"><span class="comment">	得到的结果是：</span></span><br><span class="line"><span class="comment">	[1,2,3,4,false,3,3,2,true,1,2,3, &#x27;1,2,3&#x27;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>());   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>());   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">pop</span>();</span><br><span class="line">stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>());   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">toString</span>());  <span class="comment">// 2,3,4</span></span><br></pre></td></tr></table></figure>

<h4 id="栈应用"><a href="#栈应用" class="headerlink" title="栈应用"></a>栈应用</h4><ul>
<li>函数调用</li>
<li>表达式求值</li>
<li>括号匹配</li>
<li>浏览器的前进、后退功能</li>
</ul>
<h3 id="队列含手写队列类"><a href="#队列（含手写队列类）" class="headerlink" title="队列（含手写队列类）"></a>队列（含手写队列类）</h3><blockquote>
<p>队列是一种遵循<strong>先进先出（FIFO）</strong>的有序集合</p>
</blockquote>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><ul>
<li>向队列添加元素——enqueue</li>
<li>从队列移除元素——dequeue</li>
<li>查看队列头元素——peek</li>
<li>检查队列是否为空——isEmpty</li>
<li>清空队列——clear</li>
</ul>
<h4 id="基于数组实现队列及其方法"><a href="#基于数组实现队列及其方法" class="headerlink" title="基于数组实现队列及其方法"></a>基于数组实现队列及其方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向队列添加元素——enqueue</span></span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队列移除元素——dequeue</span></span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看队列头元素——peek</span></span><br><span class="line">    <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查队列是否为空——isEmpty</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空队列——clear</span></span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于对象实现队列及其方法"><a href="#基于对象实现队列及其方法" class="headerlink" title="基于对象实现队列及其方法"></a>基于对象实现队列及其方法</h4><blockquote>
<p>基于对象实现队列比数组要难一点，因为对象是根据key来记录索引的，所以需要lowsetCount来记录队头元素的索引</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lowsetCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> - <span class="variable language_">this</span>.<span class="property">lowsetCount</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向队列添加元素——enqueue</span></span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">count</span>] = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队列移除元素——dequeue</span></span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> res = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span>];</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lowsetCount</span>++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看队列头元素——peek</span></span><br><span class="line">    <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查队列是否为空——isEmpty</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="title function_">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空队列——clear</span></span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = &#123;&#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lowsetCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// toString()</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> objString = <span class="title class_">String</span>(<span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lowsetCount</span>+<span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">count</span>; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.queue[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用一下吧~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	实现下列效果：</span></span><br><span class="line"><span class="comment">	[enqueue(1), enqueue(2), enqueue(3), isEmpty() ,peek(), dequeue(), dequeue(), enqueue(4), toString()]</span></span><br><span class="line"><span class="comment">	打印</span></span><br><span class="line"><span class="comment">	[1,2,3,false,1,1,2,4, &#x27;3,4&#x27;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">isEmpty</span>());  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">peek</span>());   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">queue.<span class="title function_">dequeue</span>();</span><br><span class="line">queue.<span class="title function_">dequeue</span>();</span><br><span class="line"></span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">toString</span>());   <span class="comment">// 3,4</span></span><br></pre></td></tr></table></figure>

<h4 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h4><ul>
<li>排队</li>
<li>异步任务：微任务队列和宏任务队列</li>
<li>打印队列</li>
</ul>
<h3 id="双端队列含手写双端队列类"><a href="#双端队列（含手写双端队列类）" class="headerlink" title="双端队列（含手写双端队列类）"></a>双端队列（含手写双端队列类）</h3><blockquote>
<p>双端队列支持同时从后面或者前面添加或者移除元素</p>
</blockquote>
<h4 id="双端队列方法"><a href="#双端队列方法" class="headerlink" title="双端队列方法"></a>双端队列方法</h4><ul>
<li>从队头添加元素——addFront</li>
<li>从队尾添加元素——addBack</li>
<li>从队头移除元素——removeFront</li>
<li>从队尾移除元素——removeBack</li>
<li>查看队头元素——peekFont</li>
<li>查看队尾元素——peekBack</li>
<li>检查队列是否为空——isEmpty</li>
<li>清空队列——clear</li>
</ul>
<h4 id="基于对象实现队列及其方法"><a href="#基于对象实现队列及其方法-1" class="headerlink" title="基于对象实现队列及其方法"></a>基于对象实现队列及其方法</h4><blockquote>
<p>用数组实现较为简单，这里就写了，直接用对象开写！</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deque</span> = &#123;&#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lowsetCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> - <span class="variable language_">this</span>.<span class="property">lowsetCount</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队头添加元素——addFront</span></span><br><span class="line">    <span class="title function_">addFront</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;  <span class="comment">// 情况1： 如果队列是空的</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">addBack</span>(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lowsetCount</span> &gt; <span class="number">0</span>) &#123;  <span class="comment">// 情况2：如果已经有删除过的情况，即 lowsetCount &gt; 0，顶替lowsetCount-1的位置即可</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span> - <span class="number">1</span>] = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lowsetCount</span> === <span class="number">0</span>) &#123; <span class="comment">// 情况3:为0的情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">count</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">count</span>] = <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">count</span> -<span class="number">1</span>];</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lowsetCount</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="number">0</span>] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队尾添加元素——addBack</span></span><br><span class="line">    <span class="title function_">addBack</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">count</span>] = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队头移除元素——removeFront</span></span><br><span class="line">    <span class="title function_">removeFront</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span>];</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lowsetCount</span>++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队尾移除元素——removeBack</span></span><br><span class="line">    <span class="title function_">removeBack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看队头元素——peekFont</span></span><br><span class="line">    <span class="title function_">peekFront</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看队尾元素——peekBack</span></span><br><span class="line">    <span class="title function_">peekBack</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">count</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查队列是否为空——isEmpty</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> - <span class="variable language_">this</span>.<span class="property">lowsetCount</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空队列——clear</span></span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = &#123;&#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lowsetCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// toString()</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> objString = <span class="title class_">String</span>(<span class="variable language_">this</span>.<span class="property">deque</span>[<span class="variable language_">this</span>.<span class="property">lowsetCount</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lowsetCount</span>+<span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">count</span>; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.deque[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用一下吧~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deque = <span class="keyword">new</span> <span class="title class_">Deque</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deque.<span class="title function_">isEmpty</span>());  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">deque.<span class="title function_">addBack</span>(<span class="number">1</span>);</span><br><span class="line">deque.<span class="title function_">addBack</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deque.<span class="title function_">toString</span>());   <span class="comment">// &#x27;1,2&#x27;</span></span><br><span class="line"></span><br><span class="line">deque.<span class="title function_">addBack</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deque.<span class="title function_">toString</span>());   <span class="comment">// &#x27;1,2,3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deque.<span class="title function_">size</span>());   <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deque.<span class="title function_">isEmpty</span>());   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">deque.<span class="title function_">removeFront</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deque.<span class="title function_">toString</span>());   <span class="comment">// &#x27;2,3&#x27;</span></span><br><span class="line"></span><br><span class="line">deque.<span class="title function_">removeBack</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deque.<span class="title function_">toString</span>());   <span class="comment">// &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="双端队列应用"><a href="#双端队列应用" class="headerlink" title="双端队列应用"></a>双端队列应用</h4><ul>
<li>浏览器撤销和回退操作</li>
<li>判断回文子串</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录_数组基础</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 | 栈和队列相互实现（含JS实现）</title>
    <url>/2022/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9B%B8%E4%BA%92%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>队列具有先进先出的特点，栈具有先进后出的特点，栈和队列互转是经常遇到的情况</p>
</blockquote>
<p>参考LeetCode原题：</p>
<p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></p>
<p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p>
<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><ul>
<li>push</li>
<li>pop</li>
<li>top</li>
<li>empty</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue1</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue2</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// push to back</span></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue2</span>.<span class="title function_">push</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue2</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="title function_">shift</span>())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">queue2</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue2</span>.<span class="title function_">shift</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：因为是队列，所以只能是pop to front即使用shift()</span></span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="title function_">shift</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// top：要获取的是栈顶元素，对应于队列是队尾元素</span></span><br><span class="line">    <span class="title function_">top</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue1</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// empty 判断栈是否为空</span></span><br><span class="line">    <span class="title function_">empty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="property">length</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><ul>
<li>push</li>
<li>pop</li>
<li>peek</li>
<li>empty</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack1</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack2</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// push</span></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="title function_">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pop from bcak 即使用pop方法</span></span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="title function_">pop</span>());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出对头元素 栈只能从后面取，即栈顶元素，所以要交换</span></span><br><span class="line">    <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="title function_">pop</span>());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack2</span>[<span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="property">length</span> -<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断为空</span></span><br><span class="line">    <span class="title function_">empty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="property">length</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 | 链表</title>
    <url>/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="链表基础知识"><a href="#链表基础知识" class="headerlink" title="链表基础知识"></a>链表基础知识</h3><h4 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h4><p>链表是一种通过指针串在一起的线性结构，每一个节点由两部分组成：<strong>数据域</strong>和<strong>指针域</strong>（用于存放指向下一个节点的指针），最后一个指针域指向null（空指针）</p>
<img src="/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8.png" class title="链表">

<p>[head：链表头节点，链表入口节点]</p>
<h4 id="链表的存储方式"><a href="#链表的存储方式" class="headerlink" title="链表的存储方式"></a>链表的存储方式</h4><p>链表不是连续分布的【区别于数组】，链表是通过指针域连接在内存中的节点，所以链表中的节点在内存中不是连续分布的，而是散乱分布在内存中的某地址上的，分配机制取决于操作系统的内存管理</p>
<img src="/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" class title="链表的内存管理">

<h3 id="链表方法"><a href="#链表方法" class="headerlink" title="链表方法"></a>链表方法</h3><ul>
<li>创建链表</li>
<li>插入节点<ul>
<li>末尾插入——push(val)<ul>
<li>链表为空——添加第一个元素</li>
<li>链表不为空——追加元素</li>
</ul>
</li>
<li>任何位置插入——insert(val, position)</li>
</ul>
</li>
<li>移除元素<ul>
<li>根据位置移除——removeAt(position)</li>
<li>根据元素值移除——remove(val)</li>
</ul>
</li>
<li>拓展<ul>
<li>查找是否存在val的节点——indexOf(val)</li>
<li>链表是否为空——isEmpty()</li>
<li>链表长度——size()</li>
<li>获取链表节点值——toString()</li>
</ul>
</li>
</ul>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NodeList</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val ? val : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = next ? next : <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;   <span class="comment">// 记录节点个数，也就是链表长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加节点</span></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">NodeList</span>(val, <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况1：如果没有head节点</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 情况2：有head节点</span></span><br><span class="line">            <span class="keyword">let</span> current = head;</span><br><span class="line">            <span class="keyword">while</span> (current.<span class="property">next</span>) &#123;</span><br><span class="line">                current = current.<span class="property">next</span>;   <span class="comment">// 找到末尾节点</span></span><br><span class="line">            &#125;;</span><br><span class="line">            current.<span class="property">next</span> = node; <span class="comment">// 末尾指向新节点</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到XX位置的node</span></span><br><span class="line">    <span class="title function_">getElementAt</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">                node = node.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除元素</span></span><br><span class="line">    <span class="title function_">removeAt</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查index的情况</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">head</span> = current.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="title function_">getElementAt</span>(index -<span class="number">1</span>);   <span class="comment">// 找到前一个节点</span></span><br><span class="line">                <span class="keyword">const</span> current = previous.<span class="property">next</span>;</span><br><span class="line">                previous.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">            <span class="keyword">return</span> current.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在任意位置增加节点</span></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">val, index</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查index的情况</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">NodeList</span>(val, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 如果是第一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">                node.<span class="property">next</span> = current;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="title function_">getElementAt</span>(index -<span class="number">1</span>);   <span class="comment">// 找到前一个节点</span></span><br><span class="line">                node.<span class="property">next</span> = previous.<span class="property">next</span>;</span><br><span class="line">                previous.<span class="property">next</span> = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 没有添加元素到链表</span></span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到元素所在位置</span></span><br><span class="line">    <span class="title function_">indexOf</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">count</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">count</span> !== <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.<span class="property">val</span> === val) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 没有找到啦~</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isEmpty</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="title function_">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// toString()</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.head.val&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">while</span> (current) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;current.val&#125;</span>`</span>;</span><br><span class="line">            current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表和普通链表的区别在于：</p>
<p>在链表中，一个节点只有链向下一个节点的链接；而在双向链表中，链表是双向的：一个链向前一个节点，一个链向后一个节点</p>
<img src="/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" class title="双向链表">

<p>双向链表不用next而用prev和tail指针代替</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleNodeList</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val, prev, tail</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val ? val : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">prev</span> = prev ? prev : <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span> = tail ? tail : <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到XX位置的node</span></span><br><span class="line">    <span class="title function_">getElementAt</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">                node = node.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写insert方法</span></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">val, index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">DoubleNodeList</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">let</span> current = head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 场景1：第一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">tail</span> = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">                    current.<span class="property">prev</span> = node;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">                &#125;  <span class="comment">// 场景2：末尾</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">                current = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">                current.<span class="property">next</span> = node;</span><br><span class="line">                node.<span class="property">prev</span> = current;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">tail</span> = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 场景3：中间位置</span></span><br><span class="line">                <span class="keyword">const</span> previous = <span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index - <span class="number">1</span>);</span><br><span class="line">                current = previous.<span class="property">next</span>;</span><br><span class="line">                node.<span class="property">next</span> = current;</span><br><span class="line">                previous.<span class="property">next</span> = node;</span><br><span class="line">                current.<span class="property">prev</span> = node;</span><br><span class="line">                node.<span class="property">prev</span> = previous;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写removeAt方法</span></span><br><span class="line">    <span class="title function_">removeAt</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="variable language_">this</span>.<span class="property">count</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">head</span> = current.<span class="property">next</span>;</span><br><span class="line">                <span class="comment">// 如果只有一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> === <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="variable language_">this</span>.<span class="property">count</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                current = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">tail</span> = current.<span class="property">prev</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = <span class="literal">undefined</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 建议这个过程可以画图</span></span><br><span class="line">                current = <span class="variable language_">this</span>.<span class="title function_">getElementAt</span>(index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">const</span> previous = current.<span class="property">prev</span>;</span><br><span class="line">                previous.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">                current.<span class="property">next</span>.<span class="property">prev</span> = previous;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">            <span class="keyword">return</span> current.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表可以向单链表一样引用，也可以像双链表一样引用，特点在于最后一个元素指向链表中的某一个节点，而不是null</p>
<img src="/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" class title="循环链表">

<h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><p>有序链表指元素有序的链表结构</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录_链表</a></p>
]]></content>
      <categories>
        <category>手写原理</category>
        <category>JavaScript</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写原理</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS | 判断是否为子矩阵</title>
    <url>/2022/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/DFS_%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<blockquote>
<p>题目来源于某次蔚来笔试~</p>
<p>本渣只能想到这一种方法！感觉好暴力啊！截至目前还没有想到更好的方法呜呜~但是这种方法是可以做的！</p>
</blockquote>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有两个矩阵，矩阵1（m×m），矩阵2（n×n），判断矩阵2是不是矩阵1的子矩阵，若是输出Yes，若不是输出No</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = [</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = [</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 &#x27;Yes&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>设两个指针<code>i</code>和<code>j</code>，用于遍历<code>m1</code>，找到<code>m1[i][j] ===  m2[0][0]</code></p>
</li>
<li><p>设置指针<code>a</code>和<code>b</code>，用于遍历<code>m2</code>，同时<code>i+a</code>和<code>j+b</code>继续遍历<code>m1</code></p>
<ul>
<li>设置边界<ul>
<li><code>i+a &gt;= m1.length</code>  || <code>j+b &gt;= m2.length</code> 返回false</li>
<li><code>m1[i+a][j+b] !== m2[a][b]</code> 返回false</li>
</ul>
</li>
<li>满足条件<ul>
<li><code>a === m2.length -1 &amp;&amp; b === m2.length -1</code>， 返回true</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">matrix1, matrix2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = matrix1.<span class="property">length</span>, n= matrix2.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 用于判断是否存在符合的情况</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;    <span class="comment">// 初始条件为false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix1[i][j] === matrix2[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">dfs</span>(i, j)) flag = <span class="literal">true</span>;  <span class="comment">// 只要有一次满足，就可以~</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? <span class="string">&#x27;Yes&#x27;</span> : <span class="string">&#x27;No&#x27;</span>; <span class="comment">// 只要有一次满足，就为true，如果一次都没满足，就是false</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; n; b++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i+a &gt;= n || j+b &gt;= n || matrix1[i+a][j+b] !== matrix2[a][b]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eg1</span></span><br><span class="line"><span class="keyword">const</span> m1 = [</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = [</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(m1, m2)) <span class="comment">// &#x27;Yes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg2</span></span><br><span class="line"><span class="keyword">const</span> m1 = [</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = [</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;.&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(m1, m2))  <span class="comment">// No</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
